
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Emprego
 * 
 */
export type Emprego = $Result.DefaultSelection<Prisma.$EmpregoPayload>
/**
 * Model Residencia
 * 
 */
export type Residencia = $Result.DefaultSelection<Prisma.$ResidenciaPayload>
/**
 * Model Papel
 * 
 */
export type Papel = $Result.DefaultSelection<Prisma.$PapelPayload>
/**
 * Model Pessoa
 * 
 */
export type Pessoa = $Result.DefaultSelection<Prisma.$PessoaPayload>
/**
 * Model Conta
 * 
 */
export type Conta = $Result.DefaultSelection<Prisma.$ContaPayload>
/**
 * Model Conjugue
 * 
 */
export type Conjugue = $Result.DefaultSelection<Prisma.$ConjuguePayload>
/**
 * Model Documento
 * 
 */
export type Documento = $Result.DefaultSelection<Prisma.$DocumentoPayload>
/**
 * Model Devedor
 * 
 */
export type Devedor = $Result.DefaultSelection<Prisma.$DevedorPayload>
/**
 * Model Investidor
 * 
 */
export type Investidor = $Result.DefaultSelection<Prisma.$InvestidorPayload>
/**
 * Model Reclamacao
 * 
 */
export type Reclamacao = $Result.DefaultSelection<Prisma.$ReclamacaoPayload>
/**
 * Model Proponente
 * 
 */
export type Proponente = $Result.DefaultSelection<Prisma.$ProponentePayload>
/**
 * Model Solidario
 * 
 */
export type Solidario = $Result.DefaultSelection<Prisma.$SolidarioPayload>
/**
 * Model Movel
 * 
 */
export type Movel = $Result.DefaultSelection<Prisma.$MovelPayload>
/**
 * Model Credito
 * 
 */
export type Credito = $Result.DefaultSelection<Prisma.$CreditoPayload>
/**
 * Model Emprestimo
 * 
 */
export type Emprestimo = $Result.DefaultSelection<Prisma.$EmprestimoPayload>
/**
 * Model EmprestimoSolidario
 * 
 */
export type EmprestimoSolidario = $Result.DefaultSelection<Prisma.$EmprestimoSolidarioPayload>
/**
 * Model CreditoSolidario
 * 
 */
export type CreditoSolidario = $Result.DefaultSelection<Prisma.$CreditoSolidarioPayload>
/**
 * Model Diversificacao
 * 
 */
export type Diversificacao = $Result.DefaultSelection<Prisma.$DiversificacaoPayload>
/**
 * Model Saque
 * 
 */
export type Saque = $Result.DefaultSelection<Prisma.$SaquePayload>
/**
 * Model Deposito
 * 
 */
export type Deposito = $Result.DefaultSelection<Prisma.$DepositoPayload>
/**
 * Model Carteira
 * 
 */
export type Carteira = $Result.DefaultSelection<Prisma.$CarteiraPayload>
/**
 * Model Pagamento
 * 
 */
export type Pagamento = $Result.DefaultSelection<Prisma.$PagamentoPayload>
/**
 * Model Reembolso
 * 
 */
export type Reembolso = $Result.DefaultSelection<Prisma.$ReembolsoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Genero: {
  MASCULINO: 'MASCULINO',
  FEMININO: 'FEMININO'
};

export type Genero = (typeof Genero)[keyof typeof Genero]


export const Propriedade: {
  PROPRIA: 'PROPRIA',
  RENDA: 'RENDA'
};

export type Propriedade = (typeof Propriedade)[keyof typeof Propriedade]


export const Sector: {
  PUBLICO: 'PUBLICO',
  PRIVADO: 'PRIVADO'
};

export type Sector = (typeof Sector)[keyof typeof Sector]


export const Area: {
  ADMINISTRACAO_PUBLICA: 'ADMINISTRACAO_PUBLICA',
  EDUCACAO: 'EDUCACAO',
  SAUDE: 'SAUDE',
  DEFESA_SEGURANCA: 'DEFESA_SEGURANCA',
  ENERGIA: 'ENERGIA',
  PETROLEO: 'PETROLEO',
  MINERACAO: 'MINERACAO',
  FINANCAS: 'FINANCAS',
  CONSTRUCAO: 'CONSTRUCAO',
  TECNOLOGIA: 'TECNOLOGIA',
  COMERCIO: 'COMERCIO',
  AGRICULTURA: 'AGRICULTURA',
  TURISMO: 'TURISMO'
};

export type Area = (typeof Area)[keyof typeof Area]


export const Comprovativo: {
  BILHETE: 'BILHETE',
  DECLARACAO_TRABALHO: 'DECLARACAO_TRABALHO',
  DECLARACAO_SEGURO: 'DECLARACAO_SEGURO',
  BEM_MOVEL: 'BEM_MOVEL',
  ORDEM_DEBITO: 'ORDEM_DEBITO',
  DEPOSITO: 'DEPOSITO',
  LEVANTAMENTO: 'LEVANTAMENTO',
  RECIBO: 'RECIBO'
};

export type Comprovativo = (typeof Comprovativo)[keyof typeof Comprovativo]


export const Parentesco: {
  PAI: 'PAI',
  MAE: 'MAE',
  FILHO: 'FILHO',
  FILHA: 'FILHA',
  AVO: 'AVO',
  NETO: 'NETO',
  NETA: 'NETA',
  IRMAO: 'IRMAO',
  IRMA: 'IRMA',
  TIO: 'TIO',
  TIA: 'TIA',
  SOBRINHO: 'SOBRINHO',
  SOBRINHA: 'SOBRINHA',
  PRIMO: 'PRIMO',
  PRIMA: 'PRIMA',
  CUNHADO: 'CUNHADO',
  CUNHADA: 'CUNHADA',
  SOGRO: 'SOGRO',
  SOGRA: 'SOGRA',
  GENRO: 'GENRO',
  NORA: 'NORA',
  ENTEADO: 'ENTEADO',
  ENTEADA: 'ENTEADA',
  PADRASTO: 'PADRASTO',
  MADRASTA: 'MADRASTA'
};

export type Parentesco = (typeof Parentesco)[keyof typeof Parentesco]


export const Aval: {
  CREDITO: 'CREDITO',
  EMPRESTIMO: 'EMPRESTIMO'
};

export type Aval = (typeof Aval)[keyof typeof Aval]


export const Modelo: {
  CARRO: 'CARRO',
  MOTO: 'MOTO'
};

export type Modelo = (typeof Modelo)[keyof typeof Modelo]


export const Progresso: {
  PENDENTE: 'PENDENTE',
  CONCLUIDO: 'CONCLUIDO',
  CANCELADO: 'CANCELADO'
};

export type Progresso = (typeof Progresso)[keyof typeof Progresso]


export const Produto: {
  CONSUMO: 'CONSUMO',
  DECIMA: 'DECIMA',
  VIGESSIMA: 'VIGESSIMA',
  MENSAL: 'MENSAL'
};

export type Produto = (typeof Produto)[keyof typeof Produto]


export const Perfil: {
  ADMIN: 'ADMIN',
  ANALISTA: 'ANALISTA'
};

export type Perfil = (typeof Perfil)[keyof typeof Perfil]


export const Estado: {
  SOLTEIRO: 'SOLTEIRO',
  CASADO: 'CASADO'
};

export type Estado = (typeof Estado)[keyof typeof Estado]

}

export type Genero = $Enums.Genero

export const Genero: typeof $Enums.Genero

export type Propriedade = $Enums.Propriedade

export const Propriedade: typeof $Enums.Propriedade

export type Sector = $Enums.Sector

export const Sector: typeof $Enums.Sector

export type Area = $Enums.Area

export const Area: typeof $Enums.Area

export type Comprovativo = $Enums.Comprovativo

export const Comprovativo: typeof $Enums.Comprovativo

export type Parentesco = $Enums.Parentesco

export const Parentesco: typeof $Enums.Parentesco

export type Aval = $Enums.Aval

export const Aval: typeof $Enums.Aval

export type Modelo = $Enums.Modelo

export const Modelo: typeof $Enums.Modelo

export type Progresso = $Enums.Progresso

export const Progresso: typeof $Enums.Progresso

export type Produto = $Enums.Produto

export const Produto: typeof $Enums.Produto

export type Perfil = $Enums.Perfil

export const Perfil: typeof $Enums.Perfil

export type Estado = $Enums.Estado

export const Estado: typeof $Enums.Estado

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emprego`: Exposes CRUD operations for the **Emprego** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empregos
    * const empregos = await prisma.emprego.findMany()
    * ```
    */
  get emprego(): Prisma.EmpregoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.residencia`: Exposes CRUD operations for the **Residencia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Residencias
    * const residencias = await prisma.residencia.findMany()
    * ```
    */
  get residencia(): Prisma.ResidenciaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.papel`: Exposes CRUD operations for the **Papel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Papels
    * const papels = await prisma.papel.findMany()
    * ```
    */
  get papel(): Prisma.PapelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pessoa`: Exposes CRUD operations for the **Pessoa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pessoas
    * const pessoas = await prisma.pessoa.findMany()
    * ```
    */
  get pessoa(): Prisma.PessoaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conta`: Exposes CRUD operations for the **Conta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contas
    * const contas = await prisma.conta.findMany()
    * ```
    */
  get conta(): Prisma.ContaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conjugue`: Exposes CRUD operations for the **Conjugue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conjugues
    * const conjugues = await prisma.conjugue.findMany()
    * ```
    */
  get conjugue(): Prisma.ConjugueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documento`: Exposes CRUD operations for the **Documento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documentos
    * const documentos = await prisma.documento.findMany()
    * ```
    */
  get documento(): Prisma.DocumentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.devedor`: Exposes CRUD operations for the **Devedor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devedors
    * const devedors = await prisma.devedor.findMany()
    * ```
    */
  get devedor(): Prisma.DevedorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.investidor`: Exposes CRUD operations for the **Investidor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investidors
    * const investidors = await prisma.investidor.findMany()
    * ```
    */
  get investidor(): Prisma.InvestidorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reclamacao`: Exposes CRUD operations for the **Reclamacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reclamacaos
    * const reclamacaos = await prisma.reclamacao.findMany()
    * ```
    */
  get reclamacao(): Prisma.ReclamacaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proponente`: Exposes CRUD operations for the **Proponente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proponentes
    * const proponentes = await prisma.proponente.findMany()
    * ```
    */
  get proponente(): Prisma.ProponenteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.solidario`: Exposes CRUD operations for the **Solidario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Solidarios
    * const solidarios = await prisma.solidario.findMany()
    * ```
    */
  get solidario(): Prisma.SolidarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.movel`: Exposes CRUD operations for the **Movel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Movels
    * const movels = await prisma.movel.findMany()
    * ```
    */
  get movel(): Prisma.MovelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.credito`: Exposes CRUD operations for the **Credito** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Creditos
    * const creditos = await prisma.credito.findMany()
    * ```
    */
  get credito(): Prisma.CreditoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emprestimo`: Exposes CRUD operations for the **Emprestimo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emprestimos
    * const emprestimos = await prisma.emprestimo.findMany()
    * ```
    */
  get emprestimo(): Prisma.EmprestimoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emprestimoSolidario`: Exposes CRUD operations for the **EmprestimoSolidario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmprestimoSolidarios
    * const emprestimoSolidarios = await prisma.emprestimoSolidario.findMany()
    * ```
    */
  get emprestimoSolidario(): Prisma.EmprestimoSolidarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditoSolidario`: Exposes CRUD operations for the **CreditoSolidario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditoSolidarios
    * const creditoSolidarios = await prisma.creditoSolidario.findMany()
    * ```
    */
  get creditoSolidario(): Prisma.CreditoSolidarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.diversificacao`: Exposes CRUD operations for the **Diversificacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diversificacaos
    * const diversificacaos = await prisma.diversificacao.findMany()
    * ```
    */
  get diversificacao(): Prisma.DiversificacaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saque`: Exposes CRUD operations for the **Saque** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Saques
    * const saques = await prisma.saque.findMany()
    * ```
    */
  get saque(): Prisma.SaqueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deposito`: Exposes CRUD operations for the **Deposito** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Depositos
    * const depositos = await prisma.deposito.findMany()
    * ```
    */
  get deposito(): Prisma.DepositoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.carteira`: Exposes CRUD operations for the **Carteira** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carteiras
    * const carteiras = await prisma.carteira.findMany()
    * ```
    */
  get carteira(): Prisma.CarteiraDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pagamento`: Exposes CRUD operations for the **Pagamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagamentos
    * const pagamentos = await prisma.pagamento.findMany()
    * ```
    */
  get pagamento(): Prisma.PagamentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reembolso`: Exposes CRUD operations for the **Reembolso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reembolsos
    * const reembolsos = await prisma.reembolso.findMany()
    * ```
    */
  get reembolso(): Prisma.ReembolsoDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Emprego: 'Emprego',
    Residencia: 'Residencia',
    Papel: 'Papel',
    Pessoa: 'Pessoa',
    Conta: 'Conta',
    Conjugue: 'Conjugue',
    Documento: 'Documento',
    Devedor: 'Devedor',
    Investidor: 'Investidor',
    Reclamacao: 'Reclamacao',
    Proponente: 'Proponente',
    Solidario: 'Solidario',
    Movel: 'Movel',
    Credito: 'Credito',
    Emprestimo: 'Emprestimo',
    EmprestimoSolidario: 'EmprestimoSolidario',
    CreditoSolidario: 'CreditoSolidario',
    Diversificacao: 'Diversificacao',
    Saque: 'Saque',
    Deposito: 'Deposito',
    Carteira: 'Carteira',
    Pagamento: 'Pagamento',
    Reembolso: 'Reembolso'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "emprego" | "residencia" | "papel" | "pessoa" | "conta" | "conjugue" | "documento" | "devedor" | "investidor" | "reclamacao" | "proponente" | "solidario" | "movel" | "credito" | "emprestimo" | "emprestimoSolidario" | "creditoSolidario" | "diversificacao" | "saque" | "deposito" | "carteira" | "pagamento" | "reembolso"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Emprego: {
        payload: Prisma.$EmpregoPayload<ExtArgs>
        fields: Prisma.EmpregoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmpregoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpregoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmpregoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpregoPayload>
          }
          findFirst: {
            args: Prisma.EmpregoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpregoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmpregoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpregoPayload>
          }
          findMany: {
            args: Prisma.EmpregoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpregoPayload>[]
          }
          create: {
            args: Prisma.EmpregoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpregoPayload>
          }
          createMany: {
            args: Prisma.EmpregoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmpregoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpregoPayload>
          }
          update: {
            args: Prisma.EmpregoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpregoPayload>
          }
          deleteMany: {
            args: Prisma.EmpregoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmpregoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmpregoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpregoPayload>
          }
          aggregate: {
            args: Prisma.EmpregoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmprego>
          }
          groupBy: {
            args: Prisma.EmpregoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpregoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmpregoCountArgs<ExtArgs>
            result: $Utils.Optional<EmpregoCountAggregateOutputType> | number
          }
        }
      }
      Residencia: {
        payload: Prisma.$ResidenciaPayload<ExtArgs>
        fields: Prisma.ResidenciaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResidenciaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidenciaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResidenciaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidenciaPayload>
          }
          findFirst: {
            args: Prisma.ResidenciaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidenciaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResidenciaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidenciaPayload>
          }
          findMany: {
            args: Prisma.ResidenciaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidenciaPayload>[]
          }
          create: {
            args: Prisma.ResidenciaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidenciaPayload>
          }
          createMany: {
            args: Prisma.ResidenciaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ResidenciaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidenciaPayload>
          }
          update: {
            args: Prisma.ResidenciaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidenciaPayload>
          }
          deleteMany: {
            args: Prisma.ResidenciaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResidenciaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResidenciaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidenciaPayload>
          }
          aggregate: {
            args: Prisma.ResidenciaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResidencia>
          }
          groupBy: {
            args: Prisma.ResidenciaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResidenciaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResidenciaCountArgs<ExtArgs>
            result: $Utils.Optional<ResidenciaCountAggregateOutputType> | number
          }
        }
      }
      Papel: {
        payload: Prisma.$PapelPayload<ExtArgs>
        fields: Prisma.PapelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PapelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PapelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapelPayload>
          }
          findFirst: {
            args: Prisma.PapelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PapelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapelPayload>
          }
          findMany: {
            args: Prisma.PapelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapelPayload>[]
          }
          create: {
            args: Prisma.PapelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapelPayload>
          }
          createMany: {
            args: Prisma.PapelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PapelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapelPayload>
          }
          update: {
            args: Prisma.PapelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapelPayload>
          }
          deleteMany: {
            args: Prisma.PapelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PapelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PapelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapelPayload>
          }
          aggregate: {
            args: Prisma.PapelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePapel>
          }
          groupBy: {
            args: Prisma.PapelGroupByArgs<ExtArgs>
            result: $Utils.Optional<PapelGroupByOutputType>[]
          }
          count: {
            args: Prisma.PapelCountArgs<ExtArgs>
            result: $Utils.Optional<PapelCountAggregateOutputType> | number
          }
        }
      }
      Pessoa: {
        payload: Prisma.$PessoaPayload<ExtArgs>
        fields: Prisma.PessoaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PessoaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PessoaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload>
          }
          findFirst: {
            args: Prisma.PessoaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PessoaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload>
          }
          findMany: {
            args: Prisma.PessoaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload>[]
          }
          create: {
            args: Prisma.PessoaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload>
          }
          createMany: {
            args: Prisma.PessoaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PessoaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload>
          }
          update: {
            args: Prisma.PessoaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload>
          }
          deleteMany: {
            args: Prisma.PessoaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PessoaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PessoaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload>
          }
          aggregate: {
            args: Prisma.PessoaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePessoa>
          }
          groupBy: {
            args: Prisma.PessoaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PessoaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PessoaCountArgs<ExtArgs>
            result: $Utils.Optional<PessoaCountAggregateOutputType> | number
          }
        }
      }
      Conta: {
        payload: Prisma.$ContaPayload<ExtArgs>
        fields: Prisma.ContaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload>
          }
          findFirst: {
            args: Prisma.ContaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload>
          }
          findMany: {
            args: Prisma.ContaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload>[]
          }
          create: {
            args: Prisma.ContaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload>
          }
          createMany: {
            args: Prisma.ContaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload>
          }
          update: {
            args: Prisma.ContaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload>
          }
          deleteMany: {
            args: Prisma.ContaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload>
          }
          aggregate: {
            args: Prisma.ContaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConta>
          }
          groupBy: {
            args: Prisma.ContaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContaCountArgs<ExtArgs>
            result: $Utils.Optional<ContaCountAggregateOutputType> | number
          }
        }
      }
      Conjugue: {
        payload: Prisma.$ConjuguePayload<ExtArgs>
        fields: Prisma.ConjugueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConjugueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConjuguePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConjugueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConjuguePayload>
          }
          findFirst: {
            args: Prisma.ConjugueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConjuguePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConjugueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConjuguePayload>
          }
          findMany: {
            args: Prisma.ConjugueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConjuguePayload>[]
          }
          create: {
            args: Prisma.ConjugueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConjuguePayload>
          }
          createMany: {
            args: Prisma.ConjugueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ConjugueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConjuguePayload>
          }
          update: {
            args: Prisma.ConjugueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConjuguePayload>
          }
          deleteMany: {
            args: Prisma.ConjugueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConjugueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConjugueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConjuguePayload>
          }
          aggregate: {
            args: Prisma.ConjugueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConjugue>
          }
          groupBy: {
            args: Prisma.ConjugueGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConjugueGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConjugueCountArgs<ExtArgs>
            result: $Utils.Optional<ConjugueCountAggregateOutputType> | number
          }
        }
      }
      Documento: {
        payload: Prisma.$DocumentoPayload<ExtArgs>
        fields: Prisma.DocumentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          findFirst: {
            args: Prisma.DocumentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          findMany: {
            args: Prisma.DocumentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>[]
          }
          create: {
            args: Prisma.DocumentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          createMany: {
            args: Prisma.DocumentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DocumentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          update: {
            args: Prisma.DocumentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          deleteMany: {
            args: Prisma.DocumentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          aggregate: {
            args: Prisma.DocumentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumento>
          }
          groupBy: {
            args: Prisma.DocumentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentoCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentoCountAggregateOutputType> | number
          }
        }
      }
      Devedor: {
        payload: Prisma.$DevedorPayload<ExtArgs>
        fields: Prisma.DevedorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DevedorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevedorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DevedorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevedorPayload>
          }
          findFirst: {
            args: Prisma.DevedorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevedorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DevedorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevedorPayload>
          }
          findMany: {
            args: Prisma.DevedorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevedorPayload>[]
          }
          create: {
            args: Prisma.DevedorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevedorPayload>
          }
          createMany: {
            args: Prisma.DevedorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DevedorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevedorPayload>
          }
          update: {
            args: Prisma.DevedorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevedorPayload>
          }
          deleteMany: {
            args: Prisma.DevedorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DevedorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DevedorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevedorPayload>
          }
          aggregate: {
            args: Prisma.DevedorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevedor>
          }
          groupBy: {
            args: Prisma.DevedorGroupByArgs<ExtArgs>
            result: $Utils.Optional<DevedorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DevedorCountArgs<ExtArgs>
            result: $Utils.Optional<DevedorCountAggregateOutputType> | number
          }
        }
      }
      Investidor: {
        payload: Prisma.$InvestidorPayload<ExtArgs>
        fields: Prisma.InvestidorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestidorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestidorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestidorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestidorPayload>
          }
          findFirst: {
            args: Prisma.InvestidorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestidorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestidorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestidorPayload>
          }
          findMany: {
            args: Prisma.InvestidorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestidorPayload>[]
          }
          create: {
            args: Prisma.InvestidorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestidorPayload>
          }
          createMany: {
            args: Prisma.InvestidorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvestidorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestidorPayload>
          }
          update: {
            args: Prisma.InvestidorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestidorPayload>
          }
          deleteMany: {
            args: Prisma.InvestidorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvestidorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvestidorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestidorPayload>
          }
          aggregate: {
            args: Prisma.InvestidorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestidor>
          }
          groupBy: {
            args: Prisma.InvestidorGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestidorGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvestidorCountArgs<ExtArgs>
            result: $Utils.Optional<InvestidorCountAggregateOutputType> | number
          }
        }
      }
      Reclamacao: {
        payload: Prisma.$ReclamacaoPayload<ExtArgs>
        fields: Prisma.ReclamacaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReclamacaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReclamacaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReclamacaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReclamacaoPayload>
          }
          findFirst: {
            args: Prisma.ReclamacaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReclamacaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReclamacaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReclamacaoPayload>
          }
          findMany: {
            args: Prisma.ReclamacaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReclamacaoPayload>[]
          }
          create: {
            args: Prisma.ReclamacaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReclamacaoPayload>
          }
          createMany: {
            args: Prisma.ReclamacaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReclamacaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReclamacaoPayload>
          }
          update: {
            args: Prisma.ReclamacaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReclamacaoPayload>
          }
          deleteMany: {
            args: Prisma.ReclamacaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReclamacaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReclamacaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReclamacaoPayload>
          }
          aggregate: {
            args: Prisma.ReclamacaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReclamacao>
          }
          groupBy: {
            args: Prisma.ReclamacaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReclamacaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReclamacaoCountArgs<ExtArgs>
            result: $Utils.Optional<ReclamacaoCountAggregateOutputType> | number
          }
        }
      }
      Proponente: {
        payload: Prisma.$ProponentePayload<ExtArgs>
        fields: Prisma.ProponenteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProponenteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProponentePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProponenteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProponentePayload>
          }
          findFirst: {
            args: Prisma.ProponenteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProponentePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProponenteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProponentePayload>
          }
          findMany: {
            args: Prisma.ProponenteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProponentePayload>[]
          }
          create: {
            args: Prisma.ProponenteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProponentePayload>
          }
          createMany: {
            args: Prisma.ProponenteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProponenteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProponentePayload>
          }
          update: {
            args: Prisma.ProponenteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProponentePayload>
          }
          deleteMany: {
            args: Prisma.ProponenteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProponenteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProponenteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProponentePayload>
          }
          aggregate: {
            args: Prisma.ProponenteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProponente>
          }
          groupBy: {
            args: Prisma.ProponenteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProponenteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProponenteCountArgs<ExtArgs>
            result: $Utils.Optional<ProponenteCountAggregateOutputType> | number
          }
        }
      }
      Solidario: {
        payload: Prisma.$SolidarioPayload<ExtArgs>
        fields: Prisma.SolidarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SolidarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolidarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SolidarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolidarioPayload>
          }
          findFirst: {
            args: Prisma.SolidarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolidarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SolidarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolidarioPayload>
          }
          findMany: {
            args: Prisma.SolidarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolidarioPayload>[]
          }
          create: {
            args: Prisma.SolidarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolidarioPayload>
          }
          createMany: {
            args: Prisma.SolidarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SolidarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolidarioPayload>
          }
          update: {
            args: Prisma.SolidarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolidarioPayload>
          }
          deleteMany: {
            args: Prisma.SolidarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SolidarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SolidarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolidarioPayload>
          }
          aggregate: {
            args: Prisma.SolidarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSolidario>
          }
          groupBy: {
            args: Prisma.SolidarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<SolidarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.SolidarioCountArgs<ExtArgs>
            result: $Utils.Optional<SolidarioCountAggregateOutputType> | number
          }
        }
      }
      Movel: {
        payload: Prisma.$MovelPayload<ExtArgs>
        fields: Prisma.MovelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovelPayload>
          }
          findFirst: {
            args: Prisma.MovelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovelPayload>
          }
          findMany: {
            args: Prisma.MovelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovelPayload>[]
          }
          create: {
            args: Prisma.MovelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovelPayload>
          }
          createMany: {
            args: Prisma.MovelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MovelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovelPayload>
          }
          update: {
            args: Prisma.MovelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovelPayload>
          }
          deleteMany: {
            args: Prisma.MovelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MovelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovelPayload>
          }
          aggregate: {
            args: Prisma.MovelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovel>
          }
          groupBy: {
            args: Prisma.MovelGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovelGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovelCountArgs<ExtArgs>
            result: $Utils.Optional<MovelCountAggregateOutputType> | number
          }
        }
      }
      Credito: {
        payload: Prisma.$CreditoPayload<ExtArgs>
        fields: Prisma.CreditoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoPayload>
          }
          findFirst: {
            args: Prisma.CreditoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoPayload>
          }
          findMany: {
            args: Prisma.CreditoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoPayload>[]
          }
          create: {
            args: Prisma.CreditoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoPayload>
          }
          createMany: {
            args: Prisma.CreditoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CreditoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoPayload>
          }
          update: {
            args: Prisma.CreditoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoPayload>
          }
          deleteMany: {
            args: Prisma.CreditoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CreditoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoPayload>
          }
          aggregate: {
            args: Prisma.CreditoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredito>
          }
          groupBy: {
            args: Prisma.CreditoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditoCountArgs<ExtArgs>
            result: $Utils.Optional<CreditoCountAggregateOutputType> | number
          }
        }
      }
      Emprestimo: {
        payload: Prisma.$EmprestimoPayload<ExtArgs>
        fields: Prisma.EmprestimoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmprestimoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmprestimoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoPayload>
          }
          findFirst: {
            args: Prisma.EmprestimoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmprestimoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoPayload>
          }
          findMany: {
            args: Prisma.EmprestimoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoPayload>[]
          }
          create: {
            args: Prisma.EmprestimoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoPayload>
          }
          createMany: {
            args: Prisma.EmprestimoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmprestimoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoPayload>
          }
          update: {
            args: Prisma.EmprestimoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoPayload>
          }
          deleteMany: {
            args: Prisma.EmprestimoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmprestimoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmprestimoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoPayload>
          }
          aggregate: {
            args: Prisma.EmprestimoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmprestimo>
          }
          groupBy: {
            args: Prisma.EmprestimoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmprestimoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmprestimoCountArgs<ExtArgs>
            result: $Utils.Optional<EmprestimoCountAggregateOutputType> | number
          }
        }
      }
      EmprestimoSolidario: {
        payload: Prisma.$EmprestimoSolidarioPayload<ExtArgs>
        fields: Prisma.EmprestimoSolidarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmprestimoSolidarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoSolidarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmprestimoSolidarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoSolidarioPayload>
          }
          findFirst: {
            args: Prisma.EmprestimoSolidarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoSolidarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmprestimoSolidarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoSolidarioPayload>
          }
          findMany: {
            args: Prisma.EmprestimoSolidarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoSolidarioPayload>[]
          }
          create: {
            args: Prisma.EmprestimoSolidarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoSolidarioPayload>
          }
          createMany: {
            args: Prisma.EmprestimoSolidarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmprestimoSolidarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoSolidarioPayload>
          }
          update: {
            args: Prisma.EmprestimoSolidarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoSolidarioPayload>
          }
          deleteMany: {
            args: Prisma.EmprestimoSolidarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmprestimoSolidarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmprestimoSolidarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprestimoSolidarioPayload>
          }
          aggregate: {
            args: Prisma.EmprestimoSolidarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmprestimoSolidario>
          }
          groupBy: {
            args: Prisma.EmprestimoSolidarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmprestimoSolidarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmprestimoSolidarioCountArgs<ExtArgs>
            result: $Utils.Optional<EmprestimoSolidarioCountAggregateOutputType> | number
          }
        }
      }
      CreditoSolidario: {
        payload: Prisma.$CreditoSolidarioPayload<ExtArgs>
        fields: Prisma.CreditoSolidarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditoSolidarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoSolidarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditoSolidarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoSolidarioPayload>
          }
          findFirst: {
            args: Prisma.CreditoSolidarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoSolidarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditoSolidarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoSolidarioPayload>
          }
          findMany: {
            args: Prisma.CreditoSolidarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoSolidarioPayload>[]
          }
          create: {
            args: Prisma.CreditoSolidarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoSolidarioPayload>
          }
          createMany: {
            args: Prisma.CreditoSolidarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CreditoSolidarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoSolidarioPayload>
          }
          update: {
            args: Prisma.CreditoSolidarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoSolidarioPayload>
          }
          deleteMany: {
            args: Prisma.CreditoSolidarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditoSolidarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CreditoSolidarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditoSolidarioPayload>
          }
          aggregate: {
            args: Prisma.CreditoSolidarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditoSolidario>
          }
          groupBy: {
            args: Prisma.CreditoSolidarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditoSolidarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditoSolidarioCountArgs<ExtArgs>
            result: $Utils.Optional<CreditoSolidarioCountAggregateOutputType> | number
          }
        }
      }
      Diversificacao: {
        payload: Prisma.$DiversificacaoPayload<ExtArgs>
        fields: Prisma.DiversificacaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiversificacaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiversificacaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiversificacaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiversificacaoPayload>
          }
          findFirst: {
            args: Prisma.DiversificacaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiversificacaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiversificacaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiversificacaoPayload>
          }
          findMany: {
            args: Prisma.DiversificacaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiversificacaoPayload>[]
          }
          create: {
            args: Prisma.DiversificacaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiversificacaoPayload>
          }
          createMany: {
            args: Prisma.DiversificacaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DiversificacaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiversificacaoPayload>
          }
          update: {
            args: Prisma.DiversificacaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiversificacaoPayload>
          }
          deleteMany: {
            args: Prisma.DiversificacaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiversificacaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DiversificacaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiversificacaoPayload>
          }
          aggregate: {
            args: Prisma.DiversificacaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiversificacao>
          }
          groupBy: {
            args: Prisma.DiversificacaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiversificacaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiversificacaoCountArgs<ExtArgs>
            result: $Utils.Optional<DiversificacaoCountAggregateOutputType> | number
          }
        }
      }
      Saque: {
        payload: Prisma.$SaquePayload<ExtArgs>
        fields: Prisma.SaqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquePayload>
          }
          findFirst: {
            args: Prisma.SaqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquePayload>
          }
          findMany: {
            args: Prisma.SaqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquePayload>[]
          }
          create: {
            args: Prisma.SaqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquePayload>
          }
          createMany: {
            args: Prisma.SaqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SaqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquePayload>
          }
          update: {
            args: Prisma.SaqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquePayload>
          }
          deleteMany: {
            args: Prisma.SaqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquePayload>
          }
          aggregate: {
            args: Prisma.SaqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaque>
          }
          groupBy: {
            args: Prisma.SaqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaqueCountArgs<ExtArgs>
            result: $Utils.Optional<SaqueCountAggregateOutputType> | number
          }
        }
      }
      Deposito: {
        payload: Prisma.$DepositoPayload<ExtArgs>
        fields: Prisma.DepositoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepositoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepositoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositoPayload>
          }
          findFirst: {
            args: Prisma.DepositoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepositoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositoPayload>
          }
          findMany: {
            args: Prisma.DepositoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositoPayload>[]
          }
          create: {
            args: Prisma.DepositoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositoPayload>
          }
          createMany: {
            args: Prisma.DepositoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DepositoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositoPayload>
          }
          update: {
            args: Prisma.DepositoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositoPayload>
          }
          deleteMany: {
            args: Prisma.DepositoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepositoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepositoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositoPayload>
          }
          aggregate: {
            args: Prisma.DepositoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeposito>
          }
          groupBy: {
            args: Prisma.DepositoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepositoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepositoCountArgs<ExtArgs>
            result: $Utils.Optional<DepositoCountAggregateOutputType> | number
          }
        }
      }
      Carteira: {
        payload: Prisma.$CarteiraPayload<ExtArgs>
        fields: Prisma.CarteiraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CarteiraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteiraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CarteiraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteiraPayload>
          }
          findFirst: {
            args: Prisma.CarteiraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteiraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CarteiraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteiraPayload>
          }
          findMany: {
            args: Prisma.CarteiraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteiraPayload>[]
          }
          create: {
            args: Prisma.CarteiraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteiraPayload>
          }
          createMany: {
            args: Prisma.CarteiraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CarteiraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteiraPayload>
          }
          update: {
            args: Prisma.CarteiraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteiraPayload>
          }
          deleteMany: {
            args: Prisma.CarteiraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CarteiraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CarteiraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteiraPayload>
          }
          aggregate: {
            args: Prisma.CarteiraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCarteira>
          }
          groupBy: {
            args: Prisma.CarteiraGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarteiraGroupByOutputType>[]
          }
          count: {
            args: Prisma.CarteiraCountArgs<ExtArgs>
            result: $Utils.Optional<CarteiraCountAggregateOutputType> | number
          }
        }
      }
      Pagamento: {
        payload: Prisma.$PagamentoPayload<ExtArgs>
        fields: Prisma.PagamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PagamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PagamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          findFirst: {
            args: Prisma.PagamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PagamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          findMany: {
            args: Prisma.PagamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>[]
          }
          create: {
            args: Prisma.PagamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          createMany: {
            args: Prisma.PagamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PagamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          update: {
            args: Prisma.PagamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          deleteMany: {
            args: Prisma.PagamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PagamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PagamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          aggregate: {
            args: Prisma.PagamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePagamento>
          }
          groupBy: {
            args: Prisma.PagamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PagamentoCountArgs<ExtArgs>
            result: $Utils.Optional<PagamentoCountAggregateOutputType> | number
          }
        }
      }
      Reembolso: {
        payload: Prisma.$ReembolsoPayload<ExtArgs>
        fields: Prisma.ReembolsoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReembolsoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReembolsoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReembolsoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReembolsoPayload>
          }
          findFirst: {
            args: Prisma.ReembolsoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReembolsoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReembolsoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReembolsoPayload>
          }
          findMany: {
            args: Prisma.ReembolsoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReembolsoPayload>[]
          }
          create: {
            args: Prisma.ReembolsoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReembolsoPayload>
          }
          createMany: {
            args: Prisma.ReembolsoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReembolsoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReembolsoPayload>
          }
          update: {
            args: Prisma.ReembolsoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReembolsoPayload>
          }
          deleteMany: {
            args: Prisma.ReembolsoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReembolsoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReembolsoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReembolsoPayload>
          }
          aggregate: {
            args: Prisma.ReembolsoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReembolso>
          }
          groupBy: {
            args: Prisma.ReembolsoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReembolsoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReembolsoCountArgs<ExtArgs>
            result: $Utils.Optional<ReembolsoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    emprego?: EmpregoOmit
    residencia?: ResidenciaOmit
    papel?: PapelOmit
    pessoa?: PessoaOmit
    conta?: ContaOmit
    conjugue?: ConjugueOmit
    documento?: DocumentoOmit
    devedor?: DevedorOmit
    investidor?: InvestidorOmit
    reclamacao?: ReclamacaoOmit
    proponente?: ProponenteOmit
    solidario?: SolidarioOmit
    movel?: MovelOmit
    credito?: CreditoOmit
    emprestimo?: EmprestimoOmit
    emprestimoSolidario?: EmprestimoSolidarioOmit
    creditoSolidario?: CreditoSolidarioOmit
    diversificacao?: DiversificacaoOmit
    saque?: SaqueOmit
    deposito?: DepositoOmit
    carteira?: CarteiraOmit
    pagamento?: PagamentoOmit
    reembolso?: ReembolsoOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    documento: number
    reclamacao: number
    saque: number
    deposito: number
    solidario: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documento?: boolean | UserCountOutputTypeCountDocumentoArgs
    reclamacao?: boolean | UserCountOutputTypeCountReclamacaoArgs
    saque?: boolean | UserCountOutputTypeCountSaqueArgs
    deposito?: boolean | UserCountOutputTypeCountDepositoArgs
    solidario?: boolean | UserCountOutputTypeCountSolidarioArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReclamacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReclamacaoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSaqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaqueWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDepositoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepositoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSolidarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SolidarioWhereInput
  }


  /**
   * Count Type EmpregoCountOutputType
   */

  export type EmpregoCountOutputType = {
    pessoa: number
  }

  export type EmpregoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | EmpregoCountOutputTypeCountPessoaArgs
  }

  // Custom InputTypes
  /**
   * EmpregoCountOutputType without action
   */
  export type EmpregoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpregoCountOutputType
     */
    select?: EmpregoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmpregoCountOutputType without action
   */
  export type EmpregoCountOutputTypeCountPessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PessoaWhereInput
  }


  /**
   * Count Type ResidenciaCountOutputType
   */

  export type ResidenciaCountOutputType = {
    pessoa: number
  }

  export type ResidenciaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | ResidenciaCountOutputTypeCountPessoaArgs
  }

  // Custom InputTypes
  /**
   * ResidenciaCountOutputType without action
   */
  export type ResidenciaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidenciaCountOutputType
     */
    select?: ResidenciaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResidenciaCountOutputType without action
   */
  export type ResidenciaCountOutputTypeCountPessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PessoaWhereInput
  }


  /**
   * Count Type DevedorCountOutputType
   */

  export type DevedorCountOutputType = {
    credito: number
    movel: number
    pagamento: number
  }

  export type DevedorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credito?: boolean | DevedorCountOutputTypeCountCreditoArgs
    movel?: boolean | DevedorCountOutputTypeCountMovelArgs
    pagamento?: boolean | DevedorCountOutputTypeCountPagamentoArgs
  }

  // Custom InputTypes
  /**
   * DevedorCountOutputType without action
   */
  export type DevedorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevedorCountOutputType
     */
    select?: DevedorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DevedorCountOutputType without action
   */
  export type DevedorCountOutputTypeCountCreditoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditoWhereInput
  }

  /**
   * DevedorCountOutputType without action
   */
  export type DevedorCountOutputTypeCountMovelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovelWhereInput
  }

  /**
   * DevedorCountOutputType without action
   */
  export type DevedorCountOutputTypeCountPagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagamentoWhereInput
  }


  /**
   * Count Type InvestidorCountOutputType
   */

  export type InvestidorCountOutputType = {
    diversificacao: number
  }

  export type InvestidorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diversificacao?: boolean | InvestidorCountOutputTypeCountDiversificacaoArgs
  }

  // Custom InputTypes
  /**
   * InvestidorCountOutputType without action
   */
  export type InvestidorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestidorCountOutputType
     */
    select?: InvestidorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvestidorCountOutputType without action
   */
  export type InvestidorCountOutputTypeCountDiversificacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiversificacaoWhereInput
  }


  /**
   * Count Type ProponenteCountOutputType
   */

  export type ProponenteCountOutputType = {
    emprestimo: number
    reembolso: number
  }

  export type ProponenteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprestimo?: boolean | ProponenteCountOutputTypeCountEmprestimoArgs
    reembolso?: boolean | ProponenteCountOutputTypeCountReembolsoArgs
  }

  // Custom InputTypes
  /**
   * ProponenteCountOutputType without action
   */
  export type ProponenteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProponenteCountOutputType
     */
    select?: ProponenteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProponenteCountOutputType without action
   */
  export type ProponenteCountOutputTypeCountEmprestimoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmprestimoWhereInput
  }

  /**
   * ProponenteCountOutputType without action
   */
  export type ProponenteCountOutputTypeCountReembolsoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReembolsoWhereInput
  }


  /**
   * Count Type SolidarioCountOutputType
   */

  export type SolidarioCountOutputType = {
    emprestimo: number
    credito: number
  }

  export type SolidarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprestimo?: boolean | SolidarioCountOutputTypeCountEmprestimoArgs
    credito?: boolean | SolidarioCountOutputTypeCountCreditoArgs
  }

  // Custom InputTypes
  /**
   * SolidarioCountOutputType without action
   */
  export type SolidarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolidarioCountOutputType
     */
    select?: SolidarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SolidarioCountOutputType without action
   */
  export type SolidarioCountOutputTypeCountEmprestimoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmprestimoSolidarioWhereInput
  }

  /**
   * SolidarioCountOutputType without action
   */
  export type SolidarioCountOutputTypeCountCreditoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditoSolidarioWhereInput
  }


  /**
   * Count Type CreditoCountOutputType
   */

  export type CreditoCountOutputType = {
    solidario: number
  }

  export type CreditoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solidario?: boolean | CreditoCountOutputTypeCountSolidarioArgs
  }

  // Custom InputTypes
  /**
   * CreditoCountOutputType without action
   */
  export type CreditoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditoCountOutputType
     */
    select?: CreditoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CreditoCountOutputType without action
   */
  export type CreditoCountOutputTypeCountSolidarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditoSolidarioWhereInput
  }


  /**
   * Count Type EmprestimoCountOutputType
   */

  export type EmprestimoCountOutputType = {
    diversificacao: number
    solidario: number
  }

  export type EmprestimoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diversificacao?: boolean | EmprestimoCountOutputTypeCountDiversificacaoArgs
    solidario?: boolean | EmprestimoCountOutputTypeCountSolidarioArgs
  }

  // Custom InputTypes
  /**
   * EmprestimoCountOutputType without action
   */
  export type EmprestimoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmprestimoCountOutputType
     */
    select?: EmprestimoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmprestimoCountOutputType without action
   */
  export type EmprestimoCountOutputTypeCountDiversificacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiversificacaoWhereInput
  }

  /**
   * EmprestimoCountOutputType without action
   */
  export type EmprestimoCountOutputTypeCountSolidarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmprestimoSolidarioWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    primeiro_nome: string | null
    segundo_nome: string | null
    password: string | null
    genero: $Enums.Genero | null
    bilhete: string | null
    telemovel: string | null
    email: string | null
    estado: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    primeiro_nome: string | null
    segundo_nome: string | null
    password: string | null
    genero: $Enums.Genero | null
    bilhete: string | null
    telemovel: string | null
    email: string | null
    estado: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    primeiro_nome: number
    segundo_nome: number
    password: number
    genero: number
    bilhete: number
    telemovel: number
    email: number
    estado: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    primeiro_nome?: true
    segundo_nome?: true
    password?: true
    genero?: true
    bilhete?: true
    telemovel?: true
    email?: true
    estado?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    primeiro_nome?: true
    segundo_nome?: true
    password?: true
    genero?: true
    bilhete?: true
    telemovel?: true
    email?: true
    estado?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    primeiro_nome?: true
    segundo_nome?: true
    password?: true
    genero?: true
    bilhete?: true
    telemovel?: true
    email?: true
    estado?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    primeiro_nome?: boolean
    segundo_nome?: boolean
    password?: boolean
    genero?: boolean
    bilhete?: boolean
    telemovel?: boolean
    email?: boolean
    estado?: boolean
    pessoa?: boolean | User$pessoaArgs<ExtArgs>
    documento?: boolean | User$documentoArgs<ExtArgs>
    devedor?: boolean | User$devedorArgs<ExtArgs>
    investidor?: boolean | User$investidorArgs<ExtArgs>
    reclamacao?: boolean | User$reclamacaoArgs<ExtArgs>
    proponente?: boolean | User$proponenteArgs<ExtArgs>
    saque?: boolean | User$saqueArgs<ExtArgs>
    deposito?: boolean | User$depositoArgs<ExtArgs>
    carteira?: boolean | User$carteiraArgs<ExtArgs>
    papel?: boolean | User$papelArgs<ExtArgs>
    solidario?: boolean | User$solidarioArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    primeiro_nome?: boolean
    segundo_nome?: boolean
    password?: boolean
    genero?: boolean
    bilhete?: boolean
    telemovel?: boolean
    email?: boolean
    estado?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "primeiro_nome" | "segundo_nome" | "password" | "genero" | "bilhete" | "telemovel" | "email" | "estado", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | User$pessoaArgs<ExtArgs>
    documento?: boolean | User$documentoArgs<ExtArgs>
    devedor?: boolean | User$devedorArgs<ExtArgs>
    investidor?: boolean | User$investidorArgs<ExtArgs>
    reclamacao?: boolean | User$reclamacaoArgs<ExtArgs>
    proponente?: boolean | User$proponenteArgs<ExtArgs>
    saque?: boolean | User$saqueArgs<ExtArgs>
    deposito?: boolean | User$depositoArgs<ExtArgs>
    carteira?: boolean | User$carteiraArgs<ExtArgs>
    papel?: boolean | User$papelArgs<ExtArgs>
    solidario?: boolean | User$solidarioArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      pessoa: Prisma.$PessoaPayload<ExtArgs> | null
      documento: Prisma.$DocumentoPayload<ExtArgs>[]
      devedor: Prisma.$DevedorPayload<ExtArgs> | null
      investidor: Prisma.$InvestidorPayload<ExtArgs> | null
      reclamacao: Prisma.$ReclamacaoPayload<ExtArgs>[]
      proponente: Prisma.$ProponentePayload<ExtArgs> | null
      saque: Prisma.$SaquePayload<ExtArgs>[]
      deposito: Prisma.$DepositoPayload<ExtArgs>[]
      carteira: Prisma.$CarteiraPayload<ExtArgs> | null
      papel: Prisma.$PapelPayload<ExtArgs> | null
      solidario: Prisma.$SolidarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      primeiro_nome: string
      segundo_nome: string
      password: string
      genero: $Enums.Genero
      bilhete: string
      telemovel: string
      email: string
      estado: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoa<T extends User$pessoaArgs<ExtArgs> = {}>(args?: Subset<T, User$pessoaArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    documento<T extends User$documentoArgs<ExtArgs> = {}>(args?: Subset<T, User$documentoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    devedor<T extends User$devedorArgs<ExtArgs> = {}>(args?: Subset<T, User$devedorArgs<ExtArgs>>): Prisma__DevedorClient<$Result.GetResult<Prisma.$DevedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    investidor<T extends User$investidorArgs<ExtArgs> = {}>(args?: Subset<T, User$investidorArgs<ExtArgs>>): Prisma__InvestidorClient<$Result.GetResult<Prisma.$InvestidorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reclamacao<T extends User$reclamacaoArgs<ExtArgs> = {}>(args?: Subset<T, User$reclamacaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReclamacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proponente<T extends User$proponenteArgs<ExtArgs> = {}>(args?: Subset<T, User$proponenteArgs<ExtArgs>>): Prisma__ProponenteClient<$Result.GetResult<Prisma.$ProponentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    saque<T extends User$saqueArgs<ExtArgs> = {}>(args?: Subset<T, User$saqueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaquePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deposito<T extends User$depositoArgs<ExtArgs> = {}>(args?: Subset<T, User$depositoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    carteira<T extends User$carteiraArgs<ExtArgs> = {}>(args?: Subset<T, User$carteiraArgs<ExtArgs>>): Prisma__CarteiraClient<$Result.GetResult<Prisma.$CarteiraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    papel<T extends User$papelArgs<ExtArgs> = {}>(args?: Subset<T, User$papelArgs<ExtArgs>>): Prisma__PapelClient<$Result.GetResult<Prisma.$PapelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    solidario<T extends User$solidarioArgs<ExtArgs> = {}>(args?: Subset<T, User$solidarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SolidarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly primeiro_nome: FieldRef<"User", 'String'>
    readonly segundo_nome: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly genero: FieldRef<"User", 'Genero'>
    readonly bilhete: FieldRef<"User", 'String'>
    readonly telemovel: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly estado: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.pessoa
   */
  export type User$pessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    where?: PessoaWhereInput
  }

  /**
   * User.documento
   */
  export type User$documentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    where?: DocumentoWhereInput
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    cursor?: DocumentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentoScalarFieldEnum | DocumentoScalarFieldEnum[]
  }

  /**
   * User.devedor
   */
  export type User$devedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devedor
     */
    select?: DevedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devedor
     */
    omit?: DevedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevedorInclude<ExtArgs> | null
    where?: DevedorWhereInput
  }

  /**
   * User.investidor
   */
  export type User$investidorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investidor
     */
    select?: InvestidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investidor
     */
    omit?: InvestidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestidorInclude<ExtArgs> | null
    where?: InvestidorWhereInput
  }

  /**
   * User.reclamacao
   */
  export type User$reclamacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reclamacao
     */
    select?: ReclamacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reclamacao
     */
    omit?: ReclamacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReclamacaoInclude<ExtArgs> | null
    where?: ReclamacaoWhereInput
    orderBy?: ReclamacaoOrderByWithRelationInput | ReclamacaoOrderByWithRelationInput[]
    cursor?: ReclamacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReclamacaoScalarFieldEnum | ReclamacaoScalarFieldEnum[]
  }

  /**
   * User.proponente
   */
  export type User$proponenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proponente
     */
    select?: ProponenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proponente
     */
    omit?: ProponenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProponenteInclude<ExtArgs> | null
    where?: ProponenteWhereInput
  }

  /**
   * User.saque
   */
  export type User$saqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saque
     */
    select?: SaqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saque
     */
    omit?: SaqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaqueInclude<ExtArgs> | null
    where?: SaqueWhereInput
    orderBy?: SaqueOrderByWithRelationInput | SaqueOrderByWithRelationInput[]
    cursor?: SaqueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaqueScalarFieldEnum | SaqueScalarFieldEnum[]
  }

  /**
   * User.deposito
   */
  export type User$depositoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposito
     */
    select?: DepositoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposito
     */
    omit?: DepositoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositoInclude<ExtArgs> | null
    where?: DepositoWhereInput
    orderBy?: DepositoOrderByWithRelationInput | DepositoOrderByWithRelationInput[]
    cursor?: DepositoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepositoScalarFieldEnum | DepositoScalarFieldEnum[]
  }

  /**
   * User.carteira
   */
  export type User$carteiraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteira
     */
    select?: CarteiraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteira
     */
    omit?: CarteiraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarteiraInclude<ExtArgs> | null
    where?: CarteiraWhereInput
  }

  /**
   * User.papel
   */
  export type User$papelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papel
     */
    select?: PapelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papel
     */
    omit?: PapelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapelInclude<ExtArgs> | null
    where?: PapelWhereInput
  }

  /**
   * User.solidario
   */
  export type User$solidarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solidario
     */
    select?: SolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solidario
     */
    omit?: SolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolidarioInclude<ExtArgs> | null
    where?: SolidarioWhereInput
    orderBy?: SolidarioOrderByWithRelationInput | SolidarioOrderByWithRelationInput[]
    cursor?: SolidarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SolidarioScalarFieldEnum | SolidarioScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Emprego
   */

  export type AggregateEmprego = {
    _count: EmpregoCountAggregateOutputType | null
    _avg: EmpregoAvgAggregateOutputType | null
    _sum: EmpregoSumAggregateOutputType | null
    _min: EmpregoMinAggregateOutputType | null
    _max: EmpregoMaxAggregateOutputType | null
  }

  export type EmpregoAvgAggregateOutputType = {
    id: number | null
  }

  export type EmpregoSumAggregateOutputType = {
    id: number | null
  }

  export type EmpregoMinAggregateOutputType = {
    id: number | null
    data_inicio: Date | null
    sector: $Enums.Sector | null
    cargo: string | null
    area: $Enums.Area | null
    estado: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmpregoMaxAggregateOutputType = {
    id: number | null
    data_inicio: Date | null
    sector: $Enums.Sector | null
    cargo: string | null
    area: $Enums.Area | null
    estado: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmpregoCountAggregateOutputType = {
    id: number
    data_inicio: number
    sector: number
    cargo: number
    area: number
    estado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmpregoAvgAggregateInputType = {
    id?: true
  }

  export type EmpregoSumAggregateInputType = {
    id?: true
  }

  export type EmpregoMinAggregateInputType = {
    id?: true
    data_inicio?: true
    sector?: true
    cargo?: true
    area?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmpregoMaxAggregateInputType = {
    id?: true
    data_inicio?: true
    sector?: true
    cargo?: true
    area?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmpregoCountAggregateInputType = {
    id?: true
    data_inicio?: true
    sector?: true
    cargo?: true
    area?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmpregoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emprego to aggregate.
     */
    where?: EmpregoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empregos to fetch.
     */
    orderBy?: EmpregoOrderByWithRelationInput | EmpregoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmpregoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empregos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empregos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Empregos
    **/
    _count?: true | EmpregoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpregoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpregoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpregoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpregoMaxAggregateInputType
  }

  export type GetEmpregoAggregateType<T extends EmpregoAggregateArgs> = {
        [P in keyof T & keyof AggregateEmprego]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmprego[P]>
      : GetScalarType<T[P], AggregateEmprego[P]>
  }




  export type EmpregoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpregoWhereInput
    orderBy?: EmpregoOrderByWithAggregationInput | EmpregoOrderByWithAggregationInput[]
    by: EmpregoScalarFieldEnum[] | EmpregoScalarFieldEnum
    having?: EmpregoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpregoCountAggregateInputType | true
    _avg?: EmpregoAvgAggregateInputType
    _sum?: EmpregoSumAggregateInputType
    _min?: EmpregoMinAggregateInputType
    _max?: EmpregoMaxAggregateInputType
  }

  export type EmpregoGroupByOutputType = {
    id: number
    data_inicio: Date
    sector: $Enums.Sector
    cargo: string
    area: $Enums.Area
    estado: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmpregoCountAggregateOutputType | null
    _avg: EmpregoAvgAggregateOutputType | null
    _sum: EmpregoSumAggregateOutputType | null
    _min: EmpregoMinAggregateOutputType | null
    _max: EmpregoMaxAggregateOutputType | null
  }

  type GetEmpregoGroupByPayload<T extends EmpregoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpregoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpregoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpregoGroupByOutputType[P]>
            : GetScalarType<T[P], EmpregoGroupByOutputType[P]>
        }
      >
    >


  export type EmpregoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data_inicio?: boolean
    sector?: boolean
    cargo?: boolean
    area?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pessoa?: boolean | Emprego$pessoaArgs<ExtArgs>
    _count?: boolean | EmpregoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emprego"]>



  export type EmpregoSelectScalar = {
    id?: boolean
    data_inicio?: boolean
    sector?: boolean
    cargo?: boolean
    area?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmpregoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "data_inicio" | "sector" | "cargo" | "area" | "estado" | "createdAt" | "updatedAt", ExtArgs["result"]["emprego"]>
  export type EmpregoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | Emprego$pessoaArgs<ExtArgs>
    _count?: boolean | EmpregoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmpregoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Emprego"
    objects: {
      pessoa: Prisma.$PessoaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      data_inicio: Date
      sector: $Enums.Sector
      cargo: string
      area: $Enums.Area
      estado: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emprego"]>
    composites: {}
  }

  type EmpregoGetPayload<S extends boolean | null | undefined | EmpregoDefaultArgs> = $Result.GetResult<Prisma.$EmpregoPayload, S>

  type EmpregoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmpregoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmpregoCountAggregateInputType | true
    }

  export interface EmpregoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Emprego'], meta: { name: 'Emprego' } }
    /**
     * Find zero or one Emprego that matches the filter.
     * @param {EmpregoFindUniqueArgs} args - Arguments to find a Emprego
     * @example
     * // Get one Emprego
     * const emprego = await prisma.emprego.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmpregoFindUniqueArgs>(args: SelectSubset<T, EmpregoFindUniqueArgs<ExtArgs>>): Prisma__EmpregoClient<$Result.GetResult<Prisma.$EmpregoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Emprego that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmpregoFindUniqueOrThrowArgs} args - Arguments to find a Emprego
     * @example
     * // Get one Emprego
     * const emprego = await prisma.emprego.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmpregoFindUniqueOrThrowArgs>(args: SelectSubset<T, EmpregoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmpregoClient<$Result.GetResult<Prisma.$EmpregoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emprego that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpregoFindFirstArgs} args - Arguments to find a Emprego
     * @example
     * // Get one Emprego
     * const emprego = await prisma.emprego.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmpregoFindFirstArgs>(args?: SelectSubset<T, EmpregoFindFirstArgs<ExtArgs>>): Prisma__EmpregoClient<$Result.GetResult<Prisma.$EmpregoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emprego that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpregoFindFirstOrThrowArgs} args - Arguments to find a Emprego
     * @example
     * // Get one Emprego
     * const emprego = await prisma.emprego.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmpregoFindFirstOrThrowArgs>(args?: SelectSubset<T, EmpregoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmpregoClient<$Result.GetResult<Prisma.$EmpregoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Empregos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpregoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empregos
     * const empregos = await prisma.emprego.findMany()
     * 
     * // Get first 10 Empregos
     * const empregos = await prisma.emprego.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const empregoWithIdOnly = await prisma.emprego.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmpregoFindManyArgs>(args?: SelectSubset<T, EmpregoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpregoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Emprego.
     * @param {EmpregoCreateArgs} args - Arguments to create a Emprego.
     * @example
     * // Create one Emprego
     * const Emprego = await prisma.emprego.create({
     *   data: {
     *     // ... data to create a Emprego
     *   }
     * })
     * 
     */
    create<T extends EmpregoCreateArgs>(args: SelectSubset<T, EmpregoCreateArgs<ExtArgs>>): Prisma__EmpregoClient<$Result.GetResult<Prisma.$EmpregoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Empregos.
     * @param {EmpregoCreateManyArgs} args - Arguments to create many Empregos.
     * @example
     * // Create many Empregos
     * const emprego = await prisma.emprego.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmpregoCreateManyArgs>(args?: SelectSubset<T, EmpregoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Emprego.
     * @param {EmpregoDeleteArgs} args - Arguments to delete one Emprego.
     * @example
     * // Delete one Emprego
     * const Emprego = await prisma.emprego.delete({
     *   where: {
     *     // ... filter to delete one Emprego
     *   }
     * })
     * 
     */
    delete<T extends EmpregoDeleteArgs>(args: SelectSubset<T, EmpregoDeleteArgs<ExtArgs>>): Prisma__EmpregoClient<$Result.GetResult<Prisma.$EmpregoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Emprego.
     * @param {EmpregoUpdateArgs} args - Arguments to update one Emprego.
     * @example
     * // Update one Emprego
     * const emprego = await prisma.emprego.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmpregoUpdateArgs>(args: SelectSubset<T, EmpregoUpdateArgs<ExtArgs>>): Prisma__EmpregoClient<$Result.GetResult<Prisma.$EmpregoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Empregos.
     * @param {EmpregoDeleteManyArgs} args - Arguments to filter Empregos to delete.
     * @example
     * // Delete a few Empregos
     * const { count } = await prisma.emprego.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmpregoDeleteManyArgs>(args?: SelectSubset<T, EmpregoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empregos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpregoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empregos
     * const emprego = await prisma.emprego.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmpregoUpdateManyArgs>(args: SelectSubset<T, EmpregoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Emprego.
     * @param {EmpregoUpsertArgs} args - Arguments to update or create a Emprego.
     * @example
     * // Update or create a Emprego
     * const emprego = await prisma.emprego.upsert({
     *   create: {
     *     // ... data to create a Emprego
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Emprego we want to update
     *   }
     * })
     */
    upsert<T extends EmpregoUpsertArgs>(args: SelectSubset<T, EmpregoUpsertArgs<ExtArgs>>): Prisma__EmpregoClient<$Result.GetResult<Prisma.$EmpregoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Empregos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpregoCountArgs} args - Arguments to filter Empregos to count.
     * @example
     * // Count the number of Empregos
     * const count = await prisma.emprego.count({
     *   where: {
     *     // ... the filter for the Empregos we want to count
     *   }
     * })
    **/
    count<T extends EmpregoCountArgs>(
      args?: Subset<T, EmpregoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpregoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Emprego.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpregoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpregoAggregateArgs>(args: Subset<T, EmpregoAggregateArgs>): Prisma.PrismaPromise<GetEmpregoAggregateType<T>>

    /**
     * Group by Emprego.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpregoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpregoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpregoGroupByArgs['orderBy'] }
        : { orderBy?: EmpregoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpregoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpregoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Emprego model
   */
  readonly fields: EmpregoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Emprego.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmpregoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoa<T extends Emprego$pessoaArgs<ExtArgs> = {}>(args?: Subset<T, Emprego$pessoaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Emprego model
   */
  interface EmpregoFieldRefs {
    readonly id: FieldRef<"Emprego", 'Int'>
    readonly data_inicio: FieldRef<"Emprego", 'DateTime'>
    readonly sector: FieldRef<"Emprego", 'Sector'>
    readonly cargo: FieldRef<"Emprego", 'String'>
    readonly area: FieldRef<"Emprego", 'Area'>
    readonly estado: FieldRef<"Emprego", 'Boolean'>
    readonly createdAt: FieldRef<"Emprego", 'DateTime'>
    readonly updatedAt: FieldRef<"Emprego", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Emprego findUnique
   */
  export type EmpregoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprego
     */
    select?: EmpregoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprego
     */
    omit?: EmpregoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpregoInclude<ExtArgs> | null
    /**
     * Filter, which Emprego to fetch.
     */
    where: EmpregoWhereUniqueInput
  }

  /**
   * Emprego findUniqueOrThrow
   */
  export type EmpregoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprego
     */
    select?: EmpregoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprego
     */
    omit?: EmpregoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpregoInclude<ExtArgs> | null
    /**
     * Filter, which Emprego to fetch.
     */
    where: EmpregoWhereUniqueInput
  }

  /**
   * Emprego findFirst
   */
  export type EmpregoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprego
     */
    select?: EmpregoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprego
     */
    omit?: EmpregoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpregoInclude<ExtArgs> | null
    /**
     * Filter, which Emprego to fetch.
     */
    where?: EmpregoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empregos to fetch.
     */
    orderBy?: EmpregoOrderByWithRelationInput | EmpregoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empregos.
     */
    cursor?: EmpregoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empregos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empregos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empregos.
     */
    distinct?: EmpregoScalarFieldEnum | EmpregoScalarFieldEnum[]
  }

  /**
   * Emprego findFirstOrThrow
   */
  export type EmpregoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprego
     */
    select?: EmpregoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprego
     */
    omit?: EmpregoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpregoInclude<ExtArgs> | null
    /**
     * Filter, which Emprego to fetch.
     */
    where?: EmpregoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empregos to fetch.
     */
    orderBy?: EmpregoOrderByWithRelationInput | EmpregoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empregos.
     */
    cursor?: EmpregoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empregos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empregos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empregos.
     */
    distinct?: EmpregoScalarFieldEnum | EmpregoScalarFieldEnum[]
  }

  /**
   * Emprego findMany
   */
  export type EmpregoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprego
     */
    select?: EmpregoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprego
     */
    omit?: EmpregoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpregoInclude<ExtArgs> | null
    /**
     * Filter, which Empregos to fetch.
     */
    where?: EmpregoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empregos to fetch.
     */
    orderBy?: EmpregoOrderByWithRelationInput | EmpregoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Empregos.
     */
    cursor?: EmpregoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empregos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empregos.
     */
    skip?: number
    distinct?: EmpregoScalarFieldEnum | EmpregoScalarFieldEnum[]
  }

  /**
   * Emprego create
   */
  export type EmpregoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprego
     */
    select?: EmpregoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprego
     */
    omit?: EmpregoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpregoInclude<ExtArgs> | null
    /**
     * The data needed to create a Emprego.
     */
    data: XOR<EmpregoCreateInput, EmpregoUncheckedCreateInput>
  }

  /**
   * Emprego createMany
   */
  export type EmpregoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Empregos.
     */
    data: EmpregoCreateManyInput | EmpregoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Emprego update
   */
  export type EmpregoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprego
     */
    select?: EmpregoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprego
     */
    omit?: EmpregoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpregoInclude<ExtArgs> | null
    /**
     * The data needed to update a Emprego.
     */
    data: XOR<EmpregoUpdateInput, EmpregoUncheckedUpdateInput>
    /**
     * Choose, which Emprego to update.
     */
    where: EmpregoWhereUniqueInput
  }

  /**
   * Emprego updateMany
   */
  export type EmpregoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Empregos.
     */
    data: XOR<EmpregoUpdateManyMutationInput, EmpregoUncheckedUpdateManyInput>
    /**
     * Filter which Empregos to update
     */
    where?: EmpregoWhereInput
    /**
     * Limit how many Empregos to update.
     */
    limit?: number
  }

  /**
   * Emprego upsert
   */
  export type EmpregoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprego
     */
    select?: EmpregoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprego
     */
    omit?: EmpregoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpregoInclude<ExtArgs> | null
    /**
     * The filter to search for the Emprego to update in case it exists.
     */
    where: EmpregoWhereUniqueInput
    /**
     * In case the Emprego found by the `where` argument doesn't exist, create a new Emprego with this data.
     */
    create: XOR<EmpregoCreateInput, EmpregoUncheckedCreateInput>
    /**
     * In case the Emprego was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmpregoUpdateInput, EmpregoUncheckedUpdateInput>
  }

  /**
   * Emprego delete
   */
  export type EmpregoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprego
     */
    select?: EmpregoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprego
     */
    omit?: EmpregoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpregoInclude<ExtArgs> | null
    /**
     * Filter which Emprego to delete.
     */
    where: EmpregoWhereUniqueInput
  }

  /**
   * Emprego deleteMany
   */
  export type EmpregoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empregos to delete
     */
    where?: EmpregoWhereInput
    /**
     * Limit how many Empregos to delete.
     */
    limit?: number
  }

  /**
   * Emprego.pessoa
   */
  export type Emprego$pessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    where?: PessoaWhereInput
    orderBy?: PessoaOrderByWithRelationInput | PessoaOrderByWithRelationInput[]
    cursor?: PessoaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * Emprego without action
   */
  export type EmpregoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprego
     */
    select?: EmpregoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprego
     */
    omit?: EmpregoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpregoInclude<ExtArgs> | null
  }


  /**
   * Model Residencia
   */

  export type AggregateResidencia = {
    _count: ResidenciaCountAggregateOutputType | null
    _avg: ResidenciaAvgAggregateOutputType | null
    _sum: ResidenciaSumAggregateOutputType | null
    _min: ResidenciaMinAggregateOutputType | null
    _max: ResidenciaMaxAggregateOutputType | null
  }

  export type ResidenciaAvgAggregateOutputType = {
    id: number | null
  }

  export type ResidenciaSumAggregateOutputType = {
    id: number | null
  }

  export type ResidenciaMinAggregateOutputType = {
    id: number | null
    tipo: $Enums.Propriedade | null
    data_inicio: Date | null
    estado: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResidenciaMaxAggregateOutputType = {
    id: number | null
    tipo: $Enums.Propriedade | null
    data_inicio: Date | null
    estado: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResidenciaCountAggregateOutputType = {
    id: number
    tipo: number
    data_inicio: number
    estado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResidenciaAvgAggregateInputType = {
    id?: true
  }

  export type ResidenciaSumAggregateInputType = {
    id?: true
  }

  export type ResidenciaMinAggregateInputType = {
    id?: true
    tipo?: true
    data_inicio?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResidenciaMaxAggregateInputType = {
    id?: true
    tipo?: true
    data_inicio?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResidenciaCountAggregateInputType = {
    id?: true
    tipo?: true
    data_inicio?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResidenciaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Residencia to aggregate.
     */
    where?: ResidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Residencias to fetch.
     */
    orderBy?: ResidenciaOrderByWithRelationInput | ResidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Residencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Residencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Residencias
    **/
    _count?: true | ResidenciaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResidenciaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResidenciaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResidenciaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResidenciaMaxAggregateInputType
  }

  export type GetResidenciaAggregateType<T extends ResidenciaAggregateArgs> = {
        [P in keyof T & keyof AggregateResidencia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResidencia[P]>
      : GetScalarType<T[P], AggregateResidencia[P]>
  }




  export type ResidenciaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResidenciaWhereInput
    orderBy?: ResidenciaOrderByWithAggregationInput | ResidenciaOrderByWithAggregationInput[]
    by: ResidenciaScalarFieldEnum[] | ResidenciaScalarFieldEnum
    having?: ResidenciaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResidenciaCountAggregateInputType | true
    _avg?: ResidenciaAvgAggregateInputType
    _sum?: ResidenciaSumAggregateInputType
    _min?: ResidenciaMinAggregateInputType
    _max?: ResidenciaMaxAggregateInputType
  }

  export type ResidenciaGroupByOutputType = {
    id: number
    tipo: $Enums.Propriedade
    data_inicio: Date
    estado: boolean
    createdAt: Date
    updatedAt: Date
    _count: ResidenciaCountAggregateOutputType | null
    _avg: ResidenciaAvgAggregateOutputType | null
    _sum: ResidenciaSumAggregateOutputType | null
    _min: ResidenciaMinAggregateOutputType | null
    _max: ResidenciaMaxAggregateOutputType | null
  }

  type GetResidenciaGroupByPayload<T extends ResidenciaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResidenciaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResidenciaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResidenciaGroupByOutputType[P]>
            : GetScalarType<T[P], ResidenciaGroupByOutputType[P]>
        }
      >
    >


  export type ResidenciaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    data_inicio?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pessoa?: boolean | Residencia$pessoaArgs<ExtArgs>
    _count?: boolean | ResidenciaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["residencia"]>



  export type ResidenciaSelectScalar = {
    id?: boolean
    tipo?: boolean
    data_inicio?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResidenciaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipo" | "data_inicio" | "estado" | "createdAt" | "updatedAt", ExtArgs["result"]["residencia"]>
  export type ResidenciaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | Residencia$pessoaArgs<ExtArgs>
    _count?: boolean | ResidenciaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ResidenciaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Residencia"
    objects: {
      pessoa: Prisma.$PessoaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipo: $Enums.Propriedade
      data_inicio: Date
      estado: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["residencia"]>
    composites: {}
  }

  type ResidenciaGetPayload<S extends boolean | null | undefined | ResidenciaDefaultArgs> = $Result.GetResult<Prisma.$ResidenciaPayload, S>

  type ResidenciaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResidenciaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResidenciaCountAggregateInputType | true
    }

  export interface ResidenciaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Residencia'], meta: { name: 'Residencia' } }
    /**
     * Find zero or one Residencia that matches the filter.
     * @param {ResidenciaFindUniqueArgs} args - Arguments to find a Residencia
     * @example
     * // Get one Residencia
     * const residencia = await prisma.residencia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResidenciaFindUniqueArgs>(args: SelectSubset<T, ResidenciaFindUniqueArgs<ExtArgs>>): Prisma__ResidenciaClient<$Result.GetResult<Prisma.$ResidenciaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Residencia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResidenciaFindUniqueOrThrowArgs} args - Arguments to find a Residencia
     * @example
     * // Get one Residencia
     * const residencia = await prisma.residencia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResidenciaFindUniqueOrThrowArgs>(args: SelectSubset<T, ResidenciaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResidenciaClient<$Result.GetResult<Prisma.$ResidenciaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Residencia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenciaFindFirstArgs} args - Arguments to find a Residencia
     * @example
     * // Get one Residencia
     * const residencia = await prisma.residencia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResidenciaFindFirstArgs>(args?: SelectSubset<T, ResidenciaFindFirstArgs<ExtArgs>>): Prisma__ResidenciaClient<$Result.GetResult<Prisma.$ResidenciaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Residencia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenciaFindFirstOrThrowArgs} args - Arguments to find a Residencia
     * @example
     * // Get one Residencia
     * const residencia = await prisma.residencia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResidenciaFindFirstOrThrowArgs>(args?: SelectSubset<T, ResidenciaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResidenciaClient<$Result.GetResult<Prisma.$ResidenciaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Residencias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenciaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Residencias
     * const residencias = await prisma.residencia.findMany()
     * 
     * // Get first 10 Residencias
     * const residencias = await prisma.residencia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const residenciaWithIdOnly = await prisma.residencia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResidenciaFindManyArgs>(args?: SelectSubset<T, ResidenciaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResidenciaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Residencia.
     * @param {ResidenciaCreateArgs} args - Arguments to create a Residencia.
     * @example
     * // Create one Residencia
     * const Residencia = await prisma.residencia.create({
     *   data: {
     *     // ... data to create a Residencia
     *   }
     * })
     * 
     */
    create<T extends ResidenciaCreateArgs>(args: SelectSubset<T, ResidenciaCreateArgs<ExtArgs>>): Prisma__ResidenciaClient<$Result.GetResult<Prisma.$ResidenciaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Residencias.
     * @param {ResidenciaCreateManyArgs} args - Arguments to create many Residencias.
     * @example
     * // Create many Residencias
     * const residencia = await prisma.residencia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResidenciaCreateManyArgs>(args?: SelectSubset<T, ResidenciaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Residencia.
     * @param {ResidenciaDeleteArgs} args - Arguments to delete one Residencia.
     * @example
     * // Delete one Residencia
     * const Residencia = await prisma.residencia.delete({
     *   where: {
     *     // ... filter to delete one Residencia
     *   }
     * })
     * 
     */
    delete<T extends ResidenciaDeleteArgs>(args: SelectSubset<T, ResidenciaDeleteArgs<ExtArgs>>): Prisma__ResidenciaClient<$Result.GetResult<Prisma.$ResidenciaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Residencia.
     * @param {ResidenciaUpdateArgs} args - Arguments to update one Residencia.
     * @example
     * // Update one Residencia
     * const residencia = await prisma.residencia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResidenciaUpdateArgs>(args: SelectSubset<T, ResidenciaUpdateArgs<ExtArgs>>): Prisma__ResidenciaClient<$Result.GetResult<Prisma.$ResidenciaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Residencias.
     * @param {ResidenciaDeleteManyArgs} args - Arguments to filter Residencias to delete.
     * @example
     * // Delete a few Residencias
     * const { count } = await prisma.residencia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResidenciaDeleteManyArgs>(args?: SelectSubset<T, ResidenciaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Residencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenciaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Residencias
     * const residencia = await prisma.residencia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResidenciaUpdateManyArgs>(args: SelectSubset<T, ResidenciaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Residencia.
     * @param {ResidenciaUpsertArgs} args - Arguments to update or create a Residencia.
     * @example
     * // Update or create a Residencia
     * const residencia = await prisma.residencia.upsert({
     *   create: {
     *     // ... data to create a Residencia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Residencia we want to update
     *   }
     * })
     */
    upsert<T extends ResidenciaUpsertArgs>(args: SelectSubset<T, ResidenciaUpsertArgs<ExtArgs>>): Prisma__ResidenciaClient<$Result.GetResult<Prisma.$ResidenciaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Residencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenciaCountArgs} args - Arguments to filter Residencias to count.
     * @example
     * // Count the number of Residencias
     * const count = await prisma.residencia.count({
     *   where: {
     *     // ... the filter for the Residencias we want to count
     *   }
     * })
    **/
    count<T extends ResidenciaCountArgs>(
      args?: Subset<T, ResidenciaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResidenciaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Residencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenciaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResidenciaAggregateArgs>(args: Subset<T, ResidenciaAggregateArgs>): Prisma.PrismaPromise<GetResidenciaAggregateType<T>>

    /**
     * Group by Residencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenciaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResidenciaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResidenciaGroupByArgs['orderBy'] }
        : { orderBy?: ResidenciaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResidenciaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResidenciaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Residencia model
   */
  readonly fields: ResidenciaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Residencia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResidenciaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoa<T extends Residencia$pessoaArgs<ExtArgs> = {}>(args?: Subset<T, Residencia$pessoaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Residencia model
   */
  interface ResidenciaFieldRefs {
    readonly id: FieldRef<"Residencia", 'Int'>
    readonly tipo: FieldRef<"Residencia", 'Propriedade'>
    readonly data_inicio: FieldRef<"Residencia", 'DateTime'>
    readonly estado: FieldRef<"Residencia", 'Boolean'>
    readonly createdAt: FieldRef<"Residencia", 'DateTime'>
    readonly updatedAt: FieldRef<"Residencia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Residencia findUnique
   */
  export type ResidenciaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residencia
     */
    select?: ResidenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residencia
     */
    omit?: ResidenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Residencia to fetch.
     */
    where: ResidenciaWhereUniqueInput
  }

  /**
   * Residencia findUniqueOrThrow
   */
  export type ResidenciaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residencia
     */
    select?: ResidenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residencia
     */
    omit?: ResidenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Residencia to fetch.
     */
    where: ResidenciaWhereUniqueInput
  }

  /**
   * Residencia findFirst
   */
  export type ResidenciaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residencia
     */
    select?: ResidenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residencia
     */
    omit?: ResidenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Residencia to fetch.
     */
    where?: ResidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Residencias to fetch.
     */
    orderBy?: ResidenciaOrderByWithRelationInput | ResidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Residencias.
     */
    cursor?: ResidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Residencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Residencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Residencias.
     */
    distinct?: ResidenciaScalarFieldEnum | ResidenciaScalarFieldEnum[]
  }

  /**
   * Residencia findFirstOrThrow
   */
  export type ResidenciaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residencia
     */
    select?: ResidenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residencia
     */
    omit?: ResidenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Residencia to fetch.
     */
    where?: ResidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Residencias to fetch.
     */
    orderBy?: ResidenciaOrderByWithRelationInput | ResidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Residencias.
     */
    cursor?: ResidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Residencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Residencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Residencias.
     */
    distinct?: ResidenciaScalarFieldEnum | ResidenciaScalarFieldEnum[]
  }

  /**
   * Residencia findMany
   */
  export type ResidenciaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residencia
     */
    select?: ResidenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residencia
     */
    omit?: ResidenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Residencias to fetch.
     */
    where?: ResidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Residencias to fetch.
     */
    orderBy?: ResidenciaOrderByWithRelationInput | ResidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Residencias.
     */
    cursor?: ResidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Residencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Residencias.
     */
    skip?: number
    distinct?: ResidenciaScalarFieldEnum | ResidenciaScalarFieldEnum[]
  }

  /**
   * Residencia create
   */
  export type ResidenciaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residencia
     */
    select?: ResidenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residencia
     */
    omit?: ResidenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenciaInclude<ExtArgs> | null
    /**
     * The data needed to create a Residencia.
     */
    data: XOR<ResidenciaCreateInput, ResidenciaUncheckedCreateInput>
  }

  /**
   * Residencia createMany
   */
  export type ResidenciaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Residencias.
     */
    data: ResidenciaCreateManyInput | ResidenciaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Residencia update
   */
  export type ResidenciaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residencia
     */
    select?: ResidenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residencia
     */
    omit?: ResidenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenciaInclude<ExtArgs> | null
    /**
     * The data needed to update a Residencia.
     */
    data: XOR<ResidenciaUpdateInput, ResidenciaUncheckedUpdateInput>
    /**
     * Choose, which Residencia to update.
     */
    where: ResidenciaWhereUniqueInput
  }

  /**
   * Residencia updateMany
   */
  export type ResidenciaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Residencias.
     */
    data: XOR<ResidenciaUpdateManyMutationInput, ResidenciaUncheckedUpdateManyInput>
    /**
     * Filter which Residencias to update
     */
    where?: ResidenciaWhereInput
    /**
     * Limit how many Residencias to update.
     */
    limit?: number
  }

  /**
   * Residencia upsert
   */
  export type ResidenciaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residencia
     */
    select?: ResidenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residencia
     */
    omit?: ResidenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenciaInclude<ExtArgs> | null
    /**
     * The filter to search for the Residencia to update in case it exists.
     */
    where: ResidenciaWhereUniqueInput
    /**
     * In case the Residencia found by the `where` argument doesn't exist, create a new Residencia with this data.
     */
    create: XOR<ResidenciaCreateInput, ResidenciaUncheckedCreateInput>
    /**
     * In case the Residencia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResidenciaUpdateInput, ResidenciaUncheckedUpdateInput>
  }

  /**
   * Residencia delete
   */
  export type ResidenciaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residencia
     */
    select?: ResidenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residencia
     */
    omit?: ResidenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenciaInclude<ExtArgs> | null
    /**
     * Filter which Residencia to delete.
     */
    where: ResidenciaWhereUniqueInput
  }

  /**
   * Residencia deleteMany
   */
  export type ResidenciaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Residencias to delete
     */
    where?: ResidenciaWhereInput
    /**
     * Limit how many Residencias to delete.
     */
    limit?: number
  }

  /**
   * Residencia.pessoa
   */
  export type Residencia$pessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    where?: PessoaWhereInput
    orderBy?: PessoaOrderByWithRelationInput | PessoaOrderByWithRelationInput[]
    cursor?: PessoaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * Residencia without action
   */
  export type ResidenciaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residencia
     */
    select?: ResidenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residencia
     */
    omit?: ResidenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenciaInclude<ExtArgs> | null
  }


  /**
   * Model Papel
   */

  export type AggregatePapel = {
    _count: PapelCountAggregateOutputType | null
    _avg: PapelAvgAggregateOutputType | null
    _sum: PapelSumAggregateOutputType | null
    _min: PapelMinAggregateOutputType | null
    _max: PapelMaxAggregateOutputType | null
  }

  export type PapelAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type PapelSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type PapelMinAggregateOutputType = {
    id: number | null
    perfil: $Enums.Perfil | null
    user_id: number | null
    estado: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PapelMaxAggregateOutputType = {
    id: number | null
    perfil: $Enums.Perfil | null
    user_id: number | null
    estado: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PapelCountAggregateOutputType = {
    id: number
    perfil: number
    user_id: number
    estado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PapelAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type PapelSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type PapelMinAggregateInputType = {
    id?: true
    perfil?: true
    user_id?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PapelMaxAggregateInputType = {
    id?: true
    perfil?: true
    user_id?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PapelCountAggregateInputType = {
    id?: true
    perfil?: true
    user_id?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PapelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Papel to aggregate.
     */
    where?: PapelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Papels to fetch.
     */
    orderBy?: PapelOrderByWithRelationInput | PapelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PapelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Papels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Papels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Papels
    **/
    _count?: true | PapelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PapelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PapelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PapelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PapelMaxAggregateInputType
  }

  export type GetPapelAggregateType<T extends PapelAggregateArgs> = {
        [P in keyof T & keyof AggregatePapel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePapel[P]>
      : GetScalarType<T[P], AggregatePapel[P]>
  }




  export type PapelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PapelWhereInput
    orderBy?: PapelOrderByWithAggregationInput | PapelOrderByWithAggregationInput[]
    by: PapelScalarFieldEnum[] | PapelScalarFieldEnum
    having?: PapelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PapelCountAggregateInputType | true
    _avg?: PapelAvgAggregateInputType
    _sum?: PapelSumAggregateInputType
    _min?: PapelMinAggregateInputType
    _max?: PapelMaxAggregateInputType
  }

  export type PapelGroupByOutputType = {
    id: number
    perfil: $Enums.Perfil
    user_id: number
    estado: boolean
    createdAt: Date
    updatedAt: Date
    _count: PapelCountAggregateOutputType | null
    _avg: PapelAvgAggregateOutputType | null
    _sum: PapelSumAggregateOutputType | null
    _min: PapelMinAggregateOutputType | null
    _max: PapelMaxAggregateOutputType | null
  }

  type GetPapelGroupByPayload<T extends PapelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PapelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PapelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PapelGroupByOutputType[P]>
            : GetScalarType<T[P], PapelGroupByOutputType[P]>
        }
      >
    >


  export type PapelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    perfil?: boolean
    user_id?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["papel"]>



  export type PapelSelectScalar = {
    id?: boolean
    perfil?: boolean
    user_id?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PapelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "perfil" | "user_id" | "estado" | "createdAt" | "updatedAt", ExtArgs["result"]["papel"]>
  export type PapelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PapelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Papel"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      perfil: $Enums.Perfil
      user_id: number
      estado: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["papel"]>
    composites: {}
  }

  type PapelGetPayload<S extends boolean | null | undefined | PapelDefaultArgs> = $Result.GetResult<Prisma.$PapelPayload, S>

  type PapelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PapelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PapelCountAggregateInputType | true
    }

  export interface PapelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Papel'], meta: { name: 'Papel' } }
    /**
     * Find zero or one Papel that matches the filter.
     * @param {PapelFindUniqueArgs} args - Arguments to find a Papel
     * @example
     * // Get one Papel
     * const papel = await prisma.papel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PapelFindUniqueArgs>(args: SelectSubset<T, PapelFindUniqueArgs<ExtArgs>>): Prisma__PapelClient<$Result.GetResult<Prisma.$PapelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Papel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PapelFindUniqueOrThrowArgs} args - Arguments to find a Papel
     * @example
     * // Get one Papel
     * const papel = await prisma.papel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PapelFindUniqueOrThrowArgs>(args: SelectSubset<T, PapelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PapelClient<$Result.GetResult<Prisma.$PapelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Papel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PapelFindFirstArgs} args - Arguments to find a Papel
     * @example
     * // Get one Papel
     * const papel = await prisma.papel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PapelFindFirstArgs>(args?: SelectSubset<T, PapelFindFirstArgs<ExtArgs>>): Prisma__PapelClient<$Result.GetResult<Prisma.$PapelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Papel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PapelFindFirstOrThrowArgs} args - Arguments to find a Papel
     * @example
     * // Get one Papel
     * const papel = await prisma.papel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PapelFindFirstOrThrowArgs>(args?: SelectSubset<T, PapelFindFirstOrThrowArgs<ExtArgs>>): Prisma__PapelClient<$Result.GetResult<Prisma.$PapelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Papels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PapelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Papels
     * const papels = await prisma.papel.findMany()
     * 
     * // Get first 10 Papels
     * const papels = await prisma.papel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const papelWithIdOnly = await prisma.papel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PapelFindManyArgs>(args?: SelectSubset<T, PapelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PapelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Papel.
     * @param {PapelCreateArgs} args - Arguments to create a Papel.
     * @example
     * // Create one Papel
     * const Papel = await prisma.papel.create({
     *   data: {
     *     // ... data to create a Papel
     *   }
     * })
     * 
     */
    create<T extends PapelCreateArgs>(args: SelectSubset<T, PapelCreateArgs<ExtArgs>>): Prisma__PapelClient<$Result.GetResult<Prisma.$PapelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Papels.
     * @param {PapelCreateManyArgs} args - Arguments to create many Papels.
     * @example
     * // Create many Papels
     * const papel = await prisma.papel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PapelCreateManyArgs>(args?: SelectSubset<T, PapelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Papel.
     * @param {PapelDeleteArgs} args - Arguments to delete one Papel.
     * @example
     * // Delete one Papel
     * const Papel = await prisma.papel.delete({
     *   where: {
     *     // ... filter to delete one Papel
     *   }
     * })
     * 
     */
    delete<T extends PapelDeleteArgs>(args: SelectSubset<T, PapelDeleteArgs<ExtArgs>>): Prisma__PapelClient<$Result.GetResult<Prisma.$PapelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Papel.
     * @param {PapelUpdateArgs} args - Arguments to update one Papel.
     * @example
     * // Update one Papel
     * const papel = await prisma.papel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PapelUpdateArgs>(args: SelectSubset<T, PapelUpdateArgs<ExtArgs>>): Prisma__PapelClient<$Result.GetResult<Prisma.$PapelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Papels.
     * @param {PapelDeleteManyArgs} args - Arguments to filter Papels to delete.
     * @example
     * // Delete a few Papels
     * const { count } = await prisma.papel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PapelDeleteManyArgs>(args?: SelectSubset<T, PapelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Papels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PapelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Papels
     * const papel = await prisma.papel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PapelUpdateManyArgs>(args: SelectSubset<T, PapelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Papel.
     * @param {PapelUpsertArgs} args - Arguments to update or create a Papel.
     * @example
     * // Update or create a Papel
     * const papel = await prisma.papel.upsert({
     *   create: {
     *     // ... data to create a Papel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Papel we want to update
     *   }
     * })
     */
    upsert<T extends PapelUpsertArgs>(args: SelectSubset<T, PapelUpsertArgs<ExtArgs>>): Prisma__PapelClient<$Result.GetResult<Prisma.$PapelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Papels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PapelCountArgs} args - Arguments to filter Papels to count.
     * @example
     * // Count the number of Papels
     * const count = await prisma.papel.count({
     *   where: {
     *     // ... the filter for the Papels we want to count
     *   }
     * })
    **/
    count<T extends PapelCountArgs>(
      args?: Subset<T, PapelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PapelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Papel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PapelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PapelAggregateArgs>(args: Subset<T, PapelAggregateArgs>): Prisma.PrismaPromise<GetPapelAggregateType<T>>

    /**
     * Group by Papel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PapelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PapelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PapelGroupByArgs['orderBy'] }
        : { orderBy?: PapelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PapelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPapelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Papel model
   */
  readonly fields: PapelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Papel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PapelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Papel model
   */
  interface PapelFieldRefs {
    readonly id: FieldRef<"Papel", 'Int'>
    readonly perfil: FieldRef<"Papel", 'Perfil'>
    readonly user_id: FieldRef<"Papel", 'Int'>
    readonly estado: FieldRef<"Papel", 'Boolean'>
    readonly createdAt: FieldRef<"Papel", 'DateTime'>
    readonly updatedAt: FieldRef<"Papel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Papel findUnique
   */
  export type PapelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papel
     */
    select?: PapelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papel
     */
    omit?: PapelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapelInclude<ExtArgs> | null
    /**
     * Filter, which Papel to fetch.
     */
    where: PapelWhereUniqueInput
  }

  /**
   * Papel findUniqueOrThrow
   */
  export type PapelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papel
     */
    select?: PapelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papel
     */
    omit?: PapelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapelInclude<ExtArgs> | null
    /**
     * Filter, which Papel to fetch.
     */
    where: PapelWhereUniqueInput
  }

  /**
   * Papel findFirst
   */
  export type PapelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papel
     */
    select?: PapelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papel
     */
    omit?: PapelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapelInclude<ExtArgs> | null
    /**
     * Filter, which Papel to fetch.
     */
    where?: PapelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Papels to fetch.
     */
    orderBy?: PapelOrderByWithRelationInput | PapelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Papels.
     */
    cursor?: PapelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Papels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Papels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Papels.
     */
    distinct?: PapelScalarFieldEnum | PapelScalarFieldEnum[]
  }

  /**
   * Papel findFirstOrThrow
   */
  export type PapelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papel
     */
    select?: PapelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papel
     */
    omit?: PapelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapelInclude<ExtArgs> | null
    /**
     * Filter, which Papel to fetch.
     */
    where?: PapelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Papels to fetch.
     */
    orderBy?: PapelOrderByWithRelationInput | PapelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Papels.
     */
    cursor?: PapelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Papels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Papels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Papels.
     */
    distinct?: PapelScalarFieldEnum | PapelScalarFieldEnum[]
  }

  /**
   * Papel findMany
   */
  export type PapelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papel
     */
    select?: PapelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papel
     */
    omit?: PapelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapelInclude<ExtArgs> | null
    /**
     * Filter, which Papels to fetch.
     */
    where?: PapelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Papels to fetch.
     */
    orderBy?: PapelOrderByWithRelationInput | PapelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Papels.
     */
    cursor?: PapelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Papels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Papels.
     */
    skip?: number
    distinct?: PapelScalarFieldEnum | PapelScalarFieldEnum[]
  }

  /**
   * Papel create
   */
  export type PapelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papel
     */
    select?: PapelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papel
     */
    omit?: PapelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapelInclude<ExtArgs> | null
    /**
     * The data needed to create a Papel.
     */
    data: XOR<PapelCreateInput, PapelUncheckedCreateInput>
  }

  /**
   * Papel createMany
   */
  export type PapelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Papels.
     */
    data: PapelCreateManyInput | PapelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Papel update
   */
  export type PapelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papel
     */
    select?: PapelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papel
     */
    omit?: PapelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapelInclude<ExtArgs> | null
    /**
     * The data needed to update a Papel.
     */
    data: XOR<PapelUpdateInput, PapelUncheckedUpdateInput>
    /**
     * Choose, which Papel to update.
     */
    where: PapelWhereUniqueInput
  }

  /**
   * Papel updateMany
   */
  export type PapelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Papels.
     */
    data: XOR<PapelUpdateManyMutationInput, PapelUncheckedUpdateManyInput>
    /**
     * Filter which Papels to update
     */
    where?: PapelWhereInput
    /**
     * Limit how many Papels to update.
     */
    limit?: number
  }

  /**
   * Papel upsert
   */
  export type PapelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papel
     */
    select?: PapelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papel
     */
    omit?: PapelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapelInclude<ExtArgs> | null
    /**
     * The filter to search for the Papel to update in case it exists.
     */
    where: PapelWhereUniqueInput
    /**
     * In case the Papel found by the `where` argument doesn't exist, create a new Papel with this data.
     */
    create: XOR<PapelCreateInput, PapelUncheckedCreateInput>
    /**
     * In case the Papel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PapelUpdateInput, PapelUncheckedUpdateInput>
  }

  /**
   * Papel delete
   */
  export type PapelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papel
     */
    select?: PapelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papel
     */
    omit?: PapelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapelInclude<ExtArgs> | null
    /**
     * Filter which Papel to delete.
     */
    where: PapelWhereUniqueInput
  }

  /**
   * Papel deleteMany
   */
  export type PapelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Papels to delete
     */
    where?: PapelWhereInput
    /**
     * Limit how many Papels to delete.
     */
    limit?: number
  }

  /**
   * Papel without action
   */
  export type PapelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papel
     */
    select?: PapelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papel
     */
    omit?: PapelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapelInclude<ExtArgs> | null
  }


  /**
   * Model Pessoa
   */

  export type AggregatePessoa = {
    _count: PessoaCountAggregateOutputType | null
    _avg: PessoaAvgAggregateOutputType | null
    _sum: PessoaSumAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  export type PessoaAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    emprego_id: number | null
    residencia_id: number | null
  }

  export type PessoaSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    emprego_id: number | null
    residencia_id: number | null
  }

  export type PessoaMinAggregateOutputType = {
    id: number | null
    estado_civil: $Enums.Estado | null
    provincia: string | null
    municipio: string | null
    profissao: string | null
    estado: boolean | null
    nivel_instrucao: string | null
    data_nascimento: Date | null
    user_id: number | null
    emprego_id: number | null
    residencia_id: number | null
  }

  export type PessoaMaxAggregateOutputType = {
    id: number | null
    estado_civil: $Enums.Estado | null
    provincia: string | null
    municipio: string | null
    profissao: string | null
    estado: boolean | null
    nivel_instrucao: string | null
    data_nascimento: Date | null
    user_id: number | null
    emprego_id: number | null
    residencia_id: number | null
  }

  export type PessoaCountAggregateOutputType = {
    id: number
    estado_civil: number
    provincia: number
    municipio: number
    profissao: number
    estado: number
    nivel_instrucao: number
    data_nascimento: number
    user_id: number
    emprego_id: number
    residencia_id: number
    _all: number
  }


  export type PessoaAvgAggregateInputType = {
    id?: true
    user_id?: true
    emprego_id?: true
    residencia_id?: true
  }

  export type PessoaSumAggregateInputType = {
    id?: true
    user_id?: true
    emprego_id?: true
    residencia_id?: true
  }

  export type PessoaMinAggregateInputType = {
    id?: true
    estado_civil?: true
    provincia?: true
    municipio?: true
    profissao?: true
    estado?: true
    nivel_instrucao?: true
    data_nascimento?: true
    user_id?: true
    emprego_id?: true
    residencia_id?: true
  }

  export type PessoaMaxAggregateInputType = {
    id?: true
    estado_civil?: true
    provincia?: true
    municipio?: true
    profissao?: true
    estado?: true
    nivel_instrucao?: true
    data_nascimento?: true
    user_id?: true
    emprego_id?: true
    residencia_id?: true
  }

  export type PessoaCountAggregateInputType = {
    id?: true
    estado_civil?: true
    provincia?: true
    municipio?: true
    profissao?: true
    estado?: true
    nivel_instrucao?: true
    data_nascimento?: true
    user_id?: true
    emprego_id?: true
    residencia_id?: true
    _all?: true
  }

  export type PessoaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pessoa to aggregate.
     */
    where?: PessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pessoas to fetch.
     */
    orderBy?: PessoaOrderByWithRelationInput | PessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pessoas
    **/
    _count?: true | PessoaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PessoaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PessoaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PessoaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PessoaMaxAggregateInputType
  }

  export type GetPessoaAggregateType<T extends PessoaAggregateArgs> = {
        [P in keyof T & keyof AggregatePessoa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePessoa[P]>
      : GetScalarType<T[P], AggregatePessoa[P]>
  }




  export type PessoaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PessoaWhereInput
    orderBy?: PessoaOrderByWithAggregationInput | PessoaOrderByWithAggregationInput[]
    by: PessoaScalarFieldEnum[] | PessoaScalarFieldEnum
    having?: PessoaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PessoaCountAggregateInputType | true
    _avg?: PessoaAvgAggregateInputType
    _sum?: PessoaSumAggregateInputType
    _min?: PessoaMinAggregateInputType
    _max?: PessoaMaxAggregateInputType
  }

  export type PessoaGroupByOutputType = {
    id: number
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado: boolean
    nivel_instrucao: string
    data_nascimento: Date
    user_id: number
    emprego_id: number
    residencia_id: number
    _count: PessoaCountAggregateOutputType | null
    _avg: PessoaAvgAggregateOutputType | null
    _sum: PessoaSumAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  type GetPessoaGroupByPayload<T extends PessoaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PessoaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PessoaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PessoaGroupByOutputType[P]>
            : GetScalarType<T[P], PessoaGroupByOutputType[P]>
        }
      >
    >


  export type PessoaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estado_civil?: boolean
    provincia?: boolean
    municipio?: boolean
    profissao?: boolean
    estado?: boolean
    nivel_instrucao?: boolean
    data_nascimento?: boolean
    user_id?: boolean
    emprego_id?: boolean
    residencia_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    emprego?: boolean | EmpregoDefaultArgs<ExtArgs>
    residencia?: boolean | ResidenciaDefaultArgs<ExtArgs>
    conjugue?: boolean | Pessoa$conjugueArgs<ExtArgs>
    solidario?: boolean | Pessoa$solidarioArgs<ExtArgs>
    conta?: boolean | Pessoa$contaArgs<ExtArgs>
  }, ExtArgs["result"]["pessoa"]>



  export type PessoaSelectScalar = {
    id?: boolean
    estado_civil?: boolean
    provincia?: boolean
    municipio?: boolean
    profissao?: boolean
    estado?: boolean
    nivel_instrucao?: boolean
    data_nascimento?: boolean
    user_id?: boolean
    emprego_id?: boolean
    residencia_id?: boolean
  }

  export type PessoaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "estado_civil" | "provincia" | "municipio" | "profissao" | "estado" | "nivel_instrucao" | "data_nascimento" | "user_id" | "emprego_id" | "residencia_id", ExtArgs["result"]["pessoa"]>
  export type PessoaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    emprego?: boolean | EmpregoDefaultArgs<ExtArgs>
    residencia?: boolean | ResidenciaDefaultArgs<ExtArgs>
    conjugue?: boolean | Pessoa$conjugueArgs<ExtArgs>
    solidario?: boolean | Pessoa$solidarioArgs<ExtArgs>
    conta?: boolean | Pessoa$contaArgs<ExtArgs>
  }

  export type $PessoaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pessoa"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      emprego: Prisma.$EmpregoPayload<ExtArgs>
      residencia: Prisma.$ResidenciaPayload<ExtArgs>
      conjugue: Prisma.$ConjuguePayload<ExtArgs> | null
      solidario: Prisma.$SolidarioPayload<ExtArgs> | null
      conta: Prisma.$ContaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      estado_civil: $Enums.Estado
      provincia: string
      municipio: string
      profissao: string
      estado: boolean
      nivel_instrucao: string
      data_nascimento: Date
      user_id: number
      emprego_id: number
      residencia_id: number
    }, ExtArgs["result"]["pessoa"]>
    composites: {}
  }

  type PessoaGetPayload<S extends boolean | null | undefined | PessoaDefaultArgs> = $Result.GetResult<Prisma.$PessoaPayload, S>

  type PessoaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PessoaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PessoaCountAggregateInputType | true
    }

  export interface PessoaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pessoa'], meta: { name: 'Pessoa' } }
    /**
     * Find zero or one Pessoa that matches the filter.
     * @param {PessoaFindUniqueArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PessoaFindUniqueArgs>(args: SelectSubset<T, PessoaFindUniqueArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pessoa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PessoaFindUniqueOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PessoaFindUniqueOrThrowArgs>(args: SelectSubset<T, PessoaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pessoa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaFindFirstArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PessoaFindFirstArgs>(args?: SelectSubset<T, PessoaFindFirstArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pessoa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaFindFirstOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PessoaFindFirstOrThrowArgs>(args?: SelectSubset<T, PessoaFindFirstOrThrowArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pessoas
     * const pessoas = await prisma.pessoa.findMany()
     * 
     * // Get first 10 Pessoas
     * const pessoas = await prisma.pessoa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pessoaWithIdOnly = await prisma.pessoa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PessoaFindManyArgs>(args?: SelectSubset<T, PessoaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pessoa.
     * @param {PessoaCreateArgs} args - Arguments to create a Pessoa.
     * @example
     * // Create one Pessoa
     * const Pessoa = await prisma.pessoa.create({
     *   data: {
     *     // ... data to create a Pessoa
     *   }
     * })
     * 
     */
    create<T extends PessoaCreateArgs>(args: SelectSubset<T, PessoaCreateArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pessoas.
     * @param {PessoaCreateManyArgs} args - Arguments to create many Pessoas.
     * @example
     * // Create many Pessoas
     * const pessoa = await prisma.pessoa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PessoaCreateManyArgs>(args?: SelectSubset<T, PessoaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pessoa.
     * @param {PessoaDeleteArgs} args - Arguments to delete one Pessoa.
     * @example
     * // Delete one Pessoa
     * const Pessoa = await prisma.pessoa.delete({
     *   where: {
     *     // ... filter to delete one Pessoa
     *   }
     * })
     * 
     */
    delete<T extends PessoaDeleteArgs>(args: SelectSubset<T, PessoaDeleteArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pessoa.
     * @param {PessoaUpdateArgs} args - Arguments to update one Pessoa.
     * @example
     * // Update one Pessoa
     * const pessoa = await prisma.pessoa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PessoaUpdateArgs>(args: SelectSubset<T, PessoaUpdateArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pessoas.
     * @param {PessoaDeleteManyArgs} args - Arguments to filter Pessoas to delete.
     * @example
     * // Delete a few Pessoas
     * const { count } = await prisma.pessoa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PessoaDeleteManyArgs>(args?: SelectSubset<T, PessoaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pessoas
     * const pessoa = await prisma.pessoa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PessoaUpdateManyArgs>(args: SelectSubset<T, PessoaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pessoa.
     * @param {PessoaUpsertArgs} args - Arguments to update or create a Pessoa.
     * @example
     * // Update or create a Pessoa
     * const pessoa = await prisma.pessoa.upsert({
     *   create: {
     *     // ... data to create a Pessoa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pessoa we want to update
     *   }
     * })
     */
    upsert<T extends PessoaUpsertArgs>(args: SelectSubset<T, PessoaUpsertArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaCountArgs} args - Arguments to filter Pessoas to count.
     * @example
     * // Count the number of Pessoas
     * const count = await prisma.pessoa.count({
     *   where: {
     *     // ... the filter for the Pessoas we want to count
     *   }
     * })
    **/
    count<T extends PessoaCountArgs>(
      args?: Subset<T, PessoaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PessoaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PessoaAggregateArgs>(args: Subset<T, PessoaAggregateArgs>): Prisma.PrismaPromise<GetPessoaAggregateType<T>>

    /**
     * Group by Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PessoaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PessoaGroupByArgs['orderBy'] }
        : { orderBy?: PessoaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PessoaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPessoaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pessoa model
   */
  readonly fields: PessoaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pessoa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PessoaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    emprego<T extends EmpregoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpregoDefaultArgs<ExtArgs>>): Prisma__EmpregoClient<$Result.GetResult<Prisma.$EmpregoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    residencia<T extends ResidenciaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResidenciaDefaultArgs<ExtArgs>>): Prisma__ResidenciaClient<$Result.GetResult<Prisma.$ResidenciaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conjugue<T extends Pessoa$conjugueArgs<ExtArgs> = {}>(args?: Subset<T, Pessoa$conjugueArgs<ExtArgs>>): Prisma__ConjugueClient<$Result.GetResult<Prisma.$ConjuguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    solidario<T extends Pessoa$solidarioArgs<ExtArgs> = {}>(args?: Subset<T, Pessoa$solidarioArgs<ExtArgs>>): Prisma__SolidarioClient<$Result.GetResult<Prisma.$SolidarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    conta<T extends Pessoa$contaArgs<ExtArgs> = {}>(args?: Subset<T, Pessoa$contaArgs<ExtArgs>>): Prisma__ContaClient<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pessoa model
   */
  interface PessoaFieldRefs {
    readonly id: FieldRef<"Pessoa", 'Int'>
    readonly estado_civil: FieldRef<"Pessoa", 'Estado'>
    readonly provincia: FieldRef<"Pessoa", 'String'>
    readonly municipio: FieldRef<"Pessoa", 'String'>
    readonly profissao: FieldRef<"Pessoa", 'String'>
    readonly estado: FieldRef<"Pessoa", 'Boolean'>
    readonly nivel_instrucao: FieldRef<"Pessoa", 'String'>
    readonly data_nascimento: FieldRef<"Pessoa", 'DateTime'>
    readonly user_id: FieldRef<"Pessoa", 'Int'>
    readonly emprego_id: FieldRef<"Pessoa", 'Int'>
    readonly residencia_id: FieldRef<"Pessoa", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Pessoa findUnique
   */
  export type PessoaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * Filter, which Pessoa to fetch.
     */
    where: PessoaWhereUniqueInput
  }

  /**
   * Pessoa findUniqueOrThrow
   */
  export type PessoaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * Filter, which Pessoa to fetch.
     */
    where: PessoaWhereUniqueInput
  }

  /**
   * Pessoa findFirst
   */
  export type PessoaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * Filter, which Pessoa to fetch.
     */
    where?: PessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pessoas to fetch.
     */
    orderBy?: PessoaOrderByWithRelationInput | PessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pessoas.
     */
    cursor?: PessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pessoas.
     */
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * Pessoa findFirstOrThrow
   */
  export type PessoaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * Filter, which Pessoa to fetch.
     */
    where?: PessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pessoas to fetch.
     */
    orderBy?: PessoaOrderByWithRelationInput | PessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pessoas.
     */
    cursor?: PessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pessoas.
     */
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * Pessoa findMany
   */
  export type PessoaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * Filter, which Pessoas to fetch.
     */
    where?: PessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pessoas to fetch.
     */
    orderBy?: PessoaOrderByWithRelationInput | PessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pessoas.
     */
    cursor?: PessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pessoas.
     */
    skip?: number
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * Pessoa create
   */
  export type PessoaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * The data needed to create a Pessoa.
     */
    data: XOR<PessoaCreateInput, PessoaUncheckedCreateInput>
  }

  /**
   * Pessoa createMany
   */
  export type PessoaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pessoas.
     */
    data: PessoaCreateManyInput | PessoaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pessoa update
   */
  export type PessoaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * The data needed to update a Pessoa.
     */
    data: XOR<PessoaUpdateInput, PessoaUncheckedUpdateInput>
    /**
     * Choose, which Pessoa to update.
     */
    where: PessoaWhereUniqueInput
  }

  /**
   * Pessoa updateMany
   */
  export type PessoaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pessoas.
     */
    data: XOR<PessoaUpdateManyMutationInput, PessoaUncheckedUpdateManyInput>
    /**
     * Filter which Pessoas to update
     */
    where?: PessoaWhereInput
    /**
     * Limit how many Pessoas to update.
     */
    limit?: number
  }

  /**
   * Pessoa upsert
   */
  export type PessoaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * The filter to search for the Pessoa to update in case it exists.
     */
    where: PessoaWhereUniqueInput
    /**
     * In case the Pessoa found by the `where` argument doesn't exist, create a new Pessoa with this data.
     */
    create: XOR<PessoaCreateInput, PessoaUncheckedCreateInput>
    /**
     * In case the Pessoa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PessoaUpdateInput, PessoaUncheckedUpdateInput>
  }

  /**
   * Pessoa delete
   */
  export type PessoaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * Filter which Pessoa to delete.
     */
    where: PessoaWhereUniqueInput
  }

  /**
   * Pessoa deleteMany
   */
  export type PessoaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pessoas to delete
     */
    where?: PessoaWhereInput
    /**
     * Limit how many Pessoas to delete.
     */
    limit?: number
  }

  /**
   * Pessoa.conjugue
   */
  export type Pessoa$conjugueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conjugue
     */
    select?: ConjugueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conjugue
     */
    omit?: ConjugueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConjugueInclude<ExtArgs> | null
    where?: ConjugueWhereInput
  }

  /**
   * Pessoa.solidario
   */
  export type Pessoa$solidarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solidario
     */
    select?: SolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solidario
     */
    omit?: SolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolidarioInclude<ExtArgs> | null
    where?: SolidarioWhereInput
  }

  /**
   * Pessoa.conta
   */
  export type Pessoa$contaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conta
     */
    omit?: ContaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    where?: ContaWhereInput
  }

  /**
   * Pessoa without action
   */
  export type PessoaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
  }


  /**
   * Model Conta
   */

  export type AggregateConta = {
    _count: ContaCountAggregateOutputType | null
    _avg: ContaAvgAggregateOutputType | null
    _sum: ContaSumAggregateOutputType | null
    _min: ContaMinAggregateOutputType | null
    _max: ContaMaxAggregateOutputType | null
  }

  export type ContaAvgAggregateOutputType = {
    id: number | null
    salario: number | null
    pessoa_id: number | null
  }

  export type ContaSumAggregateOutputType = {
    id: number | null
    salario: number | null
    pessoa_id: number | null
  }

  export type ContaMinAggregateOutputType = {
    id: number | null
    nome: string | null
    salario: number | null
    iban: string | null
    estado: boolean | null
    pessoa_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    salario: number | null
    iban: string | null
    estado: boolean | null
    pessoa_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContaCountAggregateOutputType = {
    id: number
    nome: number
    salario: number
    iban: number
    estado: number
    pessoa_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContaAvgAggregateInputType = {
    id?: true
    salario?: true
    pessoa_id?: true
  }

  export type ContaSumAggregateInputType = {
    id?: true
    salario?: true
    pessoa_id?: true
  }

  export type ContaMinAggregateInputType = {
    id?: true
    nome?: true
    salario?: true
    iban?: true
    estado?: true
    pessoa_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContaMaxAggregateInputType = {
    id?: true
    nome?: true
    salario?: true
    iban?: true
    estado?: true
    pessoa_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContaCountAggregateInputType = {
    id?: true
    nome?: true
    salario?: true
    iban?: true
    estado?: true
    pessoa_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conta to aggregate.
     */
    where?: ContaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contas to fetch.
     */
    orderBy?: ContaOrderByWithRelationInput | ContaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contas
    **/
    _count?: true | ContaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContaMaxAggregateInputType
  }

  export type GetContaAggregateType<T extends ContaAggregateArgs> = {
        [P in keyof T & keyof AggregateConta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConta[P]>
      : GetScalarType<T[P], AggregateConta[P]>
  }




  export type ContaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContaWhereInput
    orderBy?: ContaOrderByWithAggregationInput | ContaOrderByWithAggregationInput[]
    by: ContaScalarFieldEnum[] | ContaScalarFieldEnum
    having?: ContaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContaCountAggregateInputType | true
    _avg?: ContaAvgAggregateInputType
    _sum?: ContaSumAggregateInputType
    _min?: ContaMinAggregateInputType
    _max?: ContaMaxAggregateInputType
  }

  export type ContaGroupByOutputType = {
    id: number
    nome: string
    salario: number
    iban: string
    estado: boolean
    pessoa_id: number
    createdAt: Date
    updatedAt: Date
    _count: ContaCountAggregateOutputType | null
    _avg: ContaAvgAggregateOutputType | null
    _sum: ContaSumAggregateOutputType | null
    _min: ContaMinAggregateOutputType | null
    _max: ContaMaxAggregateOutputType | null
  }

  type GetContaGroupByPayload<T extends ContaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContaGroupByOutputType[P]>
            : GetScalarType<T[P], ContaGroupByOutputType[P]>
        }
      >
    >


  export type ContaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    salario?: boolean
    iban?: boolean
    estado?: boolean
    pessoa_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conta"]>



  export type ContaSelectScalar = {
    id?: boolean
    nome?: boolean
    salario?: boolean
    iban?: boolean
    estado?: boolean
    pessoa_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "salario" | "iban" | "estado" | "pessoa_id" | "createdAt" | "updatedAt", ExtArgs["result"]["conta"]>
  export type ContaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
  }

  export type $ContaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conta"
    objects: {
      pessoa: Prisma.$PessoaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      salario: number
      iban: string
      estado: boolean
      pessoa_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conta"]>
    composites: {}
  }

  type ContaGetPayload<S extends boolean | null | undefined | ContaDefaultArgs> = $Result.GetResult<Prisma.$ContaPayload, S>

  type ContaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContaCountAggregateInputType | true
    }

  export interface ContaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conta'], meta: { name: 'Conta' } }
    /**
     * Find zero or one Conta that matches the filter.
     * @param {ContaFindUniqueArgs} args - Arguments to find a Conta
     * @example
     * // Get one Conta
     * const conta = await prisma.conta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContaFindUniqueArgs>(args: SelectSubset<T, ContaFindUniqueArgs<ExtArgs>>): Prisma__ContaClient<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContaFindUniqueOrThrowArgs} args - Arguments to find a Conta
     * @example
     * // Get one Conta
     * const conta = await prisma.conta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContaFindUniqueOrThrowArgs>(args: SelectSubset<T, ContaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContaClient<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContaFindFirstArgs} args - Arguments to find a Conta
     * @example
     * // Get one Conta
     * const conta = await prisma.conta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContaFindFirstArgs>(args?: SelectSubset<T, ContaFindFirstArgs<ExtArgs>>): Prisma__ContaClient<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContaFindFirstOrThrowArgs} args - Arguments to find a Conta
     * @example
     * // Get one Conta
     * const conta = await prisma.conta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContaFindFirstOrThrowArgs>(args?: SelectSubset<T, ContaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContaClient<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contas
     * const contas = await prisma.conta.findMany()
     * 
     * // Get first 10 Contas
     * const contas = await prisma.conta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contaWithIdOnly = await prisma.conta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContaFindManyArgs>(args?: SelectSubset<T, ContaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conta.
     * @param {ContaCreateArgs} args - Arguments to create a Conta.
     * @example
     * // Create one Conta
     * const Conta = await prisma.conta.create({
     *   data: {
     *     // ... data to create a Conta
     *   }
     * })
     * 
     */
    create<T extends ContaCreateArgs>(args: SelectSubset<T, ContaCreateArgs<ExtArgs>>): Prisma__ContaClient<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contas.
     * @param {ContaCreateManyArgs} args - Arguments to create many Contas.
     * @example
     * // Create many Contas
     * const conta = await prisma.conta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContaCreateManyArgs>(args?: SelectSubset<T, ContaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conta.
     * @param {ContaDeleteArgs} args - Arguments to delete one Conta.
     * @example
     * // Delete one Conta
     * const Conta = await prisma.conta.delete({
     *   where: {
     *     // ... filter to delete one Conta
     *   }
     * })
     * 
     */
    delete<T extends ContaDeleteArgs>(args: SelectSubset<T, ContaDeleteArgs<ExtArgs>>): Prisma__ContaClient<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conta.
     * @param {ContaUpdateArgs} args - Arguments to update one Conta.
     * @example
     * // Update one Conta
     * const conta = await prisma.conta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContaUpdateArgs>(args: SelectSubset<T, ContaUpdateArgs<ExtArgs>>): Prisma__ContaClient<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contas.
     * @param {ContaDeleteManyArgs} args - Arguments to filter Contas to delete.
     * @example
     * // Delete a few Contas
     * const { count } = await prisma.conta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContaDeleteManyArgs>(args?: SelectSubset<T, ContaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contas
     * const conta = await prisma.conta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContaUpdateManyArgs>(args: SelectSubset<T, ContaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conta.
     * @param {ContaUpsertArgs} args - Arguments to update or create a Conta.
     * @example
     * // Update or create a Conta
     * const conta = await prisma.conta.upsert({
     *   create: {
     *     // ... data to create a Conta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conta we want to update
     *   }
     * })
     */
    upsert<T extends ContaUpsertArgs>(args: SelectSubset<T, ContaUpsertArgs<ExtArgs>>): Prisma__ContaClient<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContaCountArgs} args - Arguments to filter Contas to count.
     * @example
     * // Count the number of Contas
     * const count = await prisma.conta.count({
     *   where: {
     *     // ... the filter for the Contas we want to count
     *   }
     * })
    **/
    count<T extends ContaCountArgs>(
      args?: Subset<T, ContaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContaAggregateArgs>(args: Subset<T, ContaAggregateArgs>): Prisma.PrismaPromise<GetContaAggregateType<T>>

    /**
     * Group by Conta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContaGroupByArgs['orderBy'] }
        : { orderBy?: ContaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conta model
   */
  readonly fields: ContaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoa<T extends PessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PessoaDefaultArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conta model
   */
  interface ContaFieldRefs {
    readonly id: FieldRef<"Conta", 'Int'>
    readonly nome: FieldRef<"Conta", 'String'>
    readonly salario: FieldRef<"Conta", 'Int'>
    readonly iban: FieldRef<"Conta", 'String'>
    readonly estado: FieldRef<"Conta", 'Boolean'>
    readonly pessoa_id: FieldRef<"Conta", 'Int'>
    readonly createdAt: FieldRef<"Conta", 'DateTime'>
    readonly updatedAt: FieldRef<"Conta", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conta findUnique
   */
  export type ContaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conta
     */
    omit?: ContaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * Filter, which Conta to fetch.
     */
    where: ContaWhereUniqueInput
  }

  /**
   * Conta findUniqueOrThrow
   */
  export type ContaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conta
     */
    omit?: ContaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * Filter, which Conta to fetch.
     */
    where: ContaWhereUniqueInput
  }

  /**
   * Conta findFirst
   */
  export type ContaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conta
     */
    omit?: ContaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * Filter, which Conta to fetch.
     */
    where?: ContaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contas to fetch.
     */
    orderBy?: ContaOrderByWithRelationInput | ContaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contas.
     */
    cursor?: ContaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contas.
     */
    distinct?: ContaScalarFieldEnum | ContaScalarFieldEnum[]
  }

  /**
   * Conta findFirstOrThrow
   */
  export type ContaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conta
     */
    omit?: ContaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * Filter, which Conta to fetch.
     */
    where?: ContaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contas to fetch.
     */
    orderBy?: ContaOrderByWithRelationInput | ContaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contas.
     */
    cursor?: ContaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contas.
     */
    distinct?: ContaScalarFieldEnum | ContaScalarFieldEnum[]
  }

  /**
   * Conta findMany
   */
  export type ContaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conta
     */
    omit?: ContaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * Filter, which Contas to fetch.
     */
    where?: ContaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contas to fetch.
     */
    orderBy?: ContaOrderByWithRelationInput | ContaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contas.
     */
    cursor?: ContaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contas.
     */
    skip?: number
    distinct?: ContaScalarFieldEnum | ContaScalarFieldEnum[]
  }

  /**
   * Conta create
   */
  export type ContaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conta
     */
    omit?: ContaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * The data needed to create a Conta.
     */
    data: XOR<ContaCreateInput, ContaUncheckedCreateInput>
  }

  /**
   * Conta createMany
   */
  export type ContaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contas.
     */
    data: ContaCreateManyInput | ContaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conta update
   */
  export type ContaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conta
     */
    omit?: ContaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * The data needed to update a Conta.
     */
    data: XOR<ContaUpdateInput, ContaUncheckedUpdateInput>
    /**
     * Choose, which Conta to update.
     */
    where: ContaWhereUniqueInput
  }

  /**
   * Conta updateMany
   */
  export type ContaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contas.
     */
    data: XOR<ContaUpdateManyMutationInput, ContaUncheckedUpdateManyInput>
    /**
     * Filter which Contas to update
     */
    where?: ContaWhereInput
    /**
     * Limit how many Contas to update.
     */
    limit?: number
  }

  /**
   * Conta upsert
   */
  export type ContaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conta
     */
    omit?: ContaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * The filter to search for the Conta to update in case it exists.
     */
    where: ContaWhereUniqueInput
    /**
     * In case the Conta found by the `where` argument doesn't exist, create a new Conta with this data.
     */
    create: XOR<ContaCreateInput, ContaUncheckedCreateInput>
    /**
     * In case the Conta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContaUpdateInput, ContaUncheckedUpdateInput>
  }

  /**
   * Conta delete
   */
  export type ContaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conta
     */
    omit?: ContaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * Filter which Conta to delete.
     */
    where: ContaWhereUniqueInput
  }

  /**
   * Conta deleteMany
   */
  export type ContaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contas to delete
     */
    where?: ContaWhereInput
    /**
     * Limit how many Contas to delete.
     */
    limit?: number
  }

  /**
   * Conta without action
   */
  export type ContaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conta
     */
    omit?: ContaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
  }


  /**
   * Model Conjugue
   */

  export type AggregateConjugue = {
    _count: ConjugueCountAggregateOutputType | null
    _avg: ConjugueAvgAggregateOutputType | null
    _sum: ConjugueSumAggregateOutputType | null
    _min: ConjugueMinAggregateOutputType | null
    _max: ConjugueMaxAggregateOutputType | null
  }

  export type ConjugueAvgAggregateOutputType = {
    id: number | null
    dependentes: number | null
    pessoa_id: number | null
  }

  export type ConjugueSumAggregateOutputType = {
    id: number | null
    dependentes: number | null
    pessoa_id: number | null
  }

  export type ConjugueMinAggregateOutputType = {
    id: number | null
    nome_completo: string | null
    dependentes: number | null
    nivel_instrucao: string | null
    estado: boolean | null
    data_nascimento: Date | null
    pessoa_id: number | null
  }

  export type ConjugueMaxAggregateOutputType = {
    id: number | null
    nome_completo: string | null
    dependentes: number | null
    nivel_instrucao: string | null
    estado: boolean | null
    data_nascimento: Date | null
    pessoa_id: number | null
  }

  export type ConjugueCountAggregateOutputType = {
    id: number
    nome_completo: number
    dependentes: number
    nivel_instrucao: number
    estado: number
    data_nascimento: number
    pessoa_id: number
    _all: number
  }


  export type ConjugueAvgAggregateInputType = {
    id?: true
    dependentes?: true
    pessoa_id?: true
  }

  export type ConjugueSumAggregateInputType = {
    id?: true
    dependentes?: true
    pessoa_id?: true
  }

  export type ConjugueMinAggregateInputType = {
    id?: true
    nome_completo?: true
    dependentes?: true
    nivel_instrucao?: true
    estado?: true
    data_nascimento?: true
    pessoa_id?: true
  }

  export type ConjugueMaxAggregateInputType = {
    id?: true
    nome_completo?: true
    dependentes?: true
    nivel_instrucao?: true
    estado?: true
    data_nascimento?: true
    pessoa_id?: true
  }

  export type ConjugueCountAggregateInputType = {
    id?: true
    nome_completo?: true
    dependentes?: true
    nivel_instrucao?: true
    estado?: true
    data_nascimento?: true
    pessoa_id?: true
    _all?: true
  }

  export type ConjugueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conjugue to aggregate.
     */
    where?: ConjugueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conjugues to fetch.
     */
    orderBy?: ConjugueOrderByWithRelationInput | ConjugueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConjugueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conjugues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conjugues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conjugues
    **/
    _count?: true | ConjugueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConjugueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConjugueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConjugueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConjugueMaxAggregateInputType
  }

  export type GetConjugueAggregateType<T extends ConjugueAggregateArgs> = {
        [P in keyof T & keyof AggregateConjugue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConjugue[P]>
      : GetScalarType<T[P], AggregateConjugue[P]>
  }




  export type ConjugueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConjugueWhereInput
    orderBy?: ConjugueOrderByWithAggregationInput | ConjugueOrderByWithAggregationInput[]
    by: ConjugueScalarFieldEnum[] | ConjugueScalarFieldEnum
    having?: ConjugueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConjugueCountAggregateInputType | true
    _avg?: ConjugueAvgAggregateInputType
    _sum?: ConjugueSumAggregateInputType
    _min?: ConjugueMinAggregateInputType
    _max?: ConjugueMaxAggregateInputType
  }

  export type ConjugueGroupByOutputType = {
    id: number
    nome_completo: string
    dependentes: number
    nivel_instrucao: string
    estado: boolean
    data_nascimento: Date
    pessoa_id: number
    _count: ConjugueCountAggregateOutputType | null
    _avg: ConjugueAvgAggregateOutputType | null
    _sum: ConjugueSumAggregateOutputType | null
    _min: ConjugueMinAggregateOutputType | null
    _max: ConjugueMaxAggregateOutputType | null
  }

  type GetConjugueGroupByPayload<T extends ConjugueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConjugueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConjugueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConjugueGroupByOutputType[P]>
            : GetScalarType<T[P], ConjugueGroupByOutputType[P]>
        }
      >
    >


  export type ConjugueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome_completo?: boolean
    dependentes?: boolean
    nivel_instrucao?: boolean
    estado?: boolean
    data_nascimento?: boolean
    pessoa_id?: boolean
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conjugue"]>



  export type ConjugueSelectScalar = {
    id?: boolean
    nome_completo?: boolean
    dependentes?: boolean
    nivel_instrucao?: boolean
    estado?: boolean
    data_nascimento?: boolean
    pessoa_id?: boolean
  }

  export type ConjugueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome_completo" | "dependentes" | "nivel_instrucao" | "estado" | "data_nascimento" | "pessoa_id", ExtArgs["result"]["conjugue"]>
  export type ConjugueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
  }

  export type $ConjuguePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conjugue"
    objects: {
      pessoa: Prisma.$PessoaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome_completo: string
      dependentes: number
      nivel_instrucao: string
      estado: boolean
      data_nascimento: Date
      pessoa_id: number
    }, ExtArgs["result"]["conjugue"]>
    composites: {}
  }

  type ConjugueGetPayload<S extends boolean | null | undefined | ConjugueDefaultArgs> = $Result.GetResult<Prisma.$ConjuguePayload, S>

  type ConjugueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConjugueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConjugueCountAggregateInputType | true
    }

  export interface ConjugueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conjugue'], meta: { name: 'Conjugue' } }
    /**
     * Find zero or one Conjugue that matches the filter.
     * @param {ConjugueFindUniqueArgs} args - Arguments to find a Conjugue
     * @example
     * // Get one Conjugue
     * const conjugue = await prisma.conjugue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConjugueFindUniqueArgs>(args: SelectSubset<T, ConjugueFindUniqueArgs<ExtArgs>>): Prisma__ConjugueClient<$Result.GetResult<Prisma.$ConjuguePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conjugue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConjugueFindUniqueOrThrowArgs} args - Arguments to find a Conjugue
     * @example
     * // Get one Conjugue
     * const conjugue = await prisma.conjugue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConjugueFindUniqueOrThrowArgs>(args: SelectSubset<T, ConjugueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConjugueClient<$Result.GetResult<Prisma.$ConjuguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conjugue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConjugueFindFirstArgs} args - Arguments to find a Conjugue
     * @example
     * // Get one Conjugue
     * const conjugue = await prisma.conjugue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConjugueFindFirstArgs>(args?: SelectSubset<T, ConjugueFindFirstArgs<ExtArgs>>): Prisma__ConjugueClient<$Result.GetResult<Prisma.$ConjuguePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conjugue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConjugueFindFirstOrThrowArgs} args - Arguments to find a Conjugue
     * @example
     * // Get one Conjugue
     * const conjugue = await prisma.conjugue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConjugueFindFirstOrThrowArgs>(args?: SelectSubset<T, ConjugueFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConjugueClient<$Result.GetResult<Prisma.$ConjuguePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conjugues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConjugueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conjugues
     * const conjugues = await prisma.conjugue.findMany()
     * 
     * // Get first 10 Conjugues
     * const conjugues = await prisma.conjugue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conjugueWithIdOnly = await prisma.conjugue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConjugueFindManyArgs>(args?: SelectSubset<T, ConjugueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConjuguePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conjugue.
     * @param {ConjugueCreateArgs} args - Arguments to create a Conjugue.
     * @example
     * // Create one Conjugue
     * const Conjugue = await prisma.conjugue.create({
     *   data: {
     *     // ... data to create a Conjugue
     *   }
     * })
     * 
     */
    create<T extends ConjugueCreateArgs>(args: SelectSubset<T, ConjugueCreateArgs<ExtArgs>>): Prisma__ConjugueClient<$Result.GetResult<Prisma.$ConjuguePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conjugues.
     * @param {ConjugueCreateManyArgs} args - Arguments to create many Conjugues.
     * @example
     * // Create many Conjugues
     * const conjugue = await prisma.conjugue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConjugueCreateManyArgs>(args?: SelectSubset<T, ConjugueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conjugue.
     * @param {ConjugueDeleteArgs} args - Arguments to delete one Conjugue.
     * @example
     * // Delete one Conjugue
     * const Conjugue = await prisma.conjugue.delete({
     *   where: {
     *     // ... filter to delete one Conjugue
     *   }
     * })
     * 
     */
    delete<T extends ConjugueDeleteArgs>(args: SelectSubset<T, ConjugueDeleteArgs<ExtArgs>>): Prisma__ConjugueClient<$Result.GetResult<Prisma.$ConjuguePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conjugue.
     * @param {ConjugueUpdateArgs} args - Arguments to update one Conjugue.
     * @example
     * // Update one Conjugue
     * const conjugue = await prisma.conjugue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConjugueUpdateArgs>(args: SelectSubset<T, ConjugueUpdateArgs<ExtArgs>>): Prisma__ConjugueClient<$Result.GetResult<Prisma.$ConjuguePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conjugues.
     * @param {ConjugueDeleteManyArgs} args - Arguments to filter Conjugues to delete.
     * @example
     * // Delete a few Conjugues
     * const { count } = await prisma.conjugue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConjugueDeleteManyArgs>(args?: SelectSubset<T, ConjugueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conjugues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConjugueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conjugues
     * const conjugue = await prisma.conjugue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConjugueUpdateManyArgs>(args: SelectSubset<T, ConjugueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conjugue.
     * @param {ConjugueUpsertArgs} args - Arguments to update or create a Conjugue.
     * @example
     * // Update or create a Conjugue
     * const conjugue = await prisma.conjugue.upsert({
     *   create: {
     *     // ... data to create a Conjugue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conjugue we want to update
     *   }
     * })
     */
    upsert<T extends ConjugueUpsertArgs>(args: SelectSubset<T, ConjugueUpsertArgs<ExtArgs>>): Prisma__ConjugueClient<$Result.GetResult<Prisma.$ConjuguePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conjugues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConjugueCountArgs} args - Arguments to filter Conjugues to count.
     * @example
     * // Count the number of Conjugues
     * const count = await prisma.conjugue.count({
     *   where: {
     *     // ... the filter for the Conjugues we want to count
     *   }
     * })
    **/
    count<T extends ConjugueCountArgs>(
      args?: Subset<T, ConjugueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConjugueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conjugue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConjugueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConjugueAggregateArgs>(args: Subset<T, ConjugueAggregateArgs>): Prisma.PrismaPromise<GetConjugueAggregateType<T>>

    /**
     * Group by Conjugue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConjugueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConjugueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConjugueGroupByArgs['orderBy'] }
        : { orderBy?: ConjugueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConjugueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConjugueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conjugue model
   */
  readonly fields: ConjugueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conjugue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConjugueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoa<T extends PessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PessoaDefaultArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conjugue model
   */
  interface ConjugueFieldRefs {
    readonly id: FieldRef<"Conjugue", 'Int'>
    readonly nome_completo: FieldRef<"Conjugue", 'String'>
    readonly dependentes: FieldRef<"Conjugue", 'Int'>
    readonly nivel_instrucao: FieldRef<"Conjugue", 'String'>
    readonly estado: FieldRef<"Conjugue", 'Boolean'>
    readonly data_nascimento: FieldRef<"Conjugue", 'DateTime'>
    readonly pessoa_id: FieldRef<"Conjugue", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Conjugue findUnique
   */
  export type ConjugueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conjugue
     */
    select?: ConjugueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conjugue
     */
    omit?: ConjugueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConjugueInclude<ExtArgs> | null
    /**
     * Filter, which Conjugue to fetch.
     */
    where: ConjugueWhereUniqueInput
  }

  /**
   * Conjugue findUniqueOrThrow
   */
  export type ConjugueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conjugue
     */
    select?: ConjugueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conjugue
     */
    omit?: ConjugueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConjugueInclude<ExtArgs> | null
    /**
     * Filter, which Conjugue to fetch.
     */
    where: ConjugueWhereUniqueInput
  }

  /**
   * Conjugue findFirst
   */
  export type ConjugueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conjugue
     */
    select?: ConjugueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conjugue
     */
    omit?: ConjugueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConjugueInclude<ExtArgs> | null
    /**
     * Filter, which Conjugue to fetch.
     */
    where?: ConjugueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conjugues to fetch.
     */
    orderBy?: ConjugueOrderByWithRelationInput | ConjugueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conjugues.
     */
    cursor?: ConjugueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conjugues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conjugues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conjugues.
     */
    distinct?: ConjugueScalarFieldEnum | ConjugueScalarFieldEnum[]
  }

  /**
   * Conjugue findFirstOrThrow
   */
  export type ConjugueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conjugue
     */
    select?: ConjugueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conjugue
     */
    omit?: ConjugueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConjugueInclude<ExtArgs> | null
    /**
     * Filter, which Conjugue to fetch.
     */
    where?: ConjugueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conjugues to fetch.
     */
    orderBy?: ConjugueOrderByWithRelationInput | ConjugueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conjugues.
     */
    cursor?: ConjugueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conjugues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conjugues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conjugues.
     */
    distinct?: ConjugueScalarFieldEnum | ConjugueScalarFieldEnum[]
  }

  /**
   * Conjugue findMany
   */
  export type ConjugueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conjugue
     */
    select?: ConjugueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conjugue
     */
    omit?: ConjugueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConjugueInclude<ExtArgs> | null
    /**
     * Filter, which Conjugues to fetch.
     */
    where?: ConjugueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conjugues to fetch.
     */
    orderBy?: ConjugueOrderByWithRelationInput | ConjugueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conjugues.
     */
    cursor?: ConjugueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conjugues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conjugues.
     */
    skip?: number
    distinct?: ConjugueScalarFieldEnum | ConjugueScalarFieldEnum[]
  }

  /**
   * Conjugue create
   */
  export type ConjugueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conjugue
     */
    select?: ConjugueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conjugue
     */
    omit?: ConjugueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConjugueInclude<ExtArgs> | null
    /**
     * The data needed to create a Conjugue.
     */
    data: XOR<ConjugueCreateInput, ConjugueUncheckedCreateInput>
  }

  /**
   * Conjugue createMany
   */
  export type ConjugueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conjugues.
     */
    data: ConjugueCreateManyInput | ConjugueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conjugue update
   */
  export type ConjugueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conjugue
     */
    select?: ConjugueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conjugue
     */
    omit?: ConjugueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConjugueInclude<ExtArgs> | null
    /**
     * The data needed to update a Conjugue.
     */
    data: XOR<ConjugueUpdateInput, ConjugueUncheckedUpdateInput>
    /**
     * Choose, which Conjugue to update.
     */
    where: ConjugueWhereUniqueInput
  }

  /**
   * Conjugue updateMany
   */
  export type ConjugueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conjugues.
     */
    data: XOR<ConjugueUpdateManyMutationInput, ConjugueUncheckedUpdateManyInput>
    /**
     * Filter which Conjugues to update
     */
    where?: ConjugueWhereInput
    /**
     * Limit how many Conjugues to update.
     */
    limit?: number
  }

  /**
   * Conjugue upsert
   */
  export type ConjugueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conjugue
     */
    select?: ConjugueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conjugue
     */
    omit?: ConjugueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConjugueInclude<ExtArgs> | null
    /**
     * The filter to search for the Conjugue to update in case it exists.
     */
    where: ConjugueWhereUniqueInput
    /**
     * In case the Conjugue found by the `where` argument doesn't exist, create a new Conjugue with this data.
     */
    create: XOR<ConjugueCreateInput, ConjugueUncheckedCreateInput>
    /**
     * In case the Conjugue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConjugueUpdateInput, ConjugueUncheckedUpdateInput>
  }

  /**
   * Conjugue delete
   */
  export type ConjugueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conjugue
     */
    select?: ConjugueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conjugue
     */
    omit?: ConjugueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConjugueInclude<ExtArgs> | null
    /**
     * Filter which Conjugue to delete.
     */
    where: ConjugueWhereUniqueInput
  }

  /**
   * Conjugue deleteMany
   */
  export type ConjugueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conjugues to delete
     */
    where?: ConjugueWhereInput
    /**
     * Limit how many Conjugues to delete.
     */
    limit?: number
  }

  /**
   * Conjugue without action
   */
  export type ConjugueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conjugue
     */
    select?: ConjugueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conjugue
     */
    omit?: ConjugueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConjugueInclude<ExtArgs> | null
  }


  /**
   * Model Documento
   */

  export type AggregateDocumento = {
    _count: DocumentoCountAggregateOutputType | null
    _avg: DocumentoAvgAggregateOutputType | null
    _sum: DocumentoSumAggregateOutputType | null
    _min: DocumentoMinAggregateOutputType | null
    _max: DocumentoMaxAggregateOutputType | null
  }

  export type DocumentoAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type DocumentoSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type DocumentoMinAggregateOutputType = {
    id: number | null
    tipo: $Enums.Comprovativo | null
    titulo: string | null
    extensao: string | null
    tamanho: string | null
    nome_original: string | null
    nome_salvado: string | null
    estado: boolean | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentoMaxAggregateOutputType = {
    id: number | null
    tipo: $Enums.Comprovativo | null
    titulo: string | null
    extensao: string | null
    tamanho: string | null
    nome_original: string | null
    nome_salvado: string | null
    estado: boolean | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentoCountAggregateOutputType = {
    id: number
    tipo: number
    titulo: number
    extensao: number
    tamanho: number
    nome_original: number
    nome_salvado: number
    estado: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentoAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type DocumentoSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type DocumentoMinAggregateInputType = {
    id?: true
    tipo?: true
    titulo?: true
    extensao?: true
    tamanho?: true
    nome_original?: true
    nome_salvado?: true
    estado?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentoMaxAggregateInputType = {
    id?: true
    tipo?: true
    titulo?: true
    extensao?: true
    tamanho?: true
    nome_original?: true
    nome_salvado?: true
    estado?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentoCountAggregateInputType = {
    id?: true
    tipo?: true
    titulo?: true
    extensao?: true
    tamanho?: true
    nome_original?: true
    nome_salvado?: true
    estado?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documento to aggregate.
     */
    where?: DocumentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentos to fetch.
     */
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documentos
    **/
    _count?: true | DocumentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentoMaxAggregateInputType
  }

  export type GetDocumentoAggregateType<T extends DocumentoAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumento[P]>
      : GetScalarType<T[P], AggregateDocumento[P]>
  }




  export type DocumentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentoWhereInput
    orderBy?: DocumentoOrderByWithAggregationInput | DocumentoOrderByWithAggregationInput[]
    by: DocumentoScalarFieldEnum[] | DocumentoScalarFieldEnum
    having?: DocumentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentoCountAggregateInputType | true
    _avg?: DocumentoAvgAggregateInputType
    _sum?: DocumentoSumAggregateInputType
    _min?: DocumentoMinAggregateInputType
    _max?: DocumentoMaxAggregateInputType
  }

  export type DocumentoGroupByOutputType = {
    id: number
    tipo: $Enums.Comprovativo
    titulo: string
    extensao: string
    tamanho: string
    nome_original: string
    nome_salvado: string
    estado: boolean
    user_id: number
    createdAt: Date
    updatedAt: Date
    _count: DocumentoCountAggregateOutputType | null
    _avg: DocumentoAvgAggregateOutputType | null
    _sum: DocumentoSumAggregateOutputType | null
    _min: DocumentoMinAggregateOutputType | null
    _max: DocumentoMaxAggregateOutputType | null
  }

  type GetDocumentoGroupByPayload<T extends DocumentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentoGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentoGroupByOutputType[P]>
        }
      >
    >


  export type DocumentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    titulo?: boolean
    extensao?: boolean
    tamanho?: boolean
    nome_original?: boolean
    nome_salvado?: boolean
    estado?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documento"]>



  export type DocumentoSelectScalar = {
    id?: boolean
    tipo?: boolean
    titulo?: boolean
    extensao?: boolean
    tamanho?: boolean
    nome_original?: boolean
    nome_salvado?: boolean
    estado?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipo" | "titulo" | "extensao" | "tamanho" | "nome_original" | "nome_salvado" | "estado" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["documento"]>
  export type DocumentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Documento"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipo: $Enums.Comprovativo
      titulo: string
      extensao: string
      tamanho: string
      nome_original: string
      nome_salvado: string
      estado: boolean
      user_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["documento"]>
    composites: {}
  }

  type DocumentoGetPayload<S extends boolean | null | undefined | DocumentoDefaultArgs> = $Result.GetResult<Prisma.$DocumentoPayload, S>

  type DocumentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentoCountAggregateInputType | true
    }

  export interface DocumentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Documento'], meta: { name: 'Documento' } }
    /**
     * Find zero or one Documento that matches the filter.
     * @param {DocumentoFindUniqueArgs} args - Arguments to find a Documento
     * @example
     * // Get one Documento
     * const documento = await prisma.documento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentoFindUniqueArgs>(args: SelectSubset<T, DocumentoFindUniqueArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Documento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentoFindUniqueOrThrowArgs} args - Arguments to find a Documento
     * @example
     * // Get one Documento
     * const documento = await prisma.documento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentoFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoFindFirstArgs} args - Arguments to find a Documento
     * @example
     * // Get one Documento
     * const documento = await prisma.documento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentoFindFirstArgs>(args?: SelectSubset<T, DocumentoFindFirstArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoFindFirstOrThrowArgs} args - Arguments to find a Documento
     * @example
     * // Get one Documento
     * const documento = await prisma.documento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentoFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documentos
     * const documentos = await prisma.documento.findMany()
     * 
     * // Get first 10 Documentos
     * const documentos = await prisma.documento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentoWithIdOnly = await prisma.documento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentoFindManyArgs>(args?: SelectSubset<T, DocumentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Documento.
     * @param {DocumentoCreateArgs} args - Arguments to create a Documento.
     * @example
     * // Create one Documento
     * const Documento = await prisma.documento.create({
     *   data: {
     *     // ... data to create a Documento
     *   }
     * })
     * 
     */
    create<T extends DocumentoCreateArgs>(args: SelectSubset<T, DocumentoCreateArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documentos.
     * @param {DocumentoCreateManyArgs} args - Arguments to create many Documentos.
     * @example
     * // Create many Documentos
     * const documento = await prisma.documento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentoCreateManyArgs>(args?: SelectSubset<T, DocumentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Documento.
     * @param {DocumentoDeleteArgs} args - Arguments to delete one Documento.
     * @example
     * // Delete one Documento
     * const Documento = await prisma.documento.delete({
     *   where: {
     *     // ... filter to delete one Documento
     *   }
     * })
     * 
     */
    delete<T extends DocumentoDeleteArgs>(args: SelectSubset<T, DocumentoDeleteArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Documento.
     * @param {DocumentoUpdateArgs} args - Arguments to update one Documento.
     * @example
     * // Update one Documento
     * const documento = await prisma.documento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentoUpdateArgs>(args: SelectSubset<T, DocumentoUpdateArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documentos.
     * @param {DocumentoDeleteManyArgs} args - Arguments to filter Documentos to delete.
     * @example
     * // Delete a few Documentos
     * const { count } = await prisma.documento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentoDeleteManyArgs>(args?: SelectSubset<T, DocumentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documentos
     * const documento = await prisma.documento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentoUpdateManyArgs>(args: SelectSubset<T, DocumentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Documento.
     * @param {DocumentoUpsertArgs} args - Arguments to update or create a Documento.
     * @example
     * // Update or create a Documento
     * const documento = await prisma.documento.upsert({
     *   create: {
     *     // ... data to create a Documento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Documento we want to update
     *   }
     * })
     */
    upsert<T extends DocumentoUpsertArgs>(args: SelectSubset<T, DocumentoUpsertArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoCountArgs} args - Arguments to filter Documentos to count.
     * @example
     * // Count the number of Documentos
     * const count = await prisma.documento.count({
     *   where: {
     *     // ... the filter for the Documentos we want to count
     *   }
     * })
    **/
    count<T extends DocumentoCountArgs>(
      args?: Subset<T, DocumentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Documento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentoAggregateArgs>(args: Subset<T, DocumentoAggregateArgs>): Prisma.PrismaPromise<GetDocumentoAggregateType<T>>

    /**
     * Group by Documento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentoGroupByArgs['orderBy'] }
        : { orderBy?: DocumentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Documento model
   */
  readonly fields: DocumentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Documento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Documento model
   */
  interface DocumentoFieldRefs {
    readonly id: FieldRef<"Documento", 'Int'>
    readonly tipo: FieldRef<"Documento", 'Comprovativo'>
    readonly titulo: FieldRef<"Documento", 'String'>
    readonly extensao: FieldRef<"Documento", 'String'>
    readonly tamanho: FieldRef<"Documento", 'String'>
    readonly nome_original: FieldRef<"Documento", 'String'>
    readonly nome_salvado: FieldRef<"Documento", 'String'>
    readonly estado: FieldRef<"Documento", 'Boolean'>
    readonly user_id: FieldRef<"Documento", 'Int'>
    readonly createdAt: FieldRef<"Documento", 'DateTime'>
    readonly updatedAt: FieldRef<"Documento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Documento findUnique
   */
  export type DocumentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter, which Documento to fetch.
     */
    where: DocumentoWhereUniqueInput
  }

  /**
   * Documento findUniqueOrThrow
   */
  export type DocumentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter, which Documento to fetch.
     */
    where: DocumentoWhereUniqueInput
  }

  /**
   * Documento findFirst
   */
  export type DocumentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter, which Documento to fetch.
     */
    where?: DocumentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentos to fetch.
     */
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documentos.
     */
    cursor?: DocumentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documentos.
     */
    distinct?: DocumentoScalarFieldEnum | DocumentoScalarFieldEnum[]
  }

  /**
   * Documento findFirstOrThrow
   */
  export type DocumentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter, which Documento to fetch.
     */
    where?: DocumentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentos to fetch.
     */
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documentos.
     */
    cursor?: DocumentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documentos.
     */
    distinct?: DocumentoScalarFieldEnum | DocumentoScalarFieldEnum[]
  }

  /**
   * Documento findMany
   */
  export type DocumentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter, which Documentos to fetch.
     */
    where?: DocumentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentos to fetch.
     */
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documentos.
     */
    cursor?: DocumentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentos.
     */
    skip?: number
    distinct?: DocumentoScalarFieldEnum | DocumentoScalarFieldEnum[]
  }

  /**
   * Documento create
   */
  export type DocumentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Documento.
     */
    data: XOR<DocumentoCreateInput, DocumentoUncheckedCreateInput>
  }

  /**
   * Documento createMany
   */
  export type DocumentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documentos.
     */
    data: DocumentoCreateManyInput | DocumentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Documento update
   */
  export type DocumentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Documento.
     */
    data: XOR<DocumentoUpdateInput, DocumentoUncheckedUpdateInput>
    /**
     * Choose, which Documento to update.
     */
    where: DocumentoWhereUniqueInput
  }

  /**
   * Documento updateMany
   */
  export type DocumentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documentos.
     */
    data: XOR<DocumentoUpdateManyMutationInput, DocumentoUncheckedUpdateManyInput>
    /**
     * Filter which Documentos to update
     */
    where?: DocumentoWhereInput
    /**
     * Limit how many Documentos to update.
     */
    limit?: number
  }

  /**
   * Documento upsert
   */
  export type DocumentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Documento to update in case it exists.
     */
    where: DocumentoWhereUniqueInput
    /**
     * In case the Documento found by the `where` argument doesn't exist, create a new Documento with this data.
     */
    create: XOR<DocumentoCreateInput, DocumentoUncheckedCreateInput>
    /**
     * In case the Documento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentoUpdateInput, DocumentoUncheckedUpdateInput>
  }

  /**
   * Documento delete
   */
  export type DocumentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter which Documento to delete.
     */
    where: DocumentoWhereUniqueInput
  }

  /**
   * Documento deleteMany
   */
  export type DocumentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documentos to delete
     */
    where?: DocumentoWhereInput
    /**
     * Limit how many Documentos to delete.
     */
    limit?: number
  }

  /**
   * Documento without action
   */
  export type DocumentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
  }


  /**
   * Model Devedor
   */

  export type AggregateDevedor = {
    _count: DevedorCountAggregateOutputType | null
    _avg: DevedorAvgAggregateOutputType | null
    _sum: DevedorSumAggregateOutputType | null
    _min: DevedorMinAggregateOutputType | null
    _max: DevedorMaxAggregateOutputType | null
  }

  export type DevedorAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    solicitacao: number | null
    adimplencia: number | null
    inadimplencia: number | null
  }

  export type DevedorSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    solicitacao: number | null
    adimplencia: number | null
    inadimplencia: number | null
  }

  export type DevedorMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    solicitacao: number | null
    adimplencia: number | null
    inadimplencia: number | null
    estado: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DevedorMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    solicitacao: number | null
    adimplencia: number | null
    inadimplencia: number | null
    estado: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DevedorCountAggregateOutputType = {
    id: number
    user_id: number
    solicitacao: number
    adimplencia: number
    inadimplencia: number
    estado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DevedorAvgAggregateInputType = {
    id?: true
    user_id?: true
    solicitacao?: true
    adimplencia?: true
    inadimplencia?: true
  }

  export type DevedorSumAggregateInputType = {
    id?: true
    user_id?: true
    solicitacao?: true
    adimplencia?: true
    inadimplencia?: true
  }

  export type DevedorMinAggregateInputType = {
    id?: true
    user_id?: true
    solicitacao?: true
    adimplencia?: true
    inadimplencia?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DevedorMaxAggregateInputType = {
    id?: true
    user_id?: true
    solicitacao?: true
    adimplencia?: true
    inadimplencia?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DevedorCountAggregateInputType = {
    id?: true
    user_id?: true
    solicitacao?: true
    adimplencia?: true
    inadimplencia?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DevedorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devedor to aggregate.
     */
    where?: DevedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devedors to fetch.
     */
    orderBy?: DevedorOrderByWithRelationInput | DevedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DevedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devedors
    **/
    _count?: true | DevedorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DevedorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DevedorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DevedorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DevedorMaxAggregateInputType
  }

  export type GetDevedorAggregateType<T extends DevedorAggregateArgs> = {
        [P in keyof T & keyof AggregateDevedor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevedor[P]>
      : GetScalarType<T[P], AggregateDevedor[P]>
  }




  export type DevedorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DevedorWhereInput
    orderBy?: DevedorOrderByWithAggregationInput | DevedorOrderByWithAggregationInput[]
    by: DevedorScalarFieldEnum[] | DevedorScalarFieldEnum
    having?: DevedorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DevedorCountAggregateInputType | true
    _avg?: DevedorAvgAggregateInputType
    _sum?: DevedorSumAggregateInputType
    _min?: DevedorMinAggregateInputType
    _max?: DevedorMaxAggregateInputType
  }

  export type DevedorGroupByOutputType = {
    id: number
    user_id: number
    solicitacao: number
    adimplencia: number
    inadimplencia: number
    estado: boolean
    createdAt: Date
    updatedAt: Date
    _count: DevedorCountAggregateOutputType | null
    _avg: DevedorAvgAggregateOutputType | null
    _sum: DevedorSumAggregateOutputType | null
    _min: DevedorMinAggregateOutputType | null
    _max: DevedorMaxAggregateOutputType | null
  }

  type GetDevedorGroupByPayload<T extends DevedorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DevedorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DevedorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DevedorGroupByOutputType[P]>
            : GetScalarType<T[P], DevedorGroupByOutputType[P]>
        }
      >
    >


  export type DevedorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    solicitacao?: boolean
    adimplencia?: boolean
    inadimplencia?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    credito?: boolean | Devedor$creditoArgs<ExtArgs>
    movel?: boolean | Devedor$movelArgs<ExtArgs>
    pagamento?: boolean | Devedor$pagamentoArgs<ExtArgs>
    _count?: boolean | DevedorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["devedor"]>



  export type DevedorSelectScalar = {
    id?: boolean
    user_id?: boolean
    solicitacao?: boolean
    adimplencia?: boolean
    inadimplencia?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DevedorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "solicitacao" | "adimplencia" | "inadimplencia" | "estado" | "createdAt" | "updatedAt", ExtArgs["result"]["devedor"]>
  export type DevedorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    credito?: boolean | Devedor$creditoArgs<ExtArgs>
    movel?: boolean | Devedor$movelArgs<ExtArgs>
    pagamento?: boolean | Devedor$pagamentoArgs<ExtArgs>
    _count?: boolean | DevedorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DevedorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Devedor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      credito: Prisma.$CreditoPayload<ExtArgs>[]
      movel: Prisma.$MovelPayload<ExtArgs>[]
      pagamento: Prisma.$PagamentoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      solicitacao: number
      adimplencia: number
      inadimplencia: number
      estado: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["devedor"]>
    composites: {}
  }

  type DevedorGetPayload<S extends boolean | null | undefined | DevedorDefaultArgs> = $Result.GetResult<Prisma.$DevedorPayload, S>

  type DevedorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DevedorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DevedorCountAggregateInputType | true
    }

  export interface DevedorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Devedor'], meta: { name: 'Devedor' } }
    /**
     * Find zero or one Devedor that matches the filter.
     * @param {DevedorFindUniqueArgs} args - Arguments to find a Devedor
     * @example
     * // Get one Devedor
     * const devedor = await prisma.devedor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DevedorFindUniqueArgs>(args: SelectSubset<T, DevedorFindUniqueArgs<ExtArgs>>): Prisma__DevedorClient<$Result.GetResult<Prisma.$DevedorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Devedor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DevedorFindUniqueOrThrowArgs} args - Arguments to find a Devedor
     * @example
     * // Get one Devedor
     * const devedor = await prisma.devedor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DevedorFindUniqueOrThrowArgs>(args: SelectSubset<T, DevedorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DevedorClient<$Result.GetResult<Prisma.$DevedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Devedor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevedorFindFirstArgs} args - Arguments to find a Devedor
     * @example
     * // Get one Devedor
     * const devedor = await prisma.devedor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DevedorFindFirstArgs>(args?: SelectSubset<T, DevedorFindFirstArgs<ExtArgs>>): Prisma__DevedorClient<$Result.GetResult<Prisma.$DevedorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Devedor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevedorFindFirstOrThrowArgs} args - Arguments to find a Devedor
     * @example
     * // Get one Devedor
     * const devedor = await prisma.devedor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DevedorFindFirstOrThrowArgs>(args?: SelectSubset<T, DevedorFindFirstOrThrowArgs<ExtArgs>>): Prisma__DevedorClient<$Result.GetResult<Prisma.$DevedorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Devedors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevedorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devedors
     * const devedors = await prisma.devedor.findMany()
     * 
     * // Get first 10 Devedors
     * const devedors = await prisma.devedor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const devedorWithIdOnly = await prisma.devedor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DevedorFindManyArgs>(args?: SelectSubset<T, DevedorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevedorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Devedor.
     * @param {DevedorCreateArgs} args - Arguments to create a Devedor.
     * @example
     * // Create one Devedor
     * const Devedor = await prisma.devedor.create({
     *   data: {
     *     // ... data to create a Devedor
     *   }
     * })
     * 
     */
    create<T extends DevedorCreateArgs>(args: SelectSubset<T, DevedorCreateArgs<ExtArgs>>): Prisma__DevedorClient<$Result.GetResult<Prisma.$DevedorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Devedors.
     * @param {DevedorCreateManyArgs} args - Arguments to create many Devedors.
     * @example
     * // Create many Devedors
     * const devedor = await prisma.devedor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DevedorCreateManyArgs>(args?: SelectSubset<T, DevedorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Devedor.
     * @param {DevedorDeleteArgs} args - Arguments to delete one Devedor.
     * @example
     * // Delete one Devedor
     * const Devedor = await prisma.devedor.delete({
     *   where: {
     *     // ... filter to delete one Devedor
     *   }
     * })
     * 
     */
    delete<T extends DevedorDeleteArgs>(args: SelectSubset<T, DevedorDeleteArgs<ExtArgs>>): Prisma__DevedorClient<$Result.GetResult<Prisma.$DevedorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Devedor.
     * @param {DevedorUpdateArgs} args - Arguments to update one Devedor.
     * @example
     * // Update one Devedor
     * const devedor = await prisma.devedor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DevedorUpdateArgs>(args: SelectSubset<T, DevedorUpdateArgs<ExtArgs>>): Prisma__DevedorClient<$Result.GetResult<Prisma.$DevedorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Devedors.
     * @param {DevedorDeleteManyArgs} args - Arguments to filter Devedors to delete.
     * @example
     * // Delete a few Devedors
     * const { count } = await prisma.devedor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DevedorDeleteManyArgs>(args?: SelectSubset<T, DevedorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevedorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devedors
     * const devedor = await prisma.devedor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DevedorUpdateManyArgs>(args: SelectSubset<T, DevedorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Devedor.
     * @param {DevedorUpsertArgs} args - Arguments to update or create a Devedor.
     * @example
     * // Update or create a Devedor
     * const devedor = await prisma.devedor.upsert({
     *   create: {
     *     // ... data to create a Devedor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Devedor we want to update
     *   }
     * })
     */
    upsert<T extends DevedorUpsertArgs>(args: SelectSubset<T, DevedorUpsertArgs<ExtArgs>>): Prisma__DevedorClient<$Result.GetResult<Prisma.$DevedorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Devedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevedorCountArgs} args - Arguments to filter Devedors to count.
     * @example
     * // Count the number of Devedors
     * const count = await prisma.devedor.count({
     *   where: {
     *     // ... the filter for the Devedors we want to count
     *   }
     * })
    **/
    count<T extends DevedorCountArgs>(
      args?: Subset<T, DevedorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DevedorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Devedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevedorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DevedorAggregateArgs>(args: Subset<T, DevedorAggregateArgs>): Prisma.PrismaPromise<GetDevedorAggregateType<T>>

    /**
     * Group by Devedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevedorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DevedorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DevedorGroupByArgs['orderBy'] }
        : { orderBy?: DevedorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DevedorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDevedorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Devedor model
   */
  readonly fields: DevedorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Devedor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DevedorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    credito<T extends Devedor$creditoArgs<ExtArgs> = {}>(args?: Subset<T, Devedor$creditoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    movel<T extends Devedor$movelArgs<ExtArgs> = {}>(args?: Subset<T, Devedor$movelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pagamento<T extends Devedor$pagamentoArgs<ExtArgs> = {}>(args?: Subset<T, Devedor$pagamentoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Devedor model
   */
  interface DevedorFieldRefs {
    readonly id: FieldRef<"Devedor", 'Int'>
    readonly user_id: FieldRef<"Devedor", 'Int'>
    readonly solicitacao: FieldRef<"Devedor", 'Int'>
    readonly adimplencia: FieldRef<"Devedor", 'Int'>
    readonly inadimplencia: FieldRef<"Devedor", 'Int'>
    readonly estado: FieldRef<"Devedor", 'Boolean'>
    readonly createdAt: FieldRef<"Devedor", 'DateTime'>
    readonly updatedAt: FieldRef<"Devedor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Devedor findUnique
   */
  export type DevedorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devedor
     */
    select?: DevedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devedor
     */
    omit?: DevedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevedorInclude<ExtArgs> | null
    /**
     * Filter, which Devedor to fetch.
     */
    where: DevedorWhereUniqueInput
  }

  /**
   * Devedor findUniqueOrThrow
   */
  export type DevedorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devedor
     */
    select?: DevedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devedor
     */
    omit?: DevedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevedorInclude<ExtArgs> | null
    /**
     * Filter, which Devedor to fetch.
     */
    where: DevedorWhereUniqueInput
  }

  /**
   * Devedor findFirst
   */
  export type DevedorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devedor
     */
    select?: DevedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devedor
     */
    omit?: DevedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevedorInclude<ExtArgs> | null
    /**
     * Filter, which Devedor to fetch.
     */
    where?: DevedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devedors to fetch.
     */
    orderBy?: DevedorOrderByWithRelationInput | DevedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devedors.
     */
    cursor?: DevedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devedors.
     */
    distinct?: DevedorScalarFieldEnum | DevedorScalarFieldEnum[]
  }

  /**
   * Devedor findFirstOrThrow
   */
  export type DevedorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devedor
     */
    select?: DevedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devedor
     */
    omit?: DevedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevedorInclude<ExtArgs> | null
    /**
     * Filter, which Devedor to fetch.
     */
    where?: DevedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devedors to fetch.
     */
    orderBy?: DevedorOrderByWithRelationInput | DevedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devedors.
     */
    cursor?: DevedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devedors.
     */
    distinct?: DevedorScalarFieldEnum | DevedorScalarFieldEnum[]
  }

  /**
   * Devedor findMany
   */
  export type DevedorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devedor
     */
    select?: DevedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devedor
     */
    omit?: DevedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevedorInclude<ExtArgs> | null
    /**
     * Filter, which Devedors to fetch.
     */
    where?: DevedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devedors to fetch.
     */
    orderBy?: DevedorOrderByWithRelationInput | DevedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devedors.
     */
    cursor?: DevedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devedors.
     */
    skip?: number
    distinct?: DevedorScalarFieldEnum | DevedorScalarFieldEnum[]
  }

  /**
   * Devedor create
   */
  export type DevedorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devedor
     */
    select?: DevedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devedor
     */
    omit?: DevedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevedorInclude<ExtArgs> | null
    /**
     * The data needed to create a Devedor.
     */
    data: XOR<DevedorCreateInput, DevedorUncheckedCreateInput>
  }

  /**
   * Devedor createMany
   */
  export type DevedorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devedors.
     */
    data: DevedorCreateManyInput | DevedorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Devedor update
   */
  export type DevedorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devedor
     */
    select?: DevedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devedor
     */
    omit?: DevedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevedorInclude<ExtArgs> | null
    /**
     * The data needed to update a Devedor.
     */
    data: XOR<DevedorUpdateInput, DevedorUncheckedUpdateInput>
    /**
     * Choose, which Devedor to update.
     */
    where: DevedorWhereUniqueInput
  }

  /**
   * Devedor updateMany
   */
  export type DevedorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devedors.
     */
    data: XOR<DevedorUpdateManyMutationInput, DevedorUncheckedUpdateManyInput>
    /**
     * Filter which Devedors to update
     */
    where?: DevedorWhereInput
    /**
     * Limit how many Devedors to update.
     */
    limit?: number
  }

  /**
   * Devedor upsert
   */
  export type DevedorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devedor
     */
    select?: DevedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devedor
     */
    omit?: DevedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevedorInclude<ExtArgs> | null
    /**
     * The filter to search for the Devedor to update in case it exists.
     */
    where: DevedorWhereUniqueInput
    /**
     * In case the Devedor found by the `where` argument doesn't exist, create a new Devedor with this data.
     */
    create: XOR<DevedorCreateInput, DevedorUncheckedCreateInput>
    /**
     * In case the Devedor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DevedorUpdateInput, DevedorUncheckedUpdateInput>
  }

  /**
   * Devedor delete
   */
  export type DevedorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devedor
     */
    select?: DevedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devedor
     */
    omit?: DevedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevedorInclude<ExtArgs> | null
    /**
     * Filter which Devedor to delete.
     */
    where: DevedorWhereUniqueInput
  }

  /**
   * Devedor deleteMany
   */
  export type DevedorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devedors to delete
     */
    where?: DevedorWhereInput
    /**
     * Limit how many Devedors to delete.
     */
    limit?: number
  }

  /**
   * Devedor.credito
   */
  export type Devedor$creditoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credito
     */
    select?: CreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credito
     */
    omit?: CreditoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoInclude<ExtArgs> | null
    where?: CreditoWhereInput
    orderBy?: CreditoOrderByWithRelationInput | CreditoOrderByWithRelationInput[]
    cursor?: CreditoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditoScalarFieldEnum | CreditoScalarFieldEnum[]
  }

  /**
   * Devedor.movel
   */
  export type Devedor$movelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movel
     */
    select?: MovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movel
     */
    omit?: MovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovelInclude<ExtArgs> | null
    where?: MovelWhereInput
    orderBy?: MovelOrderByWithRelationInput | MovelOrderByWithRelationInput[]
    cursor?: MovelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovelScalarFieldEnum | MovelScalarFieldEnum[]
  }

  /**
   * Devedor.pagamento
   */
  export type Devedor$pagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    where?: PagamentoWhereInput
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    cursor?: PagamentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Devedor without action
   */
  export type DevedorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devedor
     */
    select?: DevedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devedor
     */
    omit?: DevedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevedorInclude<ExtArgs> | null
  }


  /**
   * Model Investidor
   */

  export type AggregateInvestidor = {
    _count: InvestidorCountAggregateOutputType | null
    _avg: InvestidorAvgAggregateOutputType | null
    _sum: InvestidorSumAggregateOutputType | null
    _min: InvestidorMinAggregateOutputType | null
    _max: InvestidorMaxAggregateOutputType | null
  }

  export type InvestidorAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type InvestidorSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type InvestidorMinAggregateOutputType = {
    id: number | null
    maior_risco: boolean | null
    maior_seguranca: boolean | null
    saque_antecipado: boolean | null
    fundo_protegido: boolean | null
    estado: boolean | null
    partilhar_emprestimo: boolean | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestidorMaxAggregateOutputType = {
    id: number | null
    maior_risco: boolean | null
    maior_seguranca: boolean | null
    saque_antecipado: boolean | null
    fundo_protegido: boolean | null
    estado: boolean | null
    partilhar_emprestimo: boolean | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestidorCountAggregateOutputType = {
    id: number
    maior_risco: number
    maior_seguranca: number
    saque_antecipado: number
    fundo_protegido: number
    estado: number
    partilhar_emprestimo: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvestidorAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type InvestidorSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type InvestidorMinAggregateInputType = {
    id?: true
    maior_risco?: true
    maior_seguranca?: true
    saque_antecipado?: true
    fundo_protegido?: true
    estado?: true
    partilhar_emprestimo?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestidorMaxAggregateInputType = {
    id?: true
    maior_risco?: true
    maior_seguranca?: true
    saque_antecipado?: true
    fundo_protegido?: true
    estado?: true
    partilhar_emprestimo?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestidorCountAggregateInputType = {
    id?: true
    maior_risco?: true
    maior_seguranca?: true
    saque_antecipado?: true
    fundo_protegido?: true
    estado?: true
    partilhar_emprestimo?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvestidorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investidor to aggregate.
     */
    where?: InvestidorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investidors to fetch.
     */
    orderBy?: InvestidorOrderByWithRelationInput | InvestidorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestidorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investidors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investidors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Investidors
    **/
    _count?: true | InvestidorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvestidorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvestidorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestidorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestidorMaxAggregateInputType
  }

  export type GetInvestidorAggregateType<T extends InvestidorAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestidor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestidor[P]>
      : GetScalarType<T[P], AggregateInvestidor[P]>
  }




  export type InvestidorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestidorWhereInput
    orderBy?: InvestidorOrderByWithAggregationInput | InvestidorOrderByWithAggregationInput[]
    by: InvestidorScalarFieldEnum[] | InvestidorScalarFieldEnum
    having?: InvestidorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestidorCountAggregateInputType | true
    _avg?: InvestidorAvgAggregateInputType
    _sum?: InvestidorSumAggregateInputType
    _min?: InvestidorMinAggregateInputType
    _max?: InvestidorMaxAggregateInputType
  }

  export type InvestidorGroupByOutputType = {
    id: number
    maior_risco: boolean
    maior_seguranca: boolean
    saque_antecipado: boolean
    fundo_protegido: boolean
    estado: boolean
    partilhar_emprestimo: boolean
    user_id: number
    createdAt: Date
    updatedAt: Date
    _count: InvestidorCountAggregateOutputType | null
    _avg: InvestidorAvgAggregateOutputType | null
    _sum: InvestidorSumAggregateOutputType | null
    _min: InvestidorMinAggregateOutputType | null
    _max: InvestidorMaxAggregateOutputType | null
  }

  type GetInvestidorGroupByPayload<T extends InvestidorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestidorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestidorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestidorGroupByOutputType[P]>
            : GetScalarType<T[P], InvestidorGroupByOutputType[P]>
        }
      >
    >


  export type InvestidorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    maior_risco?: boolean
    maior_seguranca?: boolean
    saque_antecipado?: boolean
    fundo_protegido?: boolean
    estado?: boolean
    partilhar_emprestimo?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    diversificacao?: boolean | Investidor$diversificacaoArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | InvestidorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investidor"]>



  export type InvestidorSelectScalar = {
    id?: boolean
    maior_risco?: boolean
    maior_seguranca?: boolean
    saque_antecipado?: boolean
    fundo_protegido?: boolean
    estado?: boolean
    partilhar_emprestimo?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvestidorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "maior_risco" | "maior_seguranca" | "saque_antecipado" | "fundo_protegido" | "estado" | "partilhar_emprestimo" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["investidor"]>
  export type InvestidorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diversificacao?: boolean | Investidor$diversificacaoArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | InvestidorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InvestidorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Investidor"
    objects: {
      diversificacao: Prisma.$DiversificacaoPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      maior_risco: boolean
      maior_seguranca: boolean
      saque_antecipado: boolean
      fundo_protegido: boolean
      estado: boolean
      partilhar_emprestimo: boolean
      user_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["investidor"]>
    composites: {}
  }

  type InvestidorGetPayload<S extends boolean | null | undefined | InvestidorDefaultArgs> = $Result.GetResult<Prisma.$InvestidorPayload, S>

  type InvestidorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvestidorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvestidorCountAggregateInputType | true
    }

  export interface InvestidorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Investidor'], meta: { name: 'Investidor' } }
    /**
     * Find zero or one Investidor that matches the filter.
     * @param {InvestidorFindUniqueArgs} args - Arguments to find a Investidor
     * @example
     * // Get one Investidor
     * const investidor = await prisma.investidor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvestidorFindUniqueArgs>(args: SelectSubset<T, InvestidorFindUniqueArgs<ExtArgs>>): Prisma__InvestidorClient<$Result.GetResult<Prisma.$InvestidorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Investidor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvestidorFindUniqueOrThrowArgs} args - Arguments to find a Investidor
     * @example
     * // Get one Investidor
     * const investidor = await prisma.investidor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvestidorFindUniqueOrThrowArgs>(args: SelectSubset<T, InvestidorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvestidorClient<$Result.GetResult<Prisma.$InvestidorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Investidor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestidorFindFirstArgs} args - Arguments to find a Investidor
     * @example
     * // Get one Investidor
     * const investidor = await prisma.investidor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvestidorFindFirstArgs>(args?: SelectSubset<T, InvestidorFindFirstArgs<ExtArgs>>): Prisma__InvestidorClient<$Result.GetResult<Prisma.$InvestidorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Investidor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestidorFindFirstOrThrowArgs} args - Arguments to find a Investidor
     * @example
     * // Get one Investidor
     * const investidor = await prisma.investidor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvestidorFindFirstOrThrowArgs>(args?: SelectSubset<T, InvestidorFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvestidorClient<$Result.GetResult<Prisma.$InvestidorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Investidors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestidorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investidors
     * const investidors = await prisma.investidor.findMany()
     * 
     * // Get first 10 Investidors
     * const investidors = await prisma.investidor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investidorWithIdOnly = await prisma.investidor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvestidorFindManyArgs>(args?: SelectSubset<T, InvestidorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestidorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Investidor.
     * @param {InvestidorCreateArgs} args - Arguments to create a Investidor.
     * @example
     * // Create one Investidor
     * const Investidor = await prisma.investidor.create({
     *   data: {
     *     // ... data to create a Investidor
     *   }
     * })
     * 
     */
    create<T extends InvestidorCreateArgs>(args: SelectSubset<T, InvestidorCreateArgs<ExtArgs>>): Prisma__InvestidorClient<$Result.GetResult<Prisma.$InvestidorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Investidors.
     * @param {InvestidorCreateManyArgs} args - Arguments to create many Investidors.
     * @example
     * // Create many Investidors
     * const investidor = await prisma.investidor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvestidorCreateManyArgs>(args?: SelectSubset<T, InvestidorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Investidor.
     * @param {InvestidorDeleteArgs} args - Arguments to delete one Investidor.
     * @example
     * // Delete one Investidor
     * const Investidor = await prisma.investidor.delete({
     *   where: {
     *     // ... filter to delete one Investidor
     *   }
     * })
     * 
     */
    delete<T extends InvestidorDeleteArgs>(args: SelectSubset<T, InvestidorDeleteArgs<ExtArgs>>): Prisma__InvestidorClient<$Result.GetResult<Prisma.$InvestidorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Investidor.
     * @param {InvestidorUpdateArgs} args - Arguments to update one Investidor.
     * @example
     * // Update one Investidor
     * const investidor = await prisma.investidor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvestidorUpdateArgs>(args: SelectSubset<T, InvestidorUpdateArgs<ExtArgs>>): Prisma__InvestidorClient<$Result.GetResult<Prisma.$InvestidorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Investidors.
     * @param {InvestidorDeleteManyArgs} args - Arguments to filter Investidors to delete.
     * @example
     * // Delete a few Investidors
     * const { count } = await prisma.investidor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvestidorDeleteManyArgs>(args?: SelectSubset<T, InvestidorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investidors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestidorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investidors
     * const investidor = await prisma.investidor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvestidorUpdateManyArgs>(args: SelectSubset<T, InvestidorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Investidor.
     * @param {InvestidorUpsertArgs} args - Arguments to update or create a Investidor.
     * @example
     * // Update or create a Investidor
     * const investidor = await prisma.investidor.upsert({
     *   create: {
     *     // ... data to create a Investidor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investidor we want to update
     *   }
     * })
     */
    upsert<T extends InvestidorUpsertArgs>(args: SelectSubset<T, InvestidorUpsertArgs<ExtArgs>>): Prisma__InvestidorClient<$Result.GetResult<Prisma.$InvestidorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Investidors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestidorCountArgs} args - Arguments to filter Investidors to count.
     * @example
     * // Count the number of Investidors
     * const count = await prisma.investidor.count({
     *   where: {
     *     // ... the filter for the Investidors we want to count
     *   }
     * })
    **/
    count<T extends InvestidorCountArgs>(
      args?: Subset<T, InvestidorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestidorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investidor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestidorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestidorAggregateArgs>(args: Subset<T, InvestidorAggregateArgs>): Prisma.PrismaPromise<GetInvestidorAggregateType<T>>

    /**
     * Group by Investidor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestidorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestidorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestidorGroupByArgs['orderBy'] }
        : { orderBy?: InvestidorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestidorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestidorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Investidor model
   */
  readonly fields: InvestidorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Investidor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestidorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    diversificacao<T extends Investidor$diversificacaoArgs<ExtArgs> = {}>(args?: Subset<T, Investidor$diversificacaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiversificacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Investidor model
   */
  interface InvestidorFieldRefs {
    readonly id: FieldRef<"Investidor", 'Int'>
    readonly maior_risco: FieldRef<"Investidor", 'Boolean'>
    readonly maior_seguranca: FieldRef<"Investidor", 'Boolean'>
    readonly saque_antecipado: FieldRef<"Investidor", 'Boolean'>
    readonly fundo_protegido: FieldRef<"Investidor", 'Boolean'>
    readonly estado: FieldRef<"Investidor", 'Boolean'>
    readonly partilhar_emprestimo: FieldRef<"Investidor", 'Boolean'>
    readonly user_id: FieldRef<"Investidor", 'Int'>
    readonly createdAt: FieldRef<"Investidor", 'DateTime'>
    readonly updatedAt: FieldRef<"Investidor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Investidor findUnique
   */
  export type InvestidorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investidor
     */
    select?: InvestidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investidor
     */
    omit?: InvestidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestidorInclude<ExtArgs> | null
    /**
     * Filter, which Investidor to fetch.
     */
    where: InvestidorWhereUniqueInput
  }

  /**
   * Investidor findUniqueOrThrow
   */
  export type InvestidorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investidor
     */
    select?: InvestidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investidor
     */
    omit?: InvestidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestidorInclude<ExtArgs> | null
    /**
     * Filter, which Investidor to fetch.
     */
    where: InvestidorWhereUniqueInput
  }

  /**
   * Investidor findFirst
   */
  export type InvestidorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investidor
     */
    select?: InvestidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investidor
     */
    omit?: InvestidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestidorInclude<ExtArgs> | null
    /**
     * Filter, which Investidor to fetch.
     */
    where?: InvestidorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investidors to fetch.
     */
    orderBy?: InvestidorOrderByWithRelationInput | InvestidorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investidors.
     */
    cursor?: InvestidorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investidors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investidors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investidors.
     */
    distinct?: InvestidorScalarFieldEnum | InvestidorScalarFieldEnum[]
  }

  /**
   * Investidor findFirstOrThrow
   */
  export type InvestidorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investidor
     */
    select?: InvestidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investidor
     */
    omit?: InvestidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestidorInclude<ExtArgs> | null
    /**
     * Filter, which Investidor to fetch.
     */
    where?: InvestidorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investidors to fetch.
     */
    orderBy?: InvestidorOrderByWithRelationInput | InvestidorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investidors.
     */
    cursor?: InvestidorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investidors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investidors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investidors.
     */
    distinct?: InvestidorScalarFieldEnum | InvestidorScalarFieldEnum[]
  }

  /**
   * Investidor findMany
   */
  export type InvestidorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investidor
     */
    select?: InvestidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investidor
     */
    omit?: InvestidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestidorInclude<ExtArgs> | null
    /**
     * Filter, which Investidors to fetch.
     */
    where?: InvestidorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investidors to fetch.
     */
    orderBy?: InvestidorOrderByWithRelationInput | InvestidorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Investidors.
     */
    cursor?: InvestidorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investidors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investidors.
     */
    skip?: number
    distinct?: InvestidorScalarFieldEnum | InvestidorScalarFieldEnum[]
  }

  /**
   * Investidor create
   */
  export type InvestidorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investidor
     */
    select?: InvestidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investidor
     */
    omit?: InvestidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestidorInclude<ExtArgs> | null
    /**
     * The data needed to create a Investidor.
     */
    data: XOR<InvestidorCreateInput, InvestidorUncheckedCreateInput>
  }

  /**
   * Investidor createMany
   */
  export type InvestidorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Investidors.
     */
    data: InvestidorCreateManyInput | InvestidorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Investidor update
   */
  export type InvestidorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investidor
     */
    select?: InvestidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investidor
     */
    omit?: InvestidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestidorInclude<ExtArgs> | null
    /**
     * The data needed to update a Investidor.
     */
    data: XOR<InvestidorUpdateInput, InvestidorUncheckedUpdateInput>
    /**
     * Choose, which Investidor to update.
     */
    where: InvestidorWhereUniqueInput
  }

  /**
   * Investidor updateMany
   */
  export type InvestidorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Investidors.
     */
    data: XOR<InvestidorUpdateManyMutationInput, InvestidorUncheckedUpdateManyInput>
    /**
     * Filter which Investidors to update
     */
    where?: InvestidorWhereInput
    /**
     * Limit how many Investidors to update.
     */
    limit?: number
  }

  /**
   * Investidor upsert
   */
  export type InvestidorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investidor
     */
    select?: InvestidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investidor
     */
    omit?: InvestidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestidorInclude<ExtArgs> | null
    /**
     * The filter to search for the Investidor to update in case it exists.
     */
    where: InvestidorWhereUniqueInput
    /**
     * In case the Investidor found by the `where` argument doesn't exist, create a new Investidor with this data.
     */
    create: XOR<InvestidorCreateInput, InvestidorUncheckedCreateInput>
    /**
     * In case the Investidor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestidorUpdateInput, InvestidorUncheckedUpdateInput>
  }

  /**
   * Investidor delete
   */
  export type InvestidorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investidor
     */
    select?: InvestidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investidor
     */
    omit?: InvestidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestidorInclude<ExtArgs> | null
    /**
     * Filter which Investidor to delete.
     */
    where: InvestidorWhereUniqueInput
  }

  /**
   * Investidor deleteMany
   */
  export type InvestidorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investidors to delete
     */
    where?: InvestidorWhereInput
    /**
     * Limit how many Investidors to delete.
     */
    limit?: number
  }

  /**
   * Investidor.diversificacao
   */
  export type Investidor$diversificacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversificacao
     */
    select?: DiversificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diversificacao
     */
    omit?: DiversificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversificacaoInclude<ExtArgs> | null
    where?: DiversificacaoWhereInput
    orderBy?: DiversificacaoOrderByWithRelationInput | DiversificacaoOrderByWithRelationInput[]
    cursor?: DiversificacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiversificacaoScalarFieldEnum | DiversificacaoScalarFieldEnum[]
  }

  /**
   * Investidor without action
   */
  export type InvestidorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investidor
     */
    select?: InvestidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investidor
     */
    omit?: InvestidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestidorInclude<ExtArgs> | null
  }


  /**
   * Model Reclamacao
   */

  export type AggregateReclamacao = {
    _count: ReclamacaoCountAggregateOutputType | null
    _avg: ReclamacaoAvgAggregateOutputType | null
    _sum: ReclamacaoSumAggregateOutputType | null
    _min: ReclamacaoMinAggregateOutputType | null
    _max: ReclamacaoMaxAggregateOutputType | null
  }

  export type ReclamacaoAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ReclamacaoSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ReclamacaoMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    estado: boolean | null
    assunto: string | null
    conteudo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReclamacaoMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    estado: boolean | null
    assunto: string | null
    conteudo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReclamacaoCountAggregateOutputType = {
    id: number
    user_id: number
    estado: number
    assunto: number
    conteudo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReclamacaoAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ReclamacaoSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ReclamacaoMinAggregateInputType = {
    id?: true
    user_id?: true
    estado?: true
    assunto?: true
    conteudo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReclamacaoMaxAggregateInputType = {
    id?: true
    user_id?: true
    estado?: true
    assunto?: true
    conteudo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReclamacaoCountAggregateInputType = {
    id?: true
    user_id?: true
    estado?: true
    assunto?: true
    conteudo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReclamacaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reclamacao to aggregate.
     */
    where?: ReclamacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reclamacaos to fetch.
     */
    orderBy?: ReclamacaoOrderByWithRelationInput | ReclamacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReclamacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reclamacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reclamacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reclamacaos
    **/
    _count?: true | ReclamacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReclamacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReclamacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReclamacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReclamacaoMaxAggregateInputType
  }

  export type GetReclamacaoAggregateType<T extends ReclamacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateReclamacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReclamacao[P]>
      : GetScalarType<T[P], AggregateReclamacao[P]>
  }




  export type ReclamacaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReclamacaoWhereInput
    orderBy?: ReclamacaoOrderByWithAggregationInput | ReclamacaoOrderByWithAggregationInput[]
    by: ReclamacaoScalarFieldEnum[] | ReclamacaoScalarFieldEnum
    having?: ReclamacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReclamacaoCountAggregateInputType | true
    _avg?: ReclamacaoAvgAggregateInputType
    _sum?: ReclamacaoSumAggregateInputType
    _min?: ReclamacaoMinAggregateInputType
    _max?: ReclamacaoMaxAggregateInputType
  }

  export type ReclamacaoGroupByOutputType = {
    id: number
    user_id: number
    estado: boolean
    assunto: string
    conteudo: string
    createdAt: Date
    updatedAt: Date
    _count: ReclamacaoCountAggregateOutputType | null
    _avg: ReclamacaoAvgAggregateOutputType | null
    _sum: ReclamacaoSumAggregateOutputType | null
    _min: ReclamacaoMinAggregateOutputType | null
    _max: ReclamacaoMaxAggregateOutputType | null
  }

  type GetReclamacaoGroupByPayload<T extends ReclamacaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReclamacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReclamacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReclamacaoGroupByOutputType[P]>
            : GetScalarType<T[P], ReclamacaoGroupByOutputType[P]>
        }
      >
    >


  export type ReclamacaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    estado?: boolean
    assunto?: boolean
    conteudo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reclamacao"]>



  export type ReclamacaoSelectScalar = {
    id?: boolean
    user_id?: boolean
    estado?: boolean
    assunto?: boolean
    conteudo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReclamacaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "estado" | "assunto" | "conteudo" | "createdAt" | "updatedAt", ExtArgs["result"]["reclamacao"]>
  export type ReclamacaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReclamacaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reclamacao"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      estado: boolean
      assunto: string
      conteudo: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reclamacao"]>
    composites: {}
  }

  type ReclamacaoGetPayload<S extends boolean | null | undefined | ReclamacaoDefaultArgs> = $Result.GetResult<Prisma.$ReclamacaoPayload, S>

  type ReclamacaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReclamacaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReclamacaoCountAggregateInputType | true
    }

  export interface ReclamacaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reclamacao'], meta: { name: 'Reclamacao' } }
    /**
     * Find zero or one Reclamacao that matches the filter.
     * @param {ReclamacaoFindUniqueArgs} args - Arguments to find a Reclamacao
     * @example
     * // Get one Reclamacao
     * const reclamacao = await prisma.reclamacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReclamacaoFindUniqueArgs>(args: SelectSubset<T, ReclamacaoFindUniqueArgs<ExtArgs>>): Prisma__ReclamacaoClient<$Result.GetResult<Prisma.$ReclamacaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reclamacao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReclamacaoFindUniqueOrThrowArgs} args - Arguments to find a Reclamacao
     * @example
     * // Get one Reclamacao
     * const reclamacao = await prisma.reclamacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReclamacaoFindUniqueOrThrowArgs>(args: SelectSubset<T, ReclamacaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReclamacaoClient<$Result.GetResult<Prisma.$ReclamacaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reclamacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReclamacaoFindFirstArgs} args - Arguments to find a Reclamacao
     * @example
     * // Get one Reclamacao
     * const reclamacao = await prisma.reclamacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReclamacaoFindFirstArgs>(args?: SelectSubset<T, ReclamacaoFindFirstArgs<ExtArgs>>): Prisma__ReclamacaoClient<$Result.GetResult<Prisma.$ReclamacaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reclamacao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReclamacaoFindFirstOrThrowArgs} args - Arguments to find a Reclamacao
     * @example
     * // Get one Reclamacao
     * const reclamacao = await prisma.reclamacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReclamacaoFindFirstOrThrowArgs>(args?: SelectSubset<T, ReclamacaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReclamacaoClient<$Result.GetResult<Prisma.$ReclamacaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reclamacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReclamacaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reclamacaos
     * const reclamacaos = await prisma.reclamacao.findMany()
     * 
     * // Get first 10 Reclamacaos
     * const reclamacaos = await prisma.reclamacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reclamacaoWithIdOnly = await prisma.reclamacao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReclamacaoFindManyArgs>(args?: SelectSubset<T, ReclamacaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReclamacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reclamacao.
     * @param {ReclamacaoCreateArgs} args - Arguments to create a Reclamacao.
     * @example
     * // Create one Reclamacao
     * const Reclamacao = await prisma.reclamacao.create({
     *   data: {
     *     // ... data to create a Reclamacao
     *   }
     * })
     * 
     */
    create<T extends ReclamacaoCreateArgs>(args: SelectSubset<T, ReclamacaoCreateArgs<ExtArgs>>): Prisma__ReclamacaoClient<$Result.GetResult<Prisma.$ReclamacaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reclamacaos.
     * @param {ReclamacaoCreateManyArgs} args - Arguments to create many Reclamacaos.
     * @example
     * // Create many Reclamacaos
     * const reclamacao = await prisma.reclamacao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReclamacaoCreateManyArgs>(args?: SelectSubset<T, ReclamacaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reclamacao.
     * @param {ReclamacaoDeleteArgs} args - Arguments to delete one Reclamacao.
     * @example
     * // Delete one Reclamacao
     * const Reclamacao = await prisma.reclamacao.delete({
     *   where: {
     *     // ... filter to delete one Reclamacao
     *   }
     * })
     * 
     */
    delete<T extends ReclamacaoDeleteArgs>(args: SelectSubset<T, ReclamacaoDeleteArgs<ExtArgs>>): Prisma__ReclamacaoClient<$Result.GetResult<Prisma.$ReclamacaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reclamacao.
     * @param {ReclamacaoUpdateArgs} args - Arguments to update one Reclamacao.
     * @example
     * // Update one Reclamacao
     * const reclamacao = await prisma.reclamacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReclamacaoUpdateArgs>(args: SelectSubset<T, ReclamacaoUpdateArgs<ExtArgs>>): Prisma__ReclamacaoClient<$Result.GetResult<Prisma.$ReclamacaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reclamacaos.
     * @param {ReclamacaoDeleteManyArgs} args - Arguments to filter Reclamacaos to delete.
     * @example
     * // Delete a few Reclamacaos
     * const { count } = await prisma.reclamacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReclamacaoDeleteManyArgs>(args?: SelectSubset<T, ReclamacaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reclamacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReclamacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reclamacaos
     * const reclamacao = await prisma.reclamacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReclamacaoUpdateManyArgs>(args: SelectSubset<T, ReclamacaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reclamacao.
     * @param {ReclamacaoUpsertArgs} args - Arguments to update or create a Reclamacao.
     * @example
     * // Update or create a Reclamacao
     * const reclamacao = await prisma.reclamacao.upsert({
     *   create: {
     *     // ... data to create a Reclamacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reclamacao we want to update
     *   }
     * })
     */
    upsert<T extends ReclamacaoUpsertArgs>(args: SelectSubset<T, ReclamacaoUpsertArgs<ExtArgs>>): Prisma__ReclamacaoClient<$Result.GetResult<Prisma.$ReclamacaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reclamacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReclamacaoCountArgs} args - Arguments to filter Reclamacaos to count.
     * @example
     * // Count the number of Reclamacaos
     * const count = await prisma.reclamacao.count({
     *   where: {
     *     // ... the filter for the Reclamacaos we want to count
     *   }
     * })
    **/
    count<T extends ReclamacaoCountArgs>(
      args?: Subset<T, ReclamacaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReclamacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reclamacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReclamacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReclamacaoAggregateArgs>(args: Subset<T, ReclamacaoAggregateArgs>): Prisma.PrismaPromise<GetReclamacaoAggregateType<T>>

    /**
     * Group by Reclamacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReclamacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReclamacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReclamacaoGroupByArgs['orderBy'] }
        : { orderBy?: ReclamacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReclamacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReclamacaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reclamacao model
   */
  readonly fields: ReclamacaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reclamacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReclamacaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reclamacao model
   */
  interface ReclamacaoFieldRefs {
    readonly id: FieldRef<"Reclamacao", 'Int'>
    readonly user_id: FieldRef<"Reclamacao", 'Int'>
    readonly estado: FieldRef<"Reclamacao", 'Boolean'>
    readonly assunto: FieldRef<"Reclamacao", 'String'>
    readonly conteudo: FieldRef<"Reclamacao", 'String'>
    readonly createdAt: FieldRef<"Reclamacao", 'DateTime'>
    readonly updatedAt: FieldRef<"Reclamacao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reclamacao findUnique
   */
  export type ReclamacaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reclamacao
     */
    select?: ReclamacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reclamacao
     */
    omit?: ReclamacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReclamacaoInclude<ExtArgs> | null
    /**
     * Filter, which Reclamacao to fetch.
     */
    where: ReclamacaoWhereUniqueInput
  }

  /**
   * Reclamacao findUniqueOrThrow
   */
  export type ReclamacaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reclamacao
     */
    select?: ReclamacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reclamacao
     */
    omit?: ReclamacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReclamacaoInclude<ExtArgs> | null
    /**
     * Filter, which Reclamacao to fetch.
     */
    where: ReclamacaoWhereUniqueInput
  }

  /**
   * Reclamacao findFirst
   */
  export type ReclamacaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reclamacao
     */
    select?: ReclamacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reclamacao
     */
    omit?: ReclamacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReclamacaoInclude<ExtArgs> | null
    /**
     * Filter, which Reclamacao to fetch.
     */
    where?: ReclamacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reclamacaos to fetch.
     */
    orderBy?: ReclamacaoOrderByWithRelationInput | ReclamacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reclamacaos.
     */
    cursor?: ReclamacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reclamacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reclamacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reclamacaos.
     */
    distinct?: ReclamacaoScalarFieldEnum | ReclamacaoScalarFieldEnum[]
  }

  /**
   * Reclamacao findFirstOrThrow
   */
  export type ReclamacaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reclamacao
     */
    select?: ReclamacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reclamacao
     */
    omit?: ReclamacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReclamacaoInclude<ExtArgs> | null
    /**
     * Filter, which Reclamacao to fetch.
     */
    where?: ReclamacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reclamacaos to fetch.
     */
    orderBy?: ReclamacaoOrderByWithRelationInput | ReclamacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reclamacaos.
     */
    cursor?: ReclamacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reclamacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reclamacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reclamacaos.
     */
    distinct?: ReclamacaoScalarFieldEnum | ReclamacaoScalarFieldEnum[]
  }

  /**
   * Reclamacao findMany
   */
  export type ReclamacaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reclamacao
     */
    select?: ReclamacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reclamacao
     */
    omit?: ReclamacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReclamacaoInclude<ExtArgs> | null
    /**
     * Filter, which Reclamacaos to fetch.
     */
    where?: ReclamacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reclamacaos to fetch.
     */
    orderBy?: ReclamacaoOrderByWithRelationInput | ReclamacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reclamacaos.
     */
    cursor?: ReclamacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reclamacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reclamacaos.
     */
    skip?: number
    distinct?: ReclamacaoScalarFieldEnum | ReclamacaoScalarFieldEnum[]
  }

  /**
   * Reclamacao create
   */
  export type ReclamacaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reclamacao
     */
    select?: ReclamacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reclamacao
     */
    omit?: ReclamacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReclamacaoInclude<ExtArgs> | null
    /**
     * The data needed to create a Reclamacao.
     */
    data: XOR<ReclamacaoCreateInput, ReclamacaoUncheckedCreateInput>
  }

  /**
   * Reclamacao createMany
   */
  export type ReclamacaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reclamacaos.
     */
    data: ReclamacaoCreateManyInput | ReclamacaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reclamacao update
   */
  export type ReclamacaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reclamacao
     */
    select?: ReclamacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reclamacao
     */
    omit?: ReclamacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReclamacaoInclude<ExtArgs> | null
    /**
     * The data needed to update a Reclamacao.
     */
    data: XOR<ReclamacaoUpdateInput, ReclamacaoUncheckedUpdateInput>
    /**
     * Choose, which Reclamacao to update.
     */
    where: ReclamacaoWhereUniqueInput
  }

  /**
   * Reclamacao updateMany
   */
  export type ReclamacaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reclamacaos.
     */
    data: XOR<ReclamacaoUpdateManyMutationInput, ReclamacaoUncheckedUpdateManyInput>
    /**
     * Filter which Reclamacaos to update
     */
    where?: ReclamacaoWhereInput
    /**
     * Limit how many Reclamacaos to update.
     */
    limit?: number
  }

  /**
   * Reclamacao upsert
   */
  export type ReclamacaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reclamacao
     */
    select?: ReclamacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reclamacao
     */
    omit?: ReclamacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReclamacaoInclude<ExtArgs> | null
    /**
     * The filter to search for the Reclamacao to update in case it exists.
     */
    where: ReclamacaoWhereUniqueInput
    /**
     * In case the Reclamacao found by the `where` argument doesn't exist, create a new Reclamacao with this data.
     */
    create: XOR<ReclamacaoCreateInput, ReclamacaoUncheckedCreateInput>
    /**
     * In case the Reclamacao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReclamacaoUpdateInput, ReclamacaoUncheckedUpdateInput>
  }

  /**
   * Reclamacao delete
   */
  export type ReclamacaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reclamacao
     */
    select?: ReclamacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reclamacao
     */
    omit?: ReclamacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReclamacaoInclude<ExtArgs> | null
    /**
     * Filter which Reclamacao to delete.
     */
    where: ReclamacaoWhereUniqueInput
  }

  /**
   * Reclamacao deleteMany
   */
  export type ReclamacaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reclamacaos to delete
     */
    where?: ReclamacaoWhereInput
    /**
     * Limit how many Reclamacaos to delete.
     */
    limit?: number
  }

  /**
   * Reclamacao without action
   */
  export type ReclamacaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reclamacao
     */
    select?: ReclamacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reclamacao
     */
    omit?: ReclamacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReclamacaoInclude<ExtArgs> | null
  }


  /**
   * Model Proponente
   */

  export type AggregateProponente = {
    _count: ProponenteCountAggregateOutputType | null
    _avg: ProponenteAvgAggregateOutputType | null
    _sum: ProponenteSumAggregateOutputType | null
    _min: ProponenteMinAggregateOutputType | null
    _max: ProponenteMaxAggregateOutputType | null
  }

  export type ProponenteAvgAggregateOutputType = {
    id: number | null
    solicitacao: number | null
    reembolsar: number | null
    satisfeitos: number | null
    insatisfeitos: number | null
    user_id: number | null
  }

  export type ProponenteSumAggregateOutputType = {
    id: number | null
    solicitacao: number | null
    reembolsar: number | null
    satisfeitos: number | null
    insatisfeitos: number | null
    user_id: number | null
  }

  export type ProponenteMinAggregateOutputType = {
    id: number | null
    solicitacao: number | null
    reembolsar: number | null
    satisfeitos: number | null
    insatisfeitos: number | null
    estado: boolean | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProponenteMaxAggregateOutputType = {
    id: number | null
    solicitacao: number | null
    reembolsar: number | null
    satisfeitos: number | null
    insatisfeitos: number | null
    estado: boolean | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProponenteCountAggregateOutputType = {
    id: number
    solicitacao: number
    reembolsar: number
    satisfeitos: number
    insatisfeitos: number
    estado: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProponenteAvgAggregateInputType = {
    id?: true
    solicitacao?: true
    reembolsar?: true
    satisfeitos?: true
    insatisfeitos?: true
    user_id?: true
  }

  export type ProponenteSumAggregateInputType = {
    id?: true
    solicitacao?: true
    reembolsar?: true
    satisfeitos?: true
    insatisfeitos?: true
    user_id?: true
  }

  export type ProponenteMinAggregateInputType = {
    id?: true
    solicitacao?: true
    reembolsar?: true
    satisfeitos?: true
    insatisfeitos?: true
    estado?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProponenteMaxAggregateInputType = {
    id?: true
    solicitacao?: true
    reembolsar?: true
    satisfeitos?: true
    insatisfeitos?: true
    estado?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProponenteCountAggregateInputType = {
    id?: true
    solicitacao?: true
    reembolsar?: true
    satisfeitos?: true
    insatisfeitos?: true
    estado?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProponenteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proponente to aggregate.
     */
    where?: ProponenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proponentes to fetch.
     */
    orderBy?: ProponenteOrderByWithRelationInput | ProponenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProponenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proponentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proponentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proponentes
    **/
    _count?: true | ProponenteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProponenteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProponenteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProponenteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProponenteMaxAggregateInputType
  }

  export type GetProponenteAggregateType<T extends ProponenteAggregateArgs> = {
        [P in keyof T & keyof AggregateProponente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProponente[P]>
      : GetScalarType<T[P], AggregateProponente[P]>
  }




  export type ProponenteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProponenteWhereInput
    orderBy?: ProponenteOrderByWithAggregationInput | ProponenteOrderByWithAggregationInput[]
    by: ProponenteScalarFieldEnum[] | ProponenteScalarFieldEnum
    having?: ProponenteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProponenteCountAggregateInputType | true
    _avg?: ProponenteAvgAggregateInputType
    _sum?: ProponenteSumAggregateInputType
    _min?: ProponenteMinAggregateInputType
    _max?: ProponenteMaxAggregateInputType
  }

  export type ProponenteGroupByOutputType = {
    id: number
    solicitacao: number
    reembolsar: number
    satisfeitos: number
    insatisfeitos: number
    estado: boolean
    user_id: number
    createdAt: Date
    updatedAt: Date
    _count: ProponenteCountAggregateOutputType | null
    _avg: ProponenteAvgAggregateOutputType | null
    _sum: ProponenteSumAggregateOutputType | null
    _min: ProponenteMinAggregateOutputType | null
    _max: ProponenteMaxAggregateOutputType | null
  }

  type GetProponenteGroupByPayload<T extends ProponenteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProponenteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProponenteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProponenteGroupByOutputType[P]>
            : GetScalarType<T[P], ProponenteGroupByOutputType[P]>
        }
      >
    >


  export type ProponenteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    solicitacao?: boolean
    reembolsar?: boolean
    satisfeitos?: boolean
    insatisfeitos?: boolean
    estado?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emprestimo?: boolean | Proponente$emprestimoArgs<ExtArgs>
    reembolso?: boolean | Proponente$reembolsoArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ProponenteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proponente"]>



  export type ProponenteSelectScalar = {
    id?: boolean
    solicitacao?: boolean
    reembolsar?: boolean
    satisfeitos?: boolean
    insatisfeitos?: boolean
    estado?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProponenteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "solicitacao" | "reembolsar" | "satisfeitos" | "insatisfeitos" | "estado" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["proponente"]>
  export type ProponenteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprestimo?: boolean | Proponente$emprestimoArgs<ExtArgs>
    reembolso?: boolean | Proponente$reembolsoArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ProponenteCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProponentePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proponente"
    objects: {
      emprestimo: Prisma.$EmprestimoPayload<ExtArgs>[]
      reembolso: Prisma.$ReembolsoPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      solicitacao: number
      reembolsar: number
      satisfeitos: number
      insatisfeitos: number
      estado: boolean
      user_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["proponente"]>
    composites: {}
  }

  type ProponenteGetPayload<S extends boolean | null | undefined | ProponenteDefaultArgs> = $Result.GetResult<Prisma.$ProponentePayload, S>

  type ProponenteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProponenteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProponenteCountAggregateInputType | true
    }

  export interface ProponenteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proponente'], meta: { name: 'Proponente' } }
    /**
     * Find zero or one Proponente that matches the filter.
     * @param {ProponenteFindUniqueArgs} args - Arguments to find a Proponente
     * @example
     * // Get one Proponente
     * const proponente = await prisma.proponente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProponenteFindUniqueArgs>(args: SelectSubset<T, ProponenteFindUniqueArgs<ExtArgs>>): Prisma__ProponenteClient<$Result.GetResult<Prisma.$ProponentePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Proponente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProponenteFindUniqueOrThrowArgs} args - Arguments to find a Proponente
     * @example
     * // Get one Proponente
     * const proponente = await prisma.proponente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProponenteFindUniqueOrThrowArgs>(args: SelectSubset<T, ProponenteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProponenteClient<$Result.GetResult<Prisma.$ProponentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proponente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProponenteFindFirstArgs} args - Arguments to find a Proponente
     * @example
     * // Get one Proponente
     * const proponente = await prisma.proponente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProponenteFindFirstArgs>(args?: SelectSubset<T, ProponenteFindFirstArgs<ExtArgs>>): Prisma__ProponenteClient<$Result.GetResult<Prisma.$ProponentePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proponente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProponenteFindFirstOrThrowArgs} args - Arguments to find a Proponente
     * @example
     * // Get one Proponente
     * const proponente = await prisma.proponente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProponenteFindFirstOrThrowArgs>(args?: SelectSubset<T, ProponenteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProponenteClient<$Result.GetResult<Prisma.$ProponentePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Proponentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProponenteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proponentes
     * const proponentes = await prisma.proponente.findMany()
     * 
     * // Get first 10 Proponentes
     * const proponentes = await prisma.proponente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proponenteWithIdOnly = await prisma.proponente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProponenteFindManyArgs>(args?: SelectSubset<T, ProponenteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProponentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Proponente.
     * @param {ProponenteCreateArgs} args - Arguments to create a Proponente.
     * @example
     * // Create one Proponente
     * const Proponente = await prisma.proponente.create({
     *   data: {
     *     // ... data to create a Proponente
     *   }
     * })
     * 
     */
    create<T extends ProponenteCreateArgs>(args: SelectSubset<T, ProponenteCreateArgs<ExtArgs>>): Prisma__ProponenteClient<$Result.GetResult<Prisma.$ProponentePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Proponentes.
     * @param {ProponenteCreateManyArgs} args - Arguments to create many Proponentes.
     * @example
     * // Create many Proponentes
     * const proponente = await prisma.proponente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProponenteCreateManyArgs>(args?: SelectSubset<T, ProponenteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Proponente.
     * @param {ProponenteDeleteArgs} args - Arguments to delete one Proponente.
     * @example
     * // Delete one Proponente
     * const Proponente = await prisma.proponente.delete({
     *   where: {
     *     // ... filter to delete one Proponente
     *   }
     * })
     * 
     */
    delete<T extends ProponenteDeleteArgs>(args: SelectSubset<T, ProponenteDeleteArgs<ExtArgs>>): Prisma__ProponenteClient<$Result.GetResult<Prisma.$ProponentePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Proponente.
     * @param {ProponenteUpdateArgs} args - Arguments to update one Proponente.
     * @example
     * // Update one Proponente
     * const proponente = await prisma.proponente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProponenteUpdateArgs>(args: SelectSubset<T, ProponenteUpdateArgs<ExtArgs>>): Prisma__ProponenteClient<$Result.GetResult<Prisma.$ProponentePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Proponentes.
     * @param {ProponenteDeleteManyArgs} args - Arguments to filter Proponentes to delete.
     * @example
     * // Delete a few Proponentes
     * const { count } = await prisma.proponente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProponenteDeleteManyArgs>(args?: SelectSubset<T, ProponenteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proponentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProponenteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proponentes
     * const proponente = await prisma.proponente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProponenteUpdateManyArgs>(args: SelectSubset<T, ProponenteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proponente.
     * @param {ProponenteUpsertArgs} args - Arguments to update or create a Proponente.
     * @example
     * // Update or create a Proponente
     * const proponente = await prisma.proponente.upsert({
     *   create: {
     *     // ... data to create a Proponente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proponente we want to update
     *   }
     * })
     */
    upsert<T extends ProponenteUpsertArgs>(args: SelectSubset<T, ProponenteUpsertArgs<ExtArgs>>): Prisma__ProponenteClient<$Result.GetResult<Prisma.$ProponentePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Proponentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProponenteCountArgs} args - Arguments to filter Proponentes to count.
     * @example
     * // Count the number of Proponentes
     * const count = await prisma.proponente.count({
     *   where: {
     *     // ... the filter for the Proponentes we want to count
     *   }
     * })
    **/
    count<T extends ProponenteCountArgs>(
      args?: Subset<T, ProponenteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProponenteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proponente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProponenteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProponenteAggregateArgs>(args: Subset<T, ProponenteAggregateArgs>): Prisma.PrismaPromise<GetProponenteAggregateType<T>>

    /**
     * Group by Proponente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProponenteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProponenteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProponenteGroupByArgs['orderBy'] }
        : { orderBy?: ProponenteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProponenteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProponenteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proponente model
   */
  readonly fields: ProponenteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proponente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProponenteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emprestimo<T extends Proponente$emprestimoArgs<ExtArgs> = {}>(args?: Subset<T, Proponente$emprestimoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmprestimoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reembolso<T extends Proponente$reembolsoArgs<ExtArgs> = {}>(args?: Subset<T, Proponente$reembolsoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReembolsoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proponente model
   */
  interface ProponenteFieldRefs {
    readonly id: FieldRef<"Proponente", 'Int'>
    readonly solicitacao: FieldRef<"Proponente", 'Int'>
    readonly reembolsar: FieldRef<"Proponente", 'Int'>
    readonly satisfeitos: FieldRef<"Proponente", 'Int'>
    readonly insatisfeitos: FieldRef<"Proponente", 'Int'>
    readonly estado: FieldRef<"Proponente", 'Boolean'>
    readonly user_id: FieldRef<"Proponente", 'Int'>
    readonly createdAt: FieldRef<"Proponente", 'DateTime'>
    readonly updatedAt: FieldRef<"Proponente", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Proponente findUnique
   */
  export type ProponenteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proponente
     */
    select?: ProponenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proponente
     */
    omit?: ProponenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProponenteInclude<ExtArgs> | null
    /**
     * Filter, which Proponente to fetch.
     */
    where: ProponenteWhereUniqueInput
  }

  /**
   * Proponente findUniqueOrThrow
   */
  export type ProponenteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proponente
     */
    select?: ProponenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proponente
     */
    omit?: ProponenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProponenteInclude<ExtArgs> | null
    /**
     * Filter, which Proponente to fetch.
     */
    where: ProponenteWhereUniqueInput
  }

  /**
   * Proponente findFirst
   */
  export type ProponenteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proponente
     */
    select?: ProponenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proponente
     */
    omit?: ProponenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProponenteInclude<ExtArgs> | null
    /**
     * Filter, which Proponente to fetch.
     */
    where?: ProponenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proponentes to fetch.
     */
    orderBy?: ProponenteOrderByWithRelationInput | ProponenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proponentes.
     */
    cursor?: ProponenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proponentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proponentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proponentes.
     */
    distinct?: ProponenteScalarFieldEnum | ProponenteScalarFieldEnum[]
  }

  /**
   * Proponente findFirstOrThrow
   */
  export type ProponenteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proponente
     */
    select?: ProponenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proponente
     */
    omit?: ProponenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProponenteInclude<ExtArgs> | null
    /**
     * Filter, which Proponente to fetch.
     */
    where?: ProponenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proponentes to fetch.
     */
    orderBy?: ProponenteOrderByWithRelationInput | ProponenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proponentes.
     */
    cursor?: ProponenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proponentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proponentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proponentes.
     */
    distinct?: ProponenteScalarFieldEnum | ProponenteScalarFieldEnum[]
  }

  /**
   * Proponente findMany
   */
  export type ProponenteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proponente
     */
    select?: ProponenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proponente
     */
    omit?: ProponenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProponenteInclude<ExtArgs> | null
    /**
     * Filter, which Proponentes to fetch.
     */
    where?: ProponenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proponentes to fetch.
     */
    orderBy?: ProponenteOrderByWithRelationInput | ProponenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proponentes.
     */
    cursor?: ProponenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proponentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proponentes.
     */
    skip?: number
    distinct?: ProponenteScalarFieldEnum | ProponenteScalarFieldEnum[]
  }

  /**
   * Proponente create
   */
  export type ProponenteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proponente
     */
    select?: ProponenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proponente
     */
    omit?: ProponenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProponenteInclude<ExtArgs> | null
    /**
     * The data needed to create a Proponente.
     */
    data: XOR<ProponenteCreateInput, ProponenteUncheckedCreateInput>
  }

  /**
   * Proponente createMany
   */
  export type ProponenteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Proponentes.
     */
    data: ProponenteCreateManyInput | ProponenteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Proponente update
   */
  export type ProponenteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proponente
     */
    select?: ProponenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proponente
     */
    omit?: ProponenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProponenteInclude<ExtArgs> | null
    /**
     * The data needed to update a Proponente.
     */
    data: XOR<ProponenteUpdateInput, ProponenteUncheckedUpdateInput>
    /**
     * Choose, which Proponente to update.
     */
    where: ProponenteWhereUniqueInput
  }

  /**
   * Proponente updateMany
   */
  export type ProponenteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Proponentes.
     */
    data: XOR<ProponenteUpdateManyMutationInput, ProponenteUncheckedUpdateManyInput>
    /**
     * Filter which Proponentes to update
     */
    where?: ProponenteWhereInput
    /**
     * Limit how many Proponentes to update.
     */
    limit?: number
  }

  /**
   * Proponente upsert
   */
  export type ProponenteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proponente
     */
    select?: ProponenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proponente
     */
    omit?: ProponenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProponenteInclude<ExtArgs> | null
    /**
     * The filter to search for the Proponente to update in case it exists.
     */
    where: ProponenteWhereUniqueInput
    /**
     * In case the Proponente found by the `where` argument doesn't exist, create a new Proponente with this data.
     */
    create: XOR<ProponenteCreateInput, ProponenteUncheckedCreateInput>
    /**
     * In case the Proponente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProponenteUpdateInput, ProponenteUncheckedUpdateInput>
  }

  /**
   * Proponente delete
   */
  export type ProponenteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proponente
     */
    select?: ProponenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proponente
     */
    omit?: ProponenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProponenteInclude<ExtArgs> | null
    /**
     * Filter which Proponente to delete.
     */
    where: ProponenteWhereUniqueInput
  }

  /**
   * Proponente deleteMany
   */
  export type ProponenteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proponentes to delete
     */
    where?: ProponenteWhereInput
    /**
     * Limit how many Proponentes to delete.
     */
    limit?: number
  }

  /**
   * Proponente.emprestimo
   */
  export type Proponente$emprestimoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprestimo
     */
    select?: EmprestimoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprestimo
     */
    omit?: EmprestimoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoInclude<ExtArgs> | null
    where?: EmprestimoWhereInput
    orderBy?: EmprestimoOrderByWithRelationInput | EmprestimoOrderByWithRelationInput[]
    cursor?: EmprestimoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmprestimoScalarFieldEnum | EmprestimoScalarFieldEnum[]
  }

  /**
   * Proponente.reembolso
   */
  export type Proponente$reembolsoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reembolso
     */
    select?: ReembolsoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reembolso
     */
    omit?: ReembolsoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReembolsoInclude<ExtArgs> | null
    where?: ReembolsoWhereInput
    orderBy?: ReembolsoOrderByWithRelationInput | ReembolsoOrderByWithRelationInput[]
    cursor?: ReembolsoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReembolsoScalarFieldEnum | ReembolsoScalarFieldEnum[]
  }

  /**
   * Proponente without action
   */
  export type ProponenteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proponente
     */
    select?: ProponenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proponente
     */
    omit?: ProponenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProponenteInclude<ExtArgs> | null
  }


  /**
   * Model Solidario
   */

  export type AggregateSolidario = {
    _count: SolidarioCountAggregateOutputType | null
    _avg: SolidarioAvgAggregateOutputType | null
    _sum: SolidarioSumAggregateOutputType | null
    _min: SolidarioMinAggregateOutputType | null
    _max: SolidarioMaxAggregateOutputType | null
  }

  export type SolidarioAvgAggregateOutputType = {
    id: number | null
    taxa: number | null
    pessoa_id: number | null
    user_id: number | null
  }

  export type SolidarioSumAggregateOutputType = {
    id: number | null
    taxa: number | null
    pessoa_id: number | null
    user_id: number | null
  }

  export type SolidarioMinAggregateOutputType = {
    id: number | null
    tipo: $Enums.Aval | null
    parentesco: $Enums.Parentesco | null
    taxa: number | null
    estado: boolean | null
    pessoa_id: number | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SolidarioMaxAggregateOutputType = {
    id: number | null
    tipo: $Enums.Aval | null
    parentesco: $Enums.Parentesco | null
    taxa: number | null
    estado: boolean | null
    pessoa_id: number | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SolidarioCountAggregateOutputType = {
    id: number
    tipo: number
    parentesco: number
    taxa: number
    estado: number
    pessoa_id: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SolidarioAvgAggregateInputType = {
    id?: true
    taxa?: true
    pessoa_id?: true
    user_id?: true
  }

  export type SolidarioSumAggregateInputType = {
    id?: true
    taxa?: true
    pessoa_id?: true
    user_id?: true
  }

  export type SolidarioMinAggregateInputType = {
    id?: true
    tipo?: true
    parentesco?: true
    taxa?: true
    estado?: true
    pessoa_id?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SolidarioMaxAggregateInputType = {
    id?: true
    tipo?: true
    parentesco?: true
    taxa?: true
    estado?: true
    pessoa_id?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SolidarioCountAggregateInputType = {
    id?: true
    tipo?: true
    parentesco?: true
    taxa?: true
    estado?: true
    pessoa_id?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SolidarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Solidario to aggregate.
     */
    where?: SolidarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Solidarios to fetch.
     */
    orderBy?: SolidarioOrderByWithRelationInput | SolidarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SolidarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Solidarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Solidarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Solidarios
    **/
    _count?: true | SolidarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SolidarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SolidarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SolidarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SolidarioMaxAggregateInputType
  }

  export type GetSolidarioAggregateType<T extends SolidarioAggregateArgs> = {
        [P in keyof T & keyof AggregateSolidario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSolidario[P]>
      : GetScalarType<T[P], AggregateSolidario[P]>
  }




  export type SolidarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SolidarioWhereInput
    orderBy?: SolidarioOrderByWithAggregationInput | SolidarioOrderByWithAggregationInput[]
    by: SolidarioScalarFieldEnum[] | SolidarioScalarFieldEnum
    having?: SolidarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SolidarioCountAggregateInputType | true
    _avg?: SolidarioAvgAggregateInputType
    _sum?: SolidarioSumAggregateInputType
    _min?: SolidarioMinAggregateInputType
    _max?: SolidarioMaxAggregateInputType
  }

  export type SolidarioGroupByOutputType = {
    id: number
    tipo: $Enums.Aval
    parentesco: $Enums.Parentesco
    taxa: number
    estado: boolean
    pessoa_id: number
    user_id: number
    createdAt: Date
    updatedAt: Date
    _count: SolidarioCountAggregateOutputType | null
    _avg: SolidarioAvgAggregateOutputType | null
    _sum: SolidarioSumAggregateOutputType | null
    _min: SolidarioMinAggregateOutputType | null
    _max: SolidarioMaxAggregateOutputType | null
  }

  type GetSolidarioGroupByPayload<T extends SolidarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SolidarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SolidarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SolidarioGroupByOutputType[P]>
            : GetScalarType<T[P], SolidarioGroupByOutputType[P]>
        }
      >
    >


  export type SolidarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    parentesco?: boolean
    taxa?: boolean
    estado?: boolean
    pessoa_id?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
    emprestimo?: boolean | Solidario$emprestimoArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    credito?: boolean | Solidario$creditoArgs<ExtArgs>
    _count?: boolean | SolidarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["solidario"]>



  export type SolidarioSelectScalar = {
    id?: boolean
    tipo?: boolean
    parentesco?: boolean
    taxa?: boolean
    estado?: boolean
    pessoa_id?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SolidarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipo" | "parentesco" | "taxa" | "estado" | "pessoa_id" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["solidario"]>
  export type SolidarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
    emprestimo?: boolean | Solidario$emprestimoArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    credito?: boolean | Solidario$creditoArgs<ExtArgs>
    _count?: boolean | SolidarioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SolidarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Solidario"
    objects: {
      pessoa: Prisma.$PessoaPayload<ExtArgs>
      emprestimo: Prisma.$EmprestimoSolidarioPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      credito: Prisma.$CreditoSolidarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipo: $Enums.Aval
      parentesco: $Enums.Parentesco
      taxa: number
      estado: boolean
      pessoa_id: number
      user_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["solidario"]>
    composites: {}
  }

  type SolidarioGetPayload<S extends boolean | null | undefined | SolidarioDefaultArgs> = $Result.GetResult<Prisma.$SolidarioPayload, S>

  type SolidarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SolidarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SolidarioCountAggregateInputType | true
    }

  export interface SolidarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Solidario'], meta: { name: 'Solidario' } }
    /**
     * Find zero or one Solidario that matches the filter.
     * @param {SolidarioFindUniqueArgs} args - Arguments to find a Solidario
     * @example
     * // Get one Solidario
     * const solidario = await prisma.solidario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SolidarioFindUniqueArgs>(args: SelectSubset<T, SolidarioFindUniqueArgs<ExtArgs>>): Prisma__SolidarioClient<$Result.GetResult<Prisma.$SolidarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Solidario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SolidarioFindUniqueOrThrowArgs} args - Arguments to find a Solidario
     * @example
     * // Get one Solidario
     * const solidario = await prisma.solidario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SolidarioFindUniqueOrThrowArgs>(args: SelectSubset<T, SolidarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SolidarioClient<$Result.GetResult<Prisma.$SolidarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Solidario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolidarioFindFirstArgs} args - Arguments to find a Solidario
     * @example
     * // Get one Solidario
     * const solidario = await prisma.solidario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SolidarioFindFirstArgs>(args?: SelectSubset<T, SolidarioFindFirstArgs<ExtArgs>>): Prisma__SolidarioClient<$Result.GetResult<Prisma.$SolidarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Solidario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolidarioFindFirstOrThrowArgs} args - Arguments to find a Solidario
     * @example
     * // Get one Solidario
     * const solidario = await prisma.solidario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SolidarioFindFirstOrThrowArgs>(args?: SelectSubset<T, SolidarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__SolidarioClient<$Result.GetResult<Prisma.$SolidarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Solidarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolidarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Solidarios
     * const solidarios = await prisma.solidario.findMany()
     * 
     * // Get first 10 Solidarios
     * const solidarios = await prisma.solidario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const solidarioWithIdOnly = await prisma.solidario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SolidarioFindManyArgs>(args?: SelectSubset<T, SolidarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SolidarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Solidario.
     * @param {SolidarioCreateArgs} args - Arguments to create a Solidario.
     * @example
     * // Create one Solidario
     * const Solidario = await prisma.solidario.create({
     *   data: {
     *     // ... data to create a Solidario
     *   }
     * })
     * 
     */
    create<T extends SolidarioCreateArgs>(args: SelectSubset<T, SolidarioCreateArgs<ExtArgs>>): Prisma__SolidarioClient<$Result.GetResult<Prisma.$SolidarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Solidarios.
     * @param {SolidarioCreateManyArgs} args - Arguments to create many Solidarios.
     * @example
     * // Create many Solidarios
     * const solidario = await prisma.solidario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SolidarioCreateManyArgs>(args?: SelectSubset<T, SolidarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Solidario.
     * @param {SolidarioDeleteArgs} args - Arguments to delete one Solidario.
     * @example
     * // Delete one Solidario
     * const Solidario = await prisma.solidario.delete({
     *   where: {
     *     // ... filter to delete one Solidario
     *   }
     * })
     * 
     */
    delete<T extends SolidarioDeleteArgs>(args: SelectSubset<T, SolidarioDeleteArgs<ExtArgs>>): Prisma__SolidarioClient<$Result.GetResult<Prisma.$SolidarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Solidario.
     * @param {SolidarioUpdateArgs} args - Arguments to update one Solidario.
     * @example
     * // Update one Solidario
     * const solidario = await prisma.solidario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SolidarioUpdateArgs>(args: SelectSubset<T, SolidarioUpdateArgs<ExtArgs>>): Prisma__SolidarioClient<$Result.GetResult<Prisma.$SolidarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Solidarios.
     * @param {SolidarioDeleteManyArgs} args - Arguments to filter Solidarios to delete.
     * @example
     * // Delete a few Solidarios
     * const { count } = await prisma.solidario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SolidarioDeleteManyArgs>(args?: SelectSubset<T, SolidarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Solidarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolidarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Solidarios
     * const solidario = await prisma.solidario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SolidarioUpdateManyArgs>(args: SelectSubset<T, SolidarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Solidario.
     * @param {SolidarioUpsertArgs} args - Arguments to update or create a Solidario.
     * @example
     * // Update or create a Solidario
     * const solidario = await prisma.solidario.upsert({
     *   create: {
     *     // ... data to create a Solidario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Solidario we want to update
     *   }
     * })
     */
    upsert<T extends SolidarioUpsertArgs>(args: SelectSubset<T, SolidarioUpsertArgs<ExtArgs>>): Prisma__SolidarioClient<$Result.GetResult<Prisma.$SolidarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Solidarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolidarioCountArgs} args - Arguments to filter Solidarios to count.
     * @example
     * // Count the number of Solidarios
     * const count = await prisma.solidario.count({
     *   where: {
     *     // ... the filter for the Solidarios we want to count
     *   }
     * })
    **/
    count<T extends SolidarioCountArgs>(
      args?: Subset<T, SolidarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SolidarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Solidario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolidarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SolidarioAggregateArgs>(args: Subset<T, SolidarioAggregateArgs>): Prisma.PrismaPromise<GetSolidarioAggregateType<T>>

    /**
     * Group by Solidario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolidarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SolidarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SolidarioGroupByArgs['orderBy'] }
        : { orderBy?: SolidarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SolidarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSolidarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Solidario model
   */
  readonly fields: SolidarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Solidario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SolidarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoa<T extends PessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PessoaDefaultArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    emprestimo<T extends Solidario$emprestimoArgs<ExtArgs> = {}>(args?: Subset<T, Solidario$emprestimoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmprestimoSolidarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    credito<T extends Solidario$creditoArgs<ExtArgs> = {}>(args?: Subset<T, Solidario$creditoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditoSolidarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Solidario model
   */
  interface SolidarioFieldRefs {
    readonly id: FieldRef<"Solidario", 'Int'>
    readonly tipo: FieldRef<"Solidario", 'Aval'>
    readonly parentesco: FieldRef<"Solidario", 'Parentesco'>
    readonly taxa: FieldRef<"Solidario", 'Int'>
    readonly estado: FieldRef<"Solidario", 'Boolean'>
    readonly pessoa_id: FieldRef<"Solidario", 'Int'>
    readonly user_id: FieldRef<"Solidario", 'Int'>
    readonly createdAt: FieldRef<"Solidario", 'DateTime'>
    readonly updatedAt: FieldRef<"Solidario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Solidario findUnique
   */
  export type SolidarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solidario
     */
    select?: SolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solidario
     */
    omit?: SolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolidarioInclude<ExtArgs> | null
    /**
     * Filter, which Solidario to fetch.
     */
    where: SolidarioWhereUniqueInput
  }

  /**
   * Solidario findUniqueOrThrow
   */
  export type SolidarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solidario
     */
    select?: SolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solidario
     */
    omit?: SolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolidarioInclude<ExtArgs> | null
    /**
     * Filter, which Solidario to fetch.
     */
    where: SolidarioWhereUniqueInput
  }

  /**
   * Solidario findFirst
   */
  export type SolidarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solidario
     */
    select?: SolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solidario
     */
    omit?: SolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolidarioInclude<ExtArgs> | null
    /**
     * Filter, which Solidario to fetch.
     */
    where?: SolidarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Solidarios to fetch.
     */
    orderBy?: SolidarioOrderByWithRelationInput | SolidarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Solidarios.
     */
    cursor?: SolidarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Solidarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Solidarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Solidarios.
     */
    distinct?: SolidarioScalarFieldEnum | SolidarioScalarFieldEnum[]
  }

  /**
   * Solidario findFirstOrThrow
   */
  export type SolidarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solidario
     */
    select?: SolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solidario
     */
    omit?: SolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolidarioInclude<ExtArgs> | null
    /**
     * Filter, which Solidario to fetch.
     */
    where?: SolidarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Solidarios to fetch.
     */
    orderBy?: SolidarioOrderByWithRelationInput | SolidarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Solidarios.
     */
    cursor?: SolidarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Solidarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Solidarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Solidarios.
     */
    distinct?: SolidarioScalarFieldEnum | SolidarioScalarFieldEnum[]
  }

  /**
   * Solidario findMany
   */
  export type SolidarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solidario
     */
    select?: SolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solidario
     */
    omit?: SolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolidarioInclude<ExtArgs> | null
    /**
     * Filter, which Solidarios to fetch.
     */
    where?: SolidarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Solidarios to fetch.
     */
    orderBy?: SolidarioOrderByWithRelationInput | SolidarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Solidarios.
     */
    cursor?: SolidarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Solidarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Solidarios.
     */
    skip?: number
    distinct?: SolidarioScalarFieldEnum | SolidarioScalarFieldEnum[]
  }

  /**
   * Solidario create
   */
  export type SolidarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solidario
     */
    select?: SolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solidario
     */
    omit?: SolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolidarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Solidario.
     */
    data: XOR<SolidarioCreateInput, SolidarioUncheckedCreateInput>
  }

  /**
   * Solidario createMany
   */
  export type SolidarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Solidarios.
     */
    data: SolidarioCreateManyInput | SolidarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Solidario update
   */
  export type SolidarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solidario
     */
    select?: SolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solidario
     */
    omit?: SolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolidarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Solidario.
     */
    data: XOR<SolidarioUpdateInput, SolidarioUncheckedUpdateInput>
    /**
     * Choose, which Solidario to update.
     */
    where: SolidarioWhereUniqueInput
  }

  /**
   * Solidario updateMany
   */
  export type SolidarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Solidarios.
     */
    data: XOR<SolidarioUpdateManyMutationInput, SolidarioUncheckedUpdateManyInput>
    /**
     * Filter which Solidarios to update
     */
    where?: SolidarioWhereInput
    /**
     * Limit how many Solidarios to update.
     */
    limit?: number
  }

  /**
   * Solidario upsert
   */
  export type SolidarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solidario
     */
    select?: SolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solidario
     */
    omit?: SolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolidarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Solidario to update in case it exists.
     */
    where: SolidarioWhereUniqueInput
    /**
     * In case the Solidario found by the `where` argument doesn't exist, create a new Solidario with this data.
     */
    create: XOR<SolidarioCreateInput, SolidarioUncheckedCreateInput>
    /**
     * In case the Solidario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SolidarioUpdateInput, SolidarioUncheckedUpdateInput>
  }

  /**
   * Solidario delete
   */
  export type SolidarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solidario
     */
    select?: SolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solidario
     */
    omit?: SolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolidarioInclude<ExtArgs> | null
    /**
     * Filter which Solidario to delete.
     */
    where: SolidarioWhereUniqueInput
  }

  /**
   * Solidario deleteMany
   */
  export type SolidarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Solidarios to delete
     */
    where?: SolidarioWhereInput
    /**
     * Limit how many Solidarios to delete.
     */
    limit?: number
  }

  /**
   * Solidario.emprestimo
   */
  export type Solidario$emprestimoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmprestimoSolidario
     */
    select?: EmprestimoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmprestimoSolidario
     */
    omit?: EmprestimoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoSolidarioInclude<ExtArgs> | null
    where?: EmprestimoSolidarioWhereInput
    orderBy?: EmprestimoSolidarioOrderByWithRelationInput | EmprestimoSolidarioOrderByWithRelationInput[]
    cursor?: EmprestimoSolidarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmprestimoSolidarioScalarFieldEnum | EmprestimoSolidarioScalarFieldEnum[]
  }

  /**
   * Solidario.credito
   */
  export type Solidario$creditoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditoSolidario
     */
    select?: CreditoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditoSolidario
     */
    omit?: CreditoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoSolidarioInclude<ExtArgs> | null
    where?: CreditoSolidarioWhereInput
    orderBy?: CreditoSolidarioOrderByWithRelationInput | CreditoSolidarioOrderByWithRelationInput[]
    cursor?: CreditoSolidarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditoSolidarioScalarFieldEnum | CreditoSolidarioScalarFieldEnum[]
  }

  /**
   * Solidario without action
   */
  export type SolidarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solidario
     */
    select?: SolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solidario
     */
    omit?: SolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolidarioInclude<ExtArgs> | null
  }


  /**
   * Model Movel
   */

  export type AggregateMovel = {
    _count: MovelCountAggregateOutputType | null
    _avg: MovelAvgAggregateOutputType | null
    _sum: MovelSumAggregateOutputType | null
    _min: MovelMinAggregateOutputType | null
    _max: MovelMaxAggregateOutputType | null
  }

  export type MovelAvgAggregateOutputType = {
    id: number | null
    devedor_id: number | null
  }

  export type MovelSumAggregateOutputType = {
    id: number | null
    devedor_id: number | null
  }

  export type MovelMinAggregateOutputType = {
    id: number | null
    modelo: $Enums.Modelo | null
    matricula: string | null
    detalhes: string | null
    devedor_id: number | null
    estado: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MovelMaxAggregateOutputType = {
    id: number | null
    modelo: $Enums.Modelo | null
    matricula: string | null
    detalhes: string | null
    devedor_id: number | null
    estado: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MovelCountAggregateOutputType = {
    id: number
    modelo: number
    matricula: number
    detalhes: number
    devedor_id: number
    estado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MovelAvgAggregateInputType = {
    id?: true
    devedor_id?: true
  }

  export type MovelSumAggregateInputType = {
    id?: true
    devedor_id?: true
  }

  export type MovelMinAggregateInputType = {
    id?: true
    modelo?: true
    matricula?: true
    detalhes?: true
    devedor_id?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MovelMaxAggregateInputType = {
    id?: true
    modelo?: true
    matricula?: true
    detalhes?: true
    devedor_id?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MovelCountAggregateInputType = {
    id?: true
    modelo?: true
    matricula?: true
    detalhes?: true
    devedor_id?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MovelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movel to aggregate.
     */
    where?: MovelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movels to fetch.
     */
    orderBy?: MovelOrderByWithRelationInput | MovelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Movels
    **/
    _count?: true | MovelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MovelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MovelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovelMaxAggregateInputType
  }

  export type GetMovelAggregateType<T extends MovelAggregateArgs> = {
        [P in keyof T & keyof AggregateMovel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovel[P]>
      : GetScalarType<T[P], AggregateMovel[P]>
  }




  export type MovelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovelWhereInput
    orderBy?: MovelOrderByWithAggregationInput | MovelOrderByWithAggregationInput[]
    by: MovelScalarFieldEnum[] | MovelScalarFieldEnum
    having?: MovelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovelCountAggregateInputType | true
    _avg?: MovelAvgAggregateInputType
    _sum?: MovelSumAggregateInputType
    _min?: MovelMinAggregateInputType
    _max?: MovelMaxAggregateInputType
  }

  export type MovelGroupByOutputType = {
    id: number
    modelo: $Enums.Modelo
    matricula: string
    detalhes: string
    devedor_id: number
    estado: boolean
    createdAt: Date
    updatedAt: Date
    _count: MovelCountAggregateOutputType | null
    _avg: MovelAvgAggregateOutputType | null
    _sum: MovelSumAggregateOutputType | null
    _min: MovelMinAggregateOutputType | null
    _max: MovelMaxAggregateOutputType | null
  }

  type GetMovelGroupByPayload<T extends MovelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovelGroupByOutputType[P]>
            : GetScalarType<T[P], MovelGroupByOutputType[P]>
        }
      >
    >


  export type MovelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelo?: boolean
    matricula?: boolean
    detalhes?: boolean
    devedor_id?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    devedor?: boolean | DevedorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movel"]>



  export type MovelSelectScalar = {
    id?: boolean
    modelo?: boolean
    matricula?: boolean
    detalhes?: boolean
    devedor_id?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MovelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "modelo" | "matricula" | "detalhes" | "devedor_id" | "estado" | "createdAt" | "updatedAt", ExtArgs["result"]["movel"]>
  export type MovelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devedor?: boolean | DevedorDefaultArgs<ExtArgs>
  }

  export type $MovelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Movel"
    objects: {
      devedor: Prisma.$DevedorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      modelo: $Enums.Modelo
      matricula: string
      detalhes: string
      devedor_id: number
      estado: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["movel"]>
    composites: {}
  }

  type MovelGetPayload<S extends boolean | null | undefined | MovelDefaultArgs> = $Result.GetResult<Prisma.$MovelPayload, S>

  type MovelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MovelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MovelCountAggregateInputType | true
    }

  export interface MovelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Movel'], meta: { name: 'Movel' } }
    /**
     * Find zero or one Movel that matches the filter.
     * @param {MovelFindUniqueArgs} args - Arguments to find a Movel
     * @example
     * // Get one Movel
     * const movel = await prisma.movel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovelFindUniqueArgs>(args: SelectSubset<T, MovelFindUniqueArgs<ExtArgs>>): Prisma__MovelClient<$Result.GetResult<Prisma.$MovelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Movel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MovelFindUniqueOrThrowArgs} args - Arguments to find a Movel
     * @example
     * // Get one Movel
     * const movel = await prisma.movel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovelFindUniqueOrThrowArgs>(args: SelectSubset<T, MovelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovelClient<$Result.GetResult<Prisma.$MovelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Movel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovelFindFirstArgs} args - Arguments to find a Movel
     * @example
     * // Get one Movel
     * const movel = await prisma.movel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovelFindFirstArgs>(args?: SelectSubset<T, MovelFindFirstArgs<ExtArgs>>): Prisma__MovelClient<$Result.GetResult<Prisma.$MovelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Movel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovelFindFirstOrThrowArgs} args - Arguments to find a Movel
     * @example
     * // Get one Movel
     * const movel = await prisma.movel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovelFindFirstOrThrowArgs>(args?: SelectSubset<T, MovelFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovelClient<$Result.GetResult<Prisma.$MovelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Movels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Movels
     * const movels = await prisma.movel.findMany()
     * 
     * // Get first 10 Movels
     * const movels = await prisma.movel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movelWithIdOnly = await prisma.movel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MovelFindManyArgs>(args?: SelectSubset<T, MovelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Movel.
     * @param {MovelCreateArgs} args - Arguments to create a Movel.
     * @example
     * // Create one Movel
     * const Movel = await prisma.movel.create({
     *   data: {
     *     // ... data to create a Movel
     *   }
     * })
     * 
     */
    create<T extends MovelCreateArgs>(args: SelectSubset<T, MovelCreateArgs<ExtArgs>>): Prisma__MovelClient<$Result.GetResult<Prisma.$MovelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Movels.
     * @param {MovelCreateManyArgs} args - Arguments to create many Movels.
     * @example
     * // Create many Movels
     * const movel = await prisma.movel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovelCreateManyArgs>(args?: SelectSubset<T, MovelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Movel.
     * @param {MovelDeleteArgs} args - Arguments to delete one Movel.
     * @example
     * // Delete one Movel
     * const Movel = await prisma.movel.delete({
     *   where: {
     *     // ... filter to delete one Movel
     *   }
     * })
     * 
     */
    delete<T extends MovelDeleteArgs>(args: SelectSubset<T, MovelDeleteArgs<ExtArgs>>): Prisma__MovelClient<$Result.GetResult<Prisma.$MovelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Movel.
     * @param {MovelUpdateArgs} args - Arguments to update one Movel.
     * @example
     * // Update one Movel
     * const movel = await prisma.movel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovelUpdateArgs>(args: SelectSubset<T, MovelUpdateArgs<ExtArgs>>): Prisma__MovelClient<$Result.GetResult<Prisma.$MovelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Movels.
     * @param {MovelDeleteManyArgs} args - Arguments to filter Movels to delete.
     * @example
     * // Delete a few Movels
     * const { count } = await prisma.movel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovelDeleteManyArgs>(args?: SelectSubset<T, MovelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Movels
     * const movel = await prisma.movel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovelUpdateManyArgs>(args: SelectSubset<T, MovelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Movel.
     * @param {MovelUpsertArgs} args - Arguments to update or create a Movel.
     * @example
     * // Update or create a Movel
     * const movel = await prisma.movel.upsert({
     *   create: {
     *     // ... data to create a Movel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Movel we want to update
     *   }
     * })
     */
    upsert<T extends MovelUpsertArgs>(args: SelectSubset<T, MovelUpsertArgs<ExtArgs>>): Prisma__MovelClient<$Result.GetResult<Prisma.$MovelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Movels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovelCountArgs} args - Arguments to filter Movels to count.
     * @example
     * // Count the number of Movels
     * const count = await prisma.movel.count({
     *   where: {
     *     // ... the filter for the Movels we want to count
     *   }
     * })
    **/
    count<T extends MovelCountArgs>(
      args?: Subset<T, MovelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Movel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovelAggregateArgs>(args: Subset<T, MovelAggregateArgs>): Prisma.PrismaPromise<GetMovelAggregateType<T>>

    /**
     * Group by Movel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovelGroupByArgs['orderBy'] }
        : { orderBy?: MovelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Movel model
   */
  readonly fields: MovelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Movel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    devedor<T extends DevedorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DevedorDefaultArgs<ExtArgs>>): Prisma__DevedorClient<$Result.GetResult<Prisma.$DevedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Movel model
   */
  interface MovelFieldRefs {
    readonly id: FieldRef<"Movel", 'Int'>
    readonly modelo: FieldRef<"Movel", 'Modelo'>
    readonly matricula: FieldRef<"Movel", 'String'>
    readonly detalhes: FieldRef<"Movel", 'String'>
    readonly devedor_id: FieldRef<"Movel", 'Int'>
    readonly estado: FieldRef<"Movel", 'Boolean'>
    readonly createdAt: FieldRef<"Movel", 'DateTime'>
    readonly updatedAt: FieldRef<"Movel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Movel findUnique
   */
  export type MovelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movel
     */
    select?: MovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movel
     */
    omit?: MovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovelInclude<ExtArgs> | null
    /**
     * Filter, which Movel to fetch.
     */
    where: MovelWhereUniqueInput
  }

  /**
   * Movel findUniqueOrThrow
   */
  export type MovelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movel
     */
    select?: MovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movel
     */
    omit?: MovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovelInclude<ExtArgs> | null
    /**
     * Filter, which Movel to fetch.
     */
    where: MovelWhereUniqueInput
  }

  /**
   * Movel findFirst
   */
  export type MovelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movel
     */
    select?: MovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movel
     */
    omit?: MovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovelInclude<ExtArgs> | null
    /**
     * Filter, which Movel to fetch.
     */
    where?: MovelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movels to fetch.
     */
    orderBy?: MovelOrderByWithRelationInput | MovelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movels.
     */
    cursor?: MovelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movels.
     */
    distinct?: MovelScalarFieldEnum | MovelScalarFieldEnum[]
  }

  /**
   * Movel findFirstOrThrow
   */
  export type MovelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movel
     */
    select?: MovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movel
     */
    omit?: MovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovelInclude<ExtArgs> | null
    /**
     * Filter, which Movel to fetch.
     */
    where?: MovelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movels to fetch.
     */
    orderBy?: MovelOrderByWithRelationInput | MovelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movels.
     */
    cursor?: MovelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movels.
     */
    distinct?: MovelScalarFieldEnum | MovelScalarFieldEnum[]
  }

  /**
   * Movel findMany
   */
  export type MovelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movel
     */
    select?: MovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movel
     */
    omit?: MovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovelInclude<ExtArgs> | null
    /**
     * Filter, which Movels to fetch.
     */
    where?: MovelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movels to fetch.
     */
    orderBy?: MovelOrderByWithRelationInput | MovelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Movels.
     */
    cursor?: MovelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movels.
     */
    skip?: number
    distinct?: MovelScalarFieldEnum | MovelScalarFieldEnum[]
  }

  /**
   * Movel create
   */
  export type MovelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movel
     */
    select?: MovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movel
     */
    omit?: MovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovelInclude<ExtArgs> | null
    /**
     * The data needed to create a Movel.
     */
    data: XOR<MovelCreateInput, MovelUncheckedCreateInput>
  }

  /**
   * Movel createMany
   */
  export type MovelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Movels.
     */
    data: MovelCreateManyInput | MovelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Movel update
   */
  export type MovelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movel
     */
    select?: MovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movel
     */
    omit?: MovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovelInclude<ExtArgs> | null
    /**
     * The data needed to update a Movel.
     */
    data: XOR<MovelUpdateInput, MovelUncheckedUpdateInput>
    /**
     * Choose, which Movel to update.
     */
    where: MovelWhereUniqueInput
  }

  /**
   * Movel updateMany
   */
  export type MovelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Movels.
     */
    data: XOR<MovelUpdateManyMutationInput, MovelUncheckedUpdateManyInput>
    /**
     * Filter which Movels to update
     */
    where?: MovelWhereInput
    /**
     * Limit how many Movels to update.
     */
    limit?: number
  }

  /**
   * Movel upsert
   */
  export type MovelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movel
     */
    select?: MovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movel
     */
    omit?: MovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovelInclude<ExtArgs> | null
    /**
     * The filter to search for the Movel to update in case it exists.
     */
    where: MovelWhereUniqueInput
    /**
     * In case the Movel found by the `where` argument doesn't exist, create a new Movel with this data.
     */
    create: XOR<MovelCreateInput, MovelUncheckedCreateInput>
    /**
     * In case the Movel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovelUpdateInput, MovelUncheckedUpdateInput>
  }

  /**
   * Movel delete
   */
  export type MovelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movel
     */
    select?: MovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movel
     */
    omit?: MovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovelInclude<ExtArgs> | null
    /**
     * Filter which Movel to delete.
     */
    where: MovelWhereUniqueInput
  }

  /**
   * Movel deleteMany
   */
  export type MovelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movels to delete
     */
    where?: MovelWhereInput
    /**
     * Limit how many Movels to delete.
     */
    limit?: number
  }

  /**
   * Movel without action
   */
  export type MovelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movel
     */
    select?: MovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movel
     */
    omit?: MovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovelInclude<ExtArgs> | null
  }


  /**
   * Model Credito
   */

  export type AggregateCredito = {
    _count: CreditoCountAggregateOutputType | null
    _avg: CreditoAvgAggregateOutputType | null
    _sum: CreditoSumAggregateOutputType | null
    _min: CreditoMinAggregateOutputType | null
    _max: CreditoMaxAggregateOutputType | null
  }

  export type CreditoAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    prestacao: number | null
    juro: number | null
    devedor_id: number | null
  }

  export type CreditoSumAggregateOutputType = {
    id: number | null
    valor: number | null
    prestacao: number | null
    juro: number | null
    devedor_id: number | null
  }

  export type CreditoMinAggregateOutputType = {
    id: number | null
    tipo: $Enums.Produto | null
    valor: number | null
    prestacao: number | null
    juro: number | null
    termino: Date | null
    estado: boolean | null
    pendencia: boolean | null
    progresso: $Enums.Progresso | null
    devedor_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreditoMaxAggregateOutputType = {
    id: number | null
    tipo: $Enums.Produto | null
    valor: number | null
    prestacao: number | null
    juro: number | null
    termino: Date | null
    estado: boolean | null
    pendencia: boolean | null
    progresso: $Enums.Progresso | null
    devedor_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreditoCountAggregateOutputType = {
    id: number
    tipo: number
    valor: number
    prestacao: number
    juro: number
    termino: number
    estado: number
    pendencia: number
    progresso: number
    devedor_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CreditoAvgAggregateInputType = {
    id?: true
    valor?: true
    prestacao?: true
    juro?: true
    devedor_id?: true
  }

  export type CreditoSumAggregateInputType = {
    id?: true
    valor?: true
    prestacao?: true
    juro?: true
    devedor_id?: true
  }

  export type CreditoMinAggregateInputType = {
    id?: true
    tipo?: true
    valor?: true
    prestacao?: true
    juro?: true
    termino?: true
    estado?: true
    pendencia?: true
    progresso?: true
    devedor_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreditoMaxAggregateInputType = {
    id?: true
    tipo?: true
    valor?: true
    prestacao?: true
    juro?: true
    termino?: true
    estado?: true
    pendencia?: true
    progresso?: true
    devedor_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreditoCountAggregateInputType = {
    id?: true
    tipo?: true
    valor?: true
    prestacao?: true
    juro?: true
    termino?: true
    estado?: true
    pendencia?: true
    progresso?: true
    devedor_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CreditoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credito to aggregate.
     */
    where?: CreditoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creditos to fetch.
     */
    orderBy?: CreditoOrderByWithRelationInput | CreditoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creditos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creditos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Creditos
    **/
    _count?: true | CreditoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditoMaxAggregateInputType
  }

  export type GetCreditoAggregateType<T extends CreditoAggregateArgs> = {
        [P in keyof T & keyof AggregateCredito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredito[P]>
      : GetScalarType<T[P], AggregateCredito[P]>
  }




  export type CreditoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditoWhereInput
    orderBy?: CreditoOrderByWithAggregationInput | CreditoOrderByWithAggregationInput[]
    by: CreditoScalarFieldEnum[] | CreditoScalarFieldEnum
    having?: CreditoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditoCountAggregateInputType | true
    _avg?: CreditoAvgAggregateInputType
    _sum?: CreditoSumAggregateInputType
    _min?: CreditoMinAggregateInputType
    _max?: CreditoMaxAggregateInputType
  }

  export type CreditoGroupByOutputType = {
    id: number
    tipo: $Enums.Produto
    valor: number
    prestacao: number
    juro: number
    termino: Date
    estado: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    devedor_id: number
    createdAt: Date
    updatedAt: Date
    _count: CreditoCountAggregateOutputType | null
    _avg: CreditoAvgAggregateOutputType | null
    _sum: CreditoSumAggregateOutputType | null
    _min: CreditoMinAggregateOutputType | null
    _max: CreditoMaxAggregateOutputType | null
  }

  type GetCreditoGroupByPayload<T extends CreditoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditoGroupByOutputType[P]>
            : GetScalarType<T[P], CreditoGroupByOutputType[P]>
        }
      >
    >


  export type CreditoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    valor?: boolean
    prestacao?: boolean
    juro?: boolean
    termino?: boolean
    estado?: boolean
    pendencia?: boolean
    progresso?: boolean
    devedor_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    solidario?: boolean | Credito$solidarioArgs<ExtArgs>
    devedor?: boolean | DevedorDefaultArgs<ExtArgs>
    _count?: boolean | CreditoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credito"]>



  export type CreditoSelectScalar = {
    id?: boolean
    tipo?: boolean
    valor?: boolean
    prestacao?: boolean
    juro?: boolean
    termino?: boolean
    estado?: boolean
    pendencia?: boolean
    progresso?: boolean
    devedor_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CreditoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipo" | "valor" | "prestacao" | "juro" | "termino" | "estado" | "pendencia" | "progresso" | "devedor_id" | "createdAt" | "updatedAt", ExtArgs["result"]["credito"]>
  export type CreditoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solidario?: boolean | Credito$solidarioArgs<ExtArgs>
    devedor?: boolean | DevedorDefaultArgs<ExtArgs>
    _count?: boolean | CreditoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CreditoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Credito"
    objects: {
      solidario: Prisma.$CreditoSolidarioPayload<ExtArgs>[]
      devedor: Prisma.$DevedorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipo: $Enums.Produto
      valor: number
      prestacao: number
      juro: number
      termino: Date
      estado: boolean
      pendencia: boolean
      progresso: $Enums.Progresso
      devedor_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["credito"]>
    composites: {}
  }

  type CreditoGetPayload<S extends boolean | null | undefined | CreditoDefaultArgs> = $Result.GetResult<Prisma.$CreditoPayload, S>

  type CreditoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditoCountAggregateInputType | true
    }

  export interface CreditoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Credito'], meta: { name: 'Credito' } }
    /**
     * Find zero or one Credito that matches the filter.
     * @param {CreditoFindUniqueArgs} args - Arguments to find a Credito
     * @example
     * // Get one Credito
     * const credito = await prisma.credito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditoFindUniqueArgs>(args: SelectSubset<T, CreditoFindUniqueArgs<ExtArgs>>): Prisma__CreditoClient<$Result.GetResult<Prisma.$CreditoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Credito that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditoFindUniqueOrThrowArgs} args - Arguments to find a Credito
     * @example
     * // Get one Credito
     * const credito = await prisma.credito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditoFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditoClient<$Result.GetResult<Prisma.$CreditoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditoFindFirstArgs} args - Arguments to find a Credito
     * @example
     * // Get one Credito
     * const credito = await prisma.credito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditoFindFirstArgs>(args?: SelectSubset<T, CreditoFindFirstArgs<ExtArgs>>): Prisma__CreditoClient<$Result.GetResult<Prisma.$CreditoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditoFindFirstOrThrowArgs} args - Arguments to find a Credito
     * @example
     * // Get one Credito
     * const credito = await prisma.credito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditoFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditoClient<$Result.GetResult<Prisma.$CreditoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Creditos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Creditos
     * const creditos = await prisma.credito.findMany()
     * 
     * // Get first 10 Creditos
     * const creditos = await prisma.credito.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditoWithIdOnly = await prisma.credito.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditoFindManyArgs>(args?: SelectSubset<T, CreditoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Credito.
     * @param {CreditoCreateArgs} args - Arguments to create a Credito.
     * @example
     * // Create one Credito
     * const Credito = await prisma.credito.create({
     *   data: {
     *     // ... data to create a Credito
     *   }
     * })
     * 
     */
    create<T extends CreditoCreateArgs>(args: SelectSubset<T, CreditoCreateArgs<ExtArgs>>): Prisma__CreditoClient<$Result.GetResult<Prisma.$CreditoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Creditos.
     * @param {CreditoCreateManyArgs} args - Arguments to create many Creditos.
     * @example
     * // Create many Creditos
     * const credito = await prisma.credito.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditoCreateManyArgs>(args?: SelectSubset<T, CreditoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Credito.
     * @param {CreditoDeleteArgs} args - Arguments to delete one Credito.
     * @example
     * // Delete one Credito
     * const Credito = await prisma.credito.delete({
     *   where: {
     *     // ... filter to delete one Credito
     *   }
     * })
     * 
     */
    delete<T extends CreditoDeleteArgs>(args: SelectSubset<T, CreditoDeleteArgs<ExtArgs>>): Prisma__CreditoClient<$Result.GetResult<Prisma.$CreditoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Credito.
     * @param {CreditoUpdateArgs} args - Arguments to update one Credito.
     * @example
     * // Update one Credito
     * const credito = await prisma.credito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditoUpdateArgs>(args: SelectSubset<T, CreditoUpdateArgs<ExtArgs>>): Prisma__CreditoClient<$Result.GetResult<Prisma.$CreditoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Creditos.
     * @param {CreditoDeleteManyArgs} args - Arguments to filter Creditos to delete.
     * @example
     * // Delete a few Creditos
     * const { count } = await prisma.credito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditoDeleteManyArgs>(args?: SelectSubset<T, CreditoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creditos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Creditos
     * const credito = await prisma.credito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditoUpdateManyArgs>(args: SelectSubset<T, CreditoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Credito.
     * @param {CreditoUpsertArgs} args - Arguments to update or create a Credito.
     * @example
     * // Update or create a Credito
     * const credito = await prisma.credito.upsert({
     *   create: {
     *     // ... data to create a Credito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credito we want to update
     *   }
     * })
     */
    upsert<T extends CreditoUpsertArgs>(args: SelectSubset<T, CreditoUpsertArgs<ExtArgs>>): Prisma__CreditoClient<$Result.GetResult<Prisma.$CreditoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Creditos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditoCountArgs} args - Arguments to filter Creditos to count.
     * @example
     * // Count the number of Creditos
     * const count = await prisma.credito.count({
     *   where: {
     *     // ... the filter for the Creditos we want to count
     *   }
     * })
    **/
    count<T extends CreditoCountArgs>(
      args?: Subset<T, CreditoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditoAggregateArgs>(args: Subset<T, CreditoAggregateArgs>): Prisma.PrismaPromise<GetCreditoAggregateType<T>>

    /**
     * Group by Credito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditoGroupByArgs['orderBy'] }
        : { orderBy?: CreditoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Credito model
   */
  readonly fields: CreditoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Credito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    solidario<T extends Credito$solidarioArgs<ExtArgs> = {}>(args?: Subset<T, Credito$solidarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditoSolidarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    devedor<T extends DevedorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DevedorDefaultArgs<ExtArgs>>): Prisma__DevedorClient<$Result.GetResult<Prisma.$DevedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Credito model
   */
  interface CreditoFieldRefs {
    readonly id: FieldRef<"Credito", 'Int'>
    readonly tipo: FieldRef<"Credito", 'Produto'>
    readonly valor: FieldRef<"Credito", 'Float'>
    readonly prestacao: FieldRef<"Credito", 'Int'>
    readonly juro: FieldRef<"Credito", 'Int'>
    readonly termino: FieldRef<"Credito", 'DateTime'>
    readonly estado: FieldRef<"Credito", 'Boolean'>
    readonly pendencia: FieldRef<"Credito", 'Boolean'>
    readonly progresso: FieldRef<"Credito", 'Progresso'>
    readonly devedor_id: FieldRef<"Credito", 'Int'>
    readonly createdAt: FieldRef<"Credito", 'DateTime'>
    readonly updatedAt: FieldRef<"Credito", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Credito findUnique
   */
  export type CreditoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credito
     */
    select?: CreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credito
     */
    omit?: CreditoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoInclude<ExtArgs> | null
    /**
     * Filter, which Credito to fetch.
     */
    where: CreditoWhereUniqueInput
  }

  /**
   * Credito findUniqueOrThrow
   */
  export type CreditoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credito
     */
    select?: CreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credito
     */
    omit?: CreditoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoInclude<ExtArgs> | null
    /**
     * Filter, which Credito to fetch.
     */
    where: CreditoWhereUniqueInput
  }

  /**
   * Credito findFirst
   */
  export type CreditoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credito
     */
    select?: CreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credito
     */
    omit?: CreditoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoInclude<ExtArgs> | null
    /**
     * Filter, which Credito to fetch.
     */
    where?: CreditoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creditos to fetch.
     */
    orderBy?: CreditoOrderByWithRelationInput | CreditoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creditos.
     */
    cursor?: CreditoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creditos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creditos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creditos.
     */
    distinct?: CreditoScalarFieldEnum | CreditoScalarFieldEnum[]
  }

  /**
   * Credito findFirstOrThrow
   */
  export type CreditoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credito
     */
    select?: CreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credito
     */
    omit?: CreditoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoInclude<ExtArgs> | null
    /**
     * Filter, which Credito to fetch.
     */
    where?: CreditoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creditos to fetch.
     */
    orderBy?: CreditoOrderByWithRelationInput | CreditoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creditos.
     */
    cursor?: CreditoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creditos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creditos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creditos.
     */
    distinct?: CreditoScalarFieldEnum | CreditoScalarFieldEnum[]
  }

  /**
   * Credito findMany
   */
  export type CreditoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credito
     */
    select?: CreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credito
     */
    omit?: CreditoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoInclude<ExtArgs> | null
    /**
     * Filter, which Creditos to fetch.
     */
    where?: CreditoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creditos to fetch.
     */
    orderBy?: CreditoOrderByWithRelationInput | CreditoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Creditos.
     */
    cursor?: CreditoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creditos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creditos.
     */
    skip?: number
    distinct?: CreditoScalarFieldEnum | CreditoScalarFieldEnum[]
  }

  /**
   * Credito create
   */
  export type CreditoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credito
     */
    select?: CreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credito
     */
    omit?: CreditoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoInclude<ExtArgs> | null
    /**
     * The data needed to create a Credito.
     */
    data: XOR<CreditoCreateInput, CreditoUncheckedCreateInput>
  }

  /**
   * Credito createMany
   */
  export type CreditoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Creditos.
     */
    data: CreditoCreateManyInput | CreditoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Credito update
   */
  export type CreditoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credito
     */
    select?: CreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credito
     */
    omit?: CreditoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoInclude<ExtArgs> | null
    /**
     * The data needed to update a Credito.
     */
    data: XOR<CreditoUpdateInput, CreditoUncheckedUpdateInput>
    /**
     * Choose, which Credito to update.
     */
    where: CreditoWhereUniqueInput
  }

  /**
   * Credito updateMany
   */
  export type CreditoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Creditos.
     */
    data: XOR<CreditoUpdateManyMutationInput, CreditoUncheckedUpdateManyInput>
    /**
     * Filter which Creditos to update
     */
    where?: CreditoWhereInput
    /**
     * Limit how many Creditos to update.
     */
    limit?: number
  }

  /**
   * Credito upsert
   */
  export type CreditoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credito
     */
    select?: CreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credito
     */
    omit?: CreditoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoInclude<ExtArgs> | null
    /**
     * The filter to search for the Credito to update in case it exists.
     */
    where: CreditoWhereUniqueInput
    /**
     * In case the Credito found by the `where` argument doesn't exist, create a new Credito with this data.
     */
    create: XOR<CreditoCreateInput, CreditoUncheckedCreateInput>
    /**
     * In case the Credito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditoUpdateInput, CreditoUncheckedUpdateInput>
  }

  /**
   * Credito delete
   */
  export type CreditoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credito
     */
    select?: CreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credito
     */
    omit?: CreditoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoInclude<ExtArgs> | null
    /**
     * Filter which Credito to delete.
     */
    where: CreditoWhereUniqueInput
  }

  /**
   * Credito deleteMany
   */
  export type CreditoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creditos to delete
     */
    where?: CreditoWhereInput
    /**
     * Limit how many Creditos to delete.
     */
    limit?: number
  }

  /**
   * Credito.solidario
   */
  export type Credito$solidarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditoSolidario
     */
    select?: CreditoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditoSolidario
     */
    omit?: CreditoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoSolidarioInclude<ExtArgs> | null
    where?: CreditoSolidarioWhereInput
    orderBy?: CreditoSolidarioOrderByWithRelationInput | CreditoSolidarioOrderByWithRelationInput[]
    cursor?: CreditoSolidarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditoSolidarioScalarFieldEnum | CreditoSolidarioScalarFieldEnum[]
  }

  /**
   * Credito without action
   */
  export type CreditoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credito
     */
    select?: CreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credito
     */
    omit?: CreditoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoInclude<ExtArgs> | null
  }


  /**
   * Model Emprestimo
   */

  export type AggregateEmprestimo = {
    _count: EmprestimoCountAggregateOutputType | null
    _avg: EmprestimoAvgAggregateOutputType | null
    _sum: EmprestimoSumAggregateOutputType | null
    _min: EmprestimoMinAggregateOutputType | null
    _max: EmprestimoMaxAggregateOutputType | null
  }

  export type EmprestimoAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    juro_proponente: number | null
    taxa_investidor: number | null
    prestacao: number | null
    proponente_id: number | null
  }

  export type EmprestimoSumAggregateOutputType = {
    id: number | null
    valor: number | null
    juro_proponente: number | null
    taxa_investidor: number | null
    prestacao: number | null
    proponente_id: number | null
  }

  export type EmprestimoMinAggregateOutputType = {
    id: number | null
    valor: number | null
    juro_proponente: number | null
    taxa_investidor: number | null
    prestacao: number | null
    termino: Date | null
    estado: boolean | null
    pendencia: boolean | null
    progresso: $Enums.Progresso | null
    proponente_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmprestimoMaxAggregateOutputType = {
    id: number | null
    valor: number | null
    juro_proponente: number | null
    taxa_investidor: number | null
    prestacao: number | null
    termino: Date | null
    estado: boolean | null
    pendencia: boolean | null
    progresso: $Enums.Progresso | null
    proponente_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmprestimoCountAggregateOutputType = {
    id: number
    valor: number
    juro_proponente: number
    taxa_investidor: number
    prestacao: number
    termino: number
    estado: number
    pendencia: number
    progresso: number
    proponente_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmprestimoAvgAggregateInputType = {
    id?: true
    valor?: true
    juro_proponente?: true
    taxa_investidor?: true
    prestacao?: true
    proponente_id?: true
  }

  export type EmprestimoSumAggregateInputType = {
    id?: true
    valor?: true
    juro_proponente?: true
    taxa_investidor?: true
    prestacao?: true
    proponente_id?: true
  }

  export type EmprestimoMinAggregateInputType = {
    id?: true
    valor?: true
    juro_proponente?: true
    taxa_investidor?: true
    prestacao?: true
    termino?: true
    estado?: true
    pendencia?: true
    progresso?: true
    proponente_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmprestimoMaxAggregateInputType = {
    id?: true
    valor?: true
    juro_proponente?: true
    taxa_investidor?: true
    prestacao?: true
    termino?: true
    estado?: true
    pendencia?: true
    progresso?: true
    proponente_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmprestimoCountAggregateInputType = {
    id?: true
    valor?: true
    juro_proponente?: true
    taxa_investidor?: true
    prestacao?: true
    termino?: true
    estado?: true
    pendencia?: true
    progresso?: true
    proponente_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmprestimoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emprestimo to aggregate.
     */
    where?: EmprestimoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emprestimos to fetch.
     */
    orderBy?: EmprestimoOrderByWithRelationInput | EmprestimoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmprestimoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emprestimos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emprestimos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Emprestimos
    **/
    _count?: true | EmprestimoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmprestimoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmprestimoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmprestimoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmprestimoMaxAggregateInputType
  }

  export type GetEmprestimoAggregateType<T extends EmprestimoAggregateArgs> = {
        [P in keyof T & keyof AggregateEmprestimo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmprestimo[P]>
      : GetScalarType<T[P], AggregateEmprestimo[P]>
  }




  export type EmprestimoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmprestimoWhereInput
    orderBy?: EmprestimoOrderByWithAggregationInput | EmprestimoOrderByWithAggregationInput[]
    by: EmprestimoScalarFieldEnum[] | EmprestimoScalarFieldEnum
    having?: EmprestimoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmprestimoCountAggregateInputType | true
    _avg?: EmprestimoAvgAggregateInputType
    _sum?: EmprestimoSumAggregateInputType
    _min?: EmprestimoMinAggregateInputType
    _max?: EmprestimoMaxAggregateInputType
  }

  export type EmprestimoGroupByOutputType = {
    id: number
    valor: number
    juro_proponente: number
    taxa_investidor: number
    prestacao: number
    termino: Date
    estado: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    proponente_id: number
    createdAt: Date
    updatedAt: Date
    _count: EmprestimoCountAggregateOutputType | null
    _avg: EmprestimoAvgAggregateOutputType | null
    _sum: EmprestimoSumAggregateOutputType | null
    _min: EmprestimoMinAggregateOutputType | null
    _max: EmprestimoMaxAggregateOutputType | null
  }

  type GetEmprestimoGroupByPayload<T extends EmprestimoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmprestimoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmprestimoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmprestimoGroupByOutputType[P]>
            : GetScalarType<T[P], EmprestimoGroupByOutputType[P]>
        }
      >
    >


  export type EmprestimoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    juro_proponente?: boolean
    taxa_investidor?: boolean
    prestacao?: boolean
    termino?: boolean
    estado?: boolean
    pendencia?: boolean
    progresso?: boolean
    proponente_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    diversificacao?: boolean | Emprestimo$diversificacaoArgs<ExtArgs>
    solidario?: boolean | Emprestimo$solidarioArgs<ExtArgs>
    proponente?: boolean | ProponenteDefaultArgs<ExtArgs>
    _count?: boolean | EmprestimoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emprestimo"]>



  export type EmprestimoSelectScalar = {
    id?: boolean
    valor?: boolean
    juro_proponente?: boolean
    taxa_investidor?: boolean
    prestacao?: boolean
    termino?: boolean
    estado?: boolean
    pendencia?: boolean
    progresso?: boolean
    proponente_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmprestimoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "valor" | "juro_proponente" | "taxa_investidor" | "prestacao" | "termino" | "estado" | "pendencia" | "progresso" | "proponente_id" | "createdAt" | "updatedAt", ExtArgs["result"]["emprestimo"]>
  export type EmprestimoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diversificacao?: boolean | Emprestimo$diversificacaoArgs<ExtArgs>
    solidario?: boolean | Emprestimo$solidarioArgs<ExtArgs>
    proponente?: boolean | ProponenteDefaultArgs<ExtArgs>
    _count?: boolean | EmprestimoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmprestimoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Emprestimo"
    objects: {
      diversificacao: Prisma.$DiversificacaoPayload<ExtArgs>[]
      solidario: Prisma.$EmprestimoSolidarioPayload<ExtArgs>[]
      proponente: Prisma.$ProponentePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      valor: number
      juro_proponente: number
      taxa_investidor: number
      prestacao: number
      termino: Date
      estado: boolean
      pendencia: boolean
      progresso: $Enums.Progresso
      proponente_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emprestimo"]>
    composites: {}
  }

  type EmprestimoGetPayload<S extends boolean | null | undefined | EmprestimoDefaultArgs> = $Result.GetResult<Prisma.$EmprestimoPayload, S>

  type EmprestimoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmprestimoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmprestimoCountAggregateInputType | true
    }

  export interface EmprestimoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Emprestimo'], meta: { name: 'Emprestimo' } }
    /**
     * Find zero or one Emprestimo that matches the filter.
     * @param {EmprestimoFindUniqueArgs} args - Arguments to find a Emprestimo
     * @example
     * // Get one Emprestimo
     * const emprestimo = await prisma.emprestimo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmprestimoFindUniqueArgs>(args: SelectSubset<T, EmprestimoFindUniqueArgs<ExtArgs>>): Prisma__EmprestimoClient<$Result.GetResult<Prisma.$EmprestimoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Emprestimo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmprestimoFindUniqueOrThrowArgs} args - Arguments to find a Emprestimo
     * @example
     * // Get one Emprestimo
     * const emprestimo = await prisma.emprestimo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmprestimoFindUniqueOrThrowArgs>(args: SelectSubset<T, EmprestimoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmprestimoClient<$Result.GetResult<Prisma.$EmprestimoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emprestimo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprestimoFindFirstArgs} args - Arguments to find a Emprestimo
     * @example
     * // Get one Emprestimo
     * const emprestimo = await prisma.emprestimo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmprestimoFindFirstArgs>(args?: SelectSubset<T, EmprestimoFindFirstArgs<ExtArgs>>): Prisma__EmprestimoClient<$Result.GetResult<Prisma.$EmprestimoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emprestimo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprestimoFindFirstOrThrowArgs} args - Arguments to find a Emprestimo
     * @example
     * // Get one Emprestimo
     * const emprestimo = await prisma.emprestimo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmprestimoFindFirstOrThrowArgs>(args?: SelectSubset<T, EmprestimoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmprestimoClient<$Result.GetResult<Prisma.$EmprestimoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Emprestimos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprestimoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emprestimos
     * const emprestimos = await prisma.emprestimo.findMany()
     * 
     * // Get first 10 Emprestimos
     * const emprestimos = await prisma.emprestimo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emprestimoWithIdOnly = await prisma.emprestimo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmprestimoFindManyArgs>(args?: SelectSubset<T, EmprestimoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmprestimoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Emprestimo.
     * @param {EmprestimoCreateArgs} args - Arguments to create a Emprestimo.
     * @example
     * // Create one Emprestimo
     * const Emprestimo = await prisma.emprestimo.create({
     *   data: {
     *     // ... data to create a Emprestimo
     *   }
     * })
     * 
     */
    create<T extends EmprestimoCreateArgs>(args: SelectSubset<T, EmprestimoCreateArgs<ExtArgs>>): Prisma__EmprestimoClient<$Result.GetResult<Prisma.$EmprestimoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Emprestimos.
     * @param {EmprestimoCreateManyArgs} args - Arguments to create many Emprestimos.
     * @example
     * // Create many Emprestimos
     * const emprestimo = await prisma.emprestimo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmprestimoCreateManyArgs>(args?: SelectSubset<T, EmprestimoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Emprestimo.
     * @param {EmprestimoDeleteArgs} args - Arguments to delete one Emprestimo.
     * @example
     * // Delete one Emprestimo
     * const Emprestimo = await prisma.emprestimo.delete({
     *   where: {
     *     // ... filter to delete one Emprestimo
     *   }
     * })
     * 
     */
    delete<T extends EmprestimoDeleteArgs>(args: SelectSubset<T, EmprestimoDeleteArgs<ExtArgs>>): Prisma__EmprestimoClient<$Result.GetResult<Prisma.$EmprestimoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Emprestimo.
     * @param {EmprestimoUpdateArgs} args - Arguments to update one Emprestimo.
     * @example
     * // Update one Emprestimo
     * const emprestimo = await prisma.emprestimo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmprestimoUpdateArgs>(args: SelectSubset<T, EmprestimoUpdateArgs<ExtArgs>>): Prisma__EmprestimoClient<$Result.GetResult<Prisma.$EmprestimoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Emprestimos.
     * @param {EmprestimoDeleteManyArgs} args - Arguments to filter Emprestimos to delete.
     * @example
     * // Delete a few Emprestimos
     * const { count } = await prisma.emprestimo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmprestimoDeleteManyArgs>(args?: SelectSubset<T, EmprestimoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emprestimos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprestimoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emprestimos
     * const emprestimo = await prisma.emprestimo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmprestimoUpdateManyArgs>(args: SelectSubset<T, EmprestimoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Emprestimo.
     * @param {EmprestimoUpsertArgs} args - Arguments to update or create a Emprestimo.
     * @example
     * // Update or create a Emprestimo
     * const emprestimo = await prisma.emprestimo.upsert({
     *   create: {
     *     // ... data to create a Emprestimo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Emprestimo we want to update
     *   }
     * })
     */
    upsert<T extends EmprestimoUpsertArgs>(args: SelectSubset<T, EmprestimoUpsertArgs<ExtArgs>>): Prisma__EmprestimoClient<$Result.GetResult<Prisma.$EmprestimoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Emprestimos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprestimoCountArgs} args - Arguments to filter Emprestimos to count.
     * @example
     * // Count the number of Emprestimos
     * const count = await prisma.emprestimo.count({
     *   where: {
     *     // ... the filter for the Emprestimos we want to count
     *   }
     * })
    **/
    count<T extends EmprestimoCountArgs>(
      args?: Subset<T, EmprestimoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmprestimoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Emprestimo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprestimoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmprestimoAggregateArgs>(args: Subset<T, EmprestimoAggregateArgs>): Prisma.PrismaPromise<GetEmprestimoAggregateType<T>>

    /**
     * Group by Emprestimo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprestimoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmprestimoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmprestimoGroupByArgs['orderBy'] }
        : { orderBy?: EmprestimoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmprestimoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmprestimoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Emprestimo model
   */
  readonly fields: EmprestimoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Emprestimo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmprestimoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    diversificacao<T extends Emprestimo$diversificacaoArgs<ExtArgs> = {}>(args?: Subset<T, Emprestimo$diversificacaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiversificacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    solidario<T extends Emprestimo$solidarioArgs<ExtArgs> = {}>(args?: Subset<T, Emprestimo$solidarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmprestimoSolidarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proponente<T extends ProponenteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProponenteDefaultArgs<ExtArgs>>): Prisma__ProponenteClient<$Result.GetResult<Prisma.$ProponentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Emprestimo model
   */
  interface EmprestimoFieldRefs {
    readonly id: FieldRef<"Emprestimo", 'Int'>
    readonly valor: FieldRef<"Emprestimo", 'Float'>
    readonly juro_proponente: FieldRef<"Emprestimo", 'Int'>
    readonly taxa_investidor: FieldRef<"Emprestimo", 'Int'>
    readonly prestacao: FieldRef<"Emprestimo", 'Int'>
    readonly termino: FieldRef<"Emprestimo", 'DateTime'>
    readonly estado: FieldRef<"Emprestimo", 'Boolean'>
    readonly pendencia: FieldRef<"Emprestimo", 'Boolean'>
    readonly progresso: FieldRef<"Emprestimo", 'Progresso'>
    readonly proponente_id: FieldRef<"Emprestimo", 'Int'>
    readonly createdAt: FieldRef<"Emprestimo", 'DateTime'>
    readonly updatedAt: FieldRef<"Emprestimo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Emprestimo findUnique
   */
  export type EmprestimoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprestimo
     */
    select?: EmprestimoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprestimo
     */
    omit?: EmprestimoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoInclude<ExtArgs> | null
    /**
     * Filter, which Emprestimo to fetch.
     */
    where: EmprestimoWhereUniqueInput
  }

  /**
   * Emprestimo findUniqueOrThrow
   */
  export type EmprestimoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprestimo
     */
    select?: EmprestimoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprestimo
     */
    omit?: EmprestimoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoInclude<ExtArgs> | null
    /**
     * Filter, which Emprestimo to fetch.
     */
    where: EmprestimoWhereUniqueInput
  }

  /**
   * Emprestimo findFirst
   */
  export type EmprestimoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprestimo
     */
    select?: EmprestimoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprestimo
     */
    omit?: EmprestimoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoInclude<ExtArgs> | null
    /**
     * Filter, which Emprestimo to fetch.
     */
    where?: EmprestimoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emprestimos to fetch.
     */
    orderBy?: EmprestimoOrderByWithRelationInput | EmprestimoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emprestimos.
     */
    cursor?: EmprestimoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emprestimos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emprestimos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emprestimos.
     */
    distinct?: EmprestimoScalarFieldEnum | EmprestimoScalarFieldEnum[]
  }

  /**
   * Emprestimo findFirstOrThrow
   */
  export type EmprestimoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprestimo
     */
    select?: EmprestimoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprestimo
     */
    omit?: EmprestimoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoInclude<ExtArgs> | null
    /**
     * Filter, which Emprestimo to fetch.
     */
    where?: EmprestimoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emprestimos to fetch.
     */
    orderBy?: EmprestimoOrderByWithRelationInput | EmprestimoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emprestimos.
     */
    cursor?: EmprestimoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emprestimos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emprestimos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emprestimos.
     */
    distinct?: EmprestimoScalarFieldEnum | EmprestimoScalarFieldEnum[]
  }

  /**
   * Emprestimo findMany
   */
  export type EmprestimoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprestimo
     */
    select?: EmprestimoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprestimo
     */
    omit?: EmprestimoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoInclude<ExtArgs> | null
    /**
     * Filter, which Emprestimos to fetch.
     */
    where?: EmprestimoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emprestimos to fetch.
     */
    orderBy?: EmprestimoOrderByWithRelationInput | EmprestimoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Emprestimos.
     */
    cursor?: EmprestimoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emprestimos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emprestimos.
     */
    skip?: number
    distinct?: EmprestimoScalarFieldEnum | EmprestimoScalarFieldEnum[]
  }

  /**
   * Emprestimo create
   */
  export type EmprestimoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprestimo
     */
    select?: EmprestimoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprestimo
     */
    omit?: EmprestimoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoInclude<ExtArgs> | null
    /**
     * The data needed to create a Emprestimo.
     */
    data: XOR<EmprestimoCreateInput, EmprestimoUncheckedCreateInput>
  }

  /**
   * Emprestimo createMany
   */
  export type EmprestimoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Emprestimos.
     */
    data: EmprestimoCreateManyInput | EmprestimoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Emprestimo update
   */
  export type EmprestimoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprestimo
     */
    select?: EmprestimoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprestimo
     */
    omit?: EmprestimoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoInclude<ExtArgs> | null
    /**
     * The data needed to update a Emprestimo.
     */
    data: XOR<EmprestimoUpdateInput, EmprestimoUncheckedUpdateInput>
    /**
     * Choose, which Emprestimo to update.
     */
    where: EmprestimoWhereUniqueInput
  }

  /**
   * Emprestimo updateMany
   */
  export type EmprestimoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Emprestimos.
     */
    data: XOR<EmprestimoUpdateManyMutationInput, EmprestimoUncheckedUpdateManyInput>
    /**
     * Filter which Emprestimos to update
     */
    where?: EmprestimoWhereInput
    /**
     * Limit how many Emprestimos to update.
     */
    limit?: number
  }

  /**
   * Emprestimo upsert
   */
  export type EmprestimoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprestimo
     */
    select?: EmprestimoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprestimo
     */
    omit?: EmprestimoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoInclude<ExtArgs> | null
    /**
     * The filter to search for the Emprestimo to update in case it exists.
     */
    where: EmprestimoWhereUniqueInput
    /**
     * In case the Emprestimo found by the `where` argument doesn't exist, create a new Emprestimo with this data.
     */
    create: XOR<EmprestimoCreateInput, EmprestimoUncheckedCreateInput>
    /**
     * In case the Emprestimo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmprestimoUpdateInput, EmprestimoUncheckedUpdateInput>
  }

  /**
   * Emprestimo delete
   */
  export type EmprestimoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprestimo
     */
    select?: EmprestimoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprestimo
     */
    omit?: EmprestimoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoInclude<ExtArgs> | null
    /**
     * Filter which Emprestimo to delete.
     */
    where: EmprestimoWhereUniqueInput
  }

  /**
   * Emprestimo deleteMany
   */
  export type EmprestimoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emprestimos to delete
     */
    where?: EmprestimoWhereInput
    /**
     * Limit how many Emprestimos to delete.
     */
    limit?: number
  }

  /**
   * Emprestimo.diversificacao
   */
  export type Emprestimo$diversificacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversificacao
     */
    select?: DiversificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diversificacao
     */
    omit?: DiversificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversificacaoInclude<ExtArgs> | null
    where?: DiversificacaoWhereInput
    orderBy?: DiversificacaoOrderByWithRelationInput | DiversificacaoOrderByWithRelationInput[]
    cursor?: DiversificacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiversificacaoScalarFieldEnum | DiversificacaoScalarFieldEnum[]
  }

  /**
   * Emprestimo.solidario
   */
  export type Emprestimo$solidarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmprestimoSolidario
     */
    select?: EmprestimoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmprestimoSolidario
     */
    omit?: EmprestimoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoSolidarioInclude<ExtArgs> | null
    where?: EmprestimoSolidarioWhereInput
    orderBy?: EmprestimoSolidarioOrderByWithRelationInput | EmprestimoSolidarioOrderByWithRelationInput[]
    cursor?: EmprestimoSolidarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmprestimoSolidarioScalarFieldEnum | EmprestimoSolidarioScalarFieldEnum[]
  }

  /**
   * Emprestimo without action
   */
  export type EmprestimoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprestimo
     */
    select?: EmprestimoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprestimo
     */
    omit?: EmprestimoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoInclude<ExtArgs> | null
  }


  /**
   * Model EmprestimoSolidario
   */

  export type AggregateEmprestimoSolidario = {
    _count: EmprestimoSolidarioCountAggregateOutputType | null
    _avg: EmprestimoSolidarioAvgAggregateOutputType | null
    _sum: EmprestimoSolidarioSumAggregateOutputType | null
    _min: EmprestimoSolidarioMinAggregateOutputType | null
    _max: EmprestimoSolidarioMaxAggregateOutputType | null
  }

  export type EmprestimoSolidarioAvgAggregateOutputType = {
    solidario_id: number | null
    emprestimo_id: number | null
  }

  export type EmprestimoSolidarioSumAggregateOutputType = {
    solidario_id: number | null
    emprestimo_id: number | null
  }

  export type EmprestimoSolidarioMinAggregateOutputType = {
    estado: boolean | null
    solidario_id: number | null
    emprestimo_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmprestimoSolidarioMaxAggregateOutputType = {
    estado: boolean | null
    solidario_id: number | null
    emprestimo_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmprestimoSolidarioCountAggregateOutputType = {
    estado: number
    solidario_id: number
    emprestimo_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmprestimoSolidarioAvgAggregateInputType = {
    solidario_id?: true
    emprestimo_id?: true
  }

  export type EmprestimoSolidarioSumAggregateInputType = {
    solidario_id?: true
    emprestimo_id?: true
  }

  export type EmprestimoSolidarioMinAggregateInputType = {
    estado?: true
    solidario_id?: true
    emprestimo_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmprestimoSolidarioMaxAggregateInputType = {
    estado?: true
    solidario_id?: true
    emprestimo_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmprestimoSolidarioCountAggregateInputType = {
    estado?: true
    solidario_id?: true
    emprestimo_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmprestimoSolidarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmprestimoSolidario to aggregate.
     */
    where?: EmprestimoSolidarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmprestimoSolidarios to fetch.
     */
    orderBy?: EmprestimoSolidarioOrderByWithRelationInput | EmprestimoSolidarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmprestimoSolidarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmprestimoSolidarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmprestimoSolidarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmprestimoSolidarios
    **/
    _count?: true | EmprestimoSolidarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmprestimoSolidarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmprestimoSolidarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmprestimoSolidarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmprestimoSolidarioMaxAggregateInputType
  }

  export type GetEmprestimoSolidarioAggregateType<T extends EmprestimoSolidarioAggregateArgs> = {
        [P in keyof T & keyof AggregateEmprestimoSolidario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmprestimoSolidario[P]>
      : GetScalarType<T[P], AggregateEmprestimoSolidario[P]>
  }




  export type EmprestimoSolidarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmprestimoSolidarioWhereInput
    orderBy?: EmprestimoSolidarioOrderByWithAggregationInput | EmprestimoSolidarioOrderByWithAggregationInput[]
    by: EmprestimoSolidarioScalarFieldEnum[] | EmprestimoSolidarioScalarFieldEnum
    having?: EmprestimoSolidarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmprestimoSolidarioCountAggregateInputType | true
    _avg?: EmprestimoSolidarioAvgAggregateInputType
    _sum?: EmprestimoSolidarioSumAggregateInputType
    _min?: EmprestimoSolidarioMinAggregateInputType
    _max?: EmprestimoSolidarioMaxAggregateInputType
  }

  export type EmprestimoSolidarioGroupByOutputType = {
    estado: boolean
    solidario_id: number
    emprestimo_id: number
    createdAt: Date
    updatedAt: Date
    _count: EmprestimoSolidarioCountAggregateOutputType | null
    _avg: EmprestimoSolidarioAvgAggregateOutputType | null
    _sum: EmprestimoSolidarioSumAggregateOutputType | null
    _min: EmprestimoSolidarioMinAggregateOutputType | null
    _max: EmprestimoSolidarioMaxAggregateOutputType | null
  }

  type GetEmprestimoSolidarioGroupByPayload<T extends EmprestimoSolidarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmprestimoSolidarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmprestimoSolidarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmprestimoSolidarioGroupByOutputType[P]>
            : GetScalarType<T[P], EmprestimoSolidarioGroupByOutputType[P]>
        }
      >
    >


  export type EmprestimoSolidarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    estado?: boolean
    solidario_id?: boolean
    emprestimo_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    solidario?: boolean | SolidarioDefaultArgs<ExtArgs>
    emprestimo?: boolean | EmprestimoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emprestimoSolidario"]>



  export type EmprestimoSolidarioSelectScalar = {
    estado?: boolean
    solidario_id?: boolean
    emprestimo_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmprestimoSolidarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"estado" | "solidario_id" | "emprestimo_id" | "createdAt" | "updatedAt", ExtArgs["result"]["emprestimoSolidario"]>
  export type EmprestimoSolidarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solidario?: boolean | SolidarioDefaultArgs<ExtArgs>
    emprestimo?: boolean | EmprestimoDefaultArgs<ExtArgs>
  }

  export type $EmprestimoSolidarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmprestimoSolidario"
    objects: {
      solidario: Prisma.$SolidarioPayload<ExtArgs>
      emprestimo: Prisma.$EmprestimoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      estado: boolean
      solidario_id: number
      emprestimo_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emprestimoSolidario"]>
    composites: {}
  }

  type EmprestimoSolidarioGetPayload<S extends boolean | null | undefined | EmprestimoSolidarioDefaultArgs> = $Result.GetResult<Prisma.$EmprestimoSolidarioPayload, S>

  type EmprestimoSolidarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmprestimoSolidarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmprestimoSolidarioCountAggregateInputType | true
    }

  export interface EmprestimoSolidarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmprestimoSolidario'], meta: { name: 'EmprestimoSolidario' } }
    /**
     * Find zero or one EmprestimoSolidario that matches the filter.
     * @param {EmprestimoSolidarioFindUniqueArgs} args - Arguments to find a EmprestimoSolidario
     * @example
     * // Get one EmprestimoSolidario
     * const emprestimoSolidario = await prisma.emprestimoSolidario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmprestimoSolidarioFindUniqueArgs>(args: SelectSubset<T, EmprestimoSolidarioFindUniqueArgs<ExtArgs>>): Prisma__EmprestimoSolidarioClient<$Result.GetResult<Prisma.$EmprestimoSolidarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmprestimoSolidario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmprestimoSolidarioFindUniqueOrThrowArgs} args - Arguments to find a EmprestimoSolidario
     * @example
     * // Get one EmprestimoSolidario
     * const emprestimoSolidario = await prisma.emprestimoSolidario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmprestimoSolidarioFindUniqueOrThrowArgs>(args: SelectSubset<T, EmprestimoSolidarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmprestimoSolidarioClient<$Result.GetResult<Prisma.$EmprestimoSolidarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmprestimoSolidario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprestimoSolidarioFindFirstArgs} args - Arguments to find a EmprestimoSolidario
     * @example
     * // Get one EmprestimoSolidario
     * const emprestimoSolidario = await prisma.emprestimoSolidario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmprestimoSolidarioFindFirstArgs>(args?: SelectSubset<T, EmprestimoSolidarioFindFirstArgs<ExtArgs>>): Prisma__EmprestimoSolidarioClient<$Result.GetResult<Prisma.$EmprestimoSolidarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmprestimoSolidario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprestimoSolidarioFindFirstOrThrowArgs} args - Arguments to find a EmprestimoSolidario
     * @example
     * // Get one EmprestimoSolidario
     * const emprestimoSolidario = await prisma.emprestimoSolidario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmprestimoSolidarioFindFirstOrThrowArgs>(args?: SelectSubset<T, EmprestimoSolidarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmprestimoSolidarioClient<$Result.GetResult<Prisma.$EmprestimoSolidarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmprestimoSolidarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprestimoSolidarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmprestimoSolidarios
     * const emprestimoSolidarios = await prisma.emprestimoSolidario.findMany()
     * 
     * // Get first 10 EmprestimoSolidarios
     * const emprestimoSolidarios = await prisma.emprestimoSolidario.findMany({ take: 10 })
     * 
     * // Only select the `estado`
     * const emprestimoSolidarioWithEstadoOnly = await prisma.emprestimoSolidario.findMany({ select: { estado: true } })
     * 
     */
    findMany<T extends EmprestimoSolidarioFindManyArgs>(args?: SelectSubset<T, EmprestimoSolidarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmprestimoSolidarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmprestimoSolidario.
     * @param {EmprestimoSolidarioCreateArgs} args - Arguments to create a EmprestimoSolidario.
     * @example
     * // Create one EmprestimoSolidario
     * const EmprestimoSolidario = await prisma.emprestimoSolidario.create({
     *   data: {
     *     // ... data to create a EmprestimoSolidario
     *   }
     * })
     * 
     */
    create<T extends EmprestimoSolidarioCreateArgs>(args: SelectSubset<T, EmprestimoSolidarioCreateArgs<ExtArgs>>): Prisma__EmprestimoSolidarioClient<$Result.GetResult<Prisma.$EmprestimoSolidarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmprestimoSolidarios.
     * @param {EmprestimoSolidarioCreateManyArgs} args - Arguments to create many EmprestimoSolidarios.
     * @example
     * // Create many EmprestimoSolidarios
     * const emprestimoSolidario = await prisma.emprestimoSolidario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmprestimoSolidarioCreateManyArgs>(args?: SelectSubset<T, EmprestimoSolidarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmprestimoSolidario.
     * @param {EmprestimoSolidarioDeleteArgs} args - Arguments to delete one EmprestimoSolidario.
     * @example
     * // Delete one EmprestimoSolidario
     * const EmprestimoSolidario = await prisma.emprestimoSolidario.delete({
     *   where: {
     *     // ... filter to delete one EmprestimoSolidario
     *   }
     * })
     * 
     */
    delete<T extends EmprestimoSolidarioDeleteArgs>(args: SelectSubset<T, EmprestimoSolidarioDeleteArgs<ExtArgs>>): Prisma__EmprestimoSolidarioClient<$Result.GetResult<Prisma.$EmprestimoSolidarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmprestimoSolidario.
     * @param {EmprestimoSolidarioUpdateArgs} args - Arguments to update one EmprestimoSolidario.
     * @example
     * // Update one EmprestimoSolidario
     * const emprestimoSolidario = await prisma.emprestimoSolidario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmprestimoSolidarioUpdateArgs>(args: SelectSubset<T, EmprestimoSolidarioUpdateArgs<ExtArgs>>): Prisma__EmprestimoSolidarioClient<$Result.GetResult<Prisma.$EmprestimoSolidarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmprestimoSolidarios.
     * @param {EmprestimoSolidarioDeleteManyArgs} args - Arguments to filter EmprestimoSolidarios to delete.
     * @example
     * // Delete a few EmprestimoSolidarios
     * const { count } = await prisma.emprestimoSolidario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmprestimoSolidarioDeleteManyArgs>(args?: SelectSubset<T, EmprestimoSolidarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmprestimoSolidarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprestimoSolidarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmprestimoSolidarios
     * const emprestimoSolidario = await prisma.emprestimoSolidario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmprestimoSolidarioUpdateManyArgs>(args: SelectSubset<T, EmprestimoSolidarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmprestimoSolidario.
     * @param {EmprestimoSolidarioUpsertArgs} args - Arguments to update or create a EmprestimoSolidario.
     * @example
     * // Update or create a EmprestimoSolidario
     * const emprestimoSolidario = await prisma.emprestimoSolidario.upsert({
     *   create: {
     *     // ... data to create a EmprestimoSolidario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmprestimoSolidario we want to update
     *   }
     * })
     */
    upsert<T extends EmprestimoSolidarioUpsertArgs>(args: SelectSubset<T, EmprestimoSolidarioUpsertArgs<ExtArgs>>): Prisma__EmprestimoSolidarioClient<$Result.GetResult<Prisma.$EmprestimoSolidarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmprestimoSolidarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprestimoSolidarioCountArgs} args - Arguments to filter EmprestimoSolidarios to count.
     * @example
     * // Count the number of EmprestimoSolidarios
     * const count = await prisma.emprestimoSolidario.count({
     *   where: {
     *     // ... the filter for the EmprestimoSolidarios we want to count
     *   }
     * })
    **/
    count<T extends EmprestimoSolidarioCountArgs>(
      args?: Subset<T, EmprestimoSolidarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmprestimoSolidarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmprestimoSolidario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprestimoSolidarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmprestimoSolidarioAggregateArgs>(args: Subset<T, EmprestimoSolidarioAggregateArgs>): Prisma.PrismaPromise<GetEmprestimoSolidarioAggregateType<T>>

    /**
     * Group by EmprestimoSolidario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprestimoSolidarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmprestimoSolidarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmprestimoSolidarioGroupByArgs['orderBy'] }
        : { orderBy?: EmprestimoSolidarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmprestimoSolidarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmprestimoSolidarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmprestimoSolidario model
   */
  readonly fields: EmprestimoSolidarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmprestimoSolidario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmprestimoSolidarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    solidario<T extends SolidarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SolidarioDefaultArgs<ExtArgs>>): Prisma__SolidarioClient<$Result.GetResult<Prisma.$SolidarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    emprestimo<T extends EmprestimoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmprestimoDefaultArgs<ExtArgs>>): Prisma__EmprestimoClient<$Result.GetResult<Prisma.$EmprestimoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmprestimoSolidario model
   */
  interface EmprestimoSolidarioFieldRefs {
    readonly estado: FieldRef<"EmprestimoSolidario", 'Boolean'>
    readonly solidario_id: FieldRef<"EmprestimoSolidario", 'Int'>
    readonly emprestimo_id: FieldRef<"EmprestimoSolidario", 'Int'>
    readonly createdAt: FieldRef<"EmprestimoSolidario", 'DateTime'>
    readonly updatedAt: FieldRef<"EmprestimoSolidario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmprestimoSolidario findUnique
   */
  export type EmprestimoSolidarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmprestimoSolidario
     */
    select?: EmprestimoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmprestimoSolidario
     */
    omit?: EmprestimoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoSolidarioInclude<ExtArgs> | null
    /**
     * Filter, which EmprestimoSolidario to fetch.
     */
    where: EmprestimoSolidarioWhereUniqueInput
  }

  /**
   * EmprestimoSolidario findUniqueOrThrow
   */
  export type EmprestimoSolidarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmprestimoSolidario
     */
    select?: EmprestimoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmprestimoSolidario
     */
    omit?: EmprestimoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoSolidarioInclude<ExtArgs> | null
    /**
     * Filter, which EmprestimoSolidario to fetch.
     */
    where: EmprestimoSolidarioWhereUniqueInput
  }

  /**
   * EmprestimoSolidario findFirst
   */
  export type EmprestimoSolidarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmprestimoSolidario
     */
    select?: EmprestimoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmprestimoSolidario
     */
    omit?: EmprestimoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoSolidarioInclude<ExtArgs> | null
    /**
     * Filter, which EmprestimoSolidario to fetch.
     */
    where?: EmprestimoSolidarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmprestimoSolidarios to fetch.
     */
    orderBy?: EmprestimoSolidarioOrderByWithRelationInput | EmprestimoSolidarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmprestimoSolidarios.
     */
    cursor?: EmprestimoSolidarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmprestimoSolidarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmprestimoSolidarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmprestimoSolidarios.
     */
    distinct?: EmprestimoSolidarioScalarFieldEnum | EmprestimoSolidarioScalarFieldEnum[]
  }

  /**
   * EmprestimoSolidario findFirstOrThrow
   */
  export type EmprestimoSolidarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmprestimoSolidario
     */
    select?: EmprestimoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmprestimoSolidario
     */
    omit?: EmprestimoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoSolidarioInclude<ExtArgs> | null
    /**
     * Filter, which EmprestimoSolidario to fetch.
     */
    where?: EmprestimoSolidarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmprestimoSolidarios to fetch.
     */
    orderBy?: EmprestimoSolidarioOrderByWithRelationInput | EmprestimoSolidarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmprestimoSolidarios.
     */
    cursor?: EmprestimoSolidarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmprestimoSolidarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmprestimoSolidarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmprestimoSolidarios.
     */
    distinct?: EmprestimoSolidarioScalarFieldEnum | EmprestimoSolidarioScalarFieldEnum[]
  }

  /**
   * EmprestimoSolidario findMany
   */
  export type EmprestimoSolidarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmprestimoSolidario
     */
    select?: EmprestimoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmprestimoSolidario
     */
    omit?: EmprestimoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoSolidarioInclude<ExtArgs> | null
    /**
     * Filter, which EmprestimoSolidarios to fetch.
     */
    where?: EmprestimoSolidarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmprestimoSolidarios to fetch.
     */
    orderBy?: EmprestimoSolidarioOrderByWithRelationInput | EmprestimoSolidarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmprestimoSolidarios.
     */
    cursor?: EmprestimoSolidarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmprestimoSolidarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmprestimoSolidarios.
     */
    skip?: number
    distinct?: EmprestimoSolidarioScalarFieldEnum | EmprestimoSolidarioScalarFieldEnum[]
  }

  /**
   * EmprestimoSolidario create
   */
  export type EmprestimoSolidarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmprestimoSolidario
     */
    select?: EmprestimoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmprestimoSolidario
     */
    omit?: EmprestimoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoSolidarioInclude<ExtArgs> | null
    /**
     * The data needed to create a EmprestimoSolidario.
     */
    data: XOR<EmprestimoSolidarioCreateInput, EmprestimoSolidarioUncheckedCreateInput>
  }

  /**
   * EmprestimoSolidario createMany
   */
  export type EmprestimoSolidarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmprestimoSolidarios.
     */
    data: EmprestimoSolidarioCreateManyInput | EmprestimoSolidarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmprestimoSolidario update
   */
  export type EmprestimoSolidarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmprestimoSolidario
     */
    select?: EmprestimoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmprestimoSolidario
     */
    omit?: EmprestimoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoSolidarioInclude<ExtArgs> | null
    /**
     * The data needed to update a EmprestimoSolidario.
     */
    data: XOR<EmprestimoSolidarioUpdateInput, EmprestimoSolidarioUncheckedUpdateInput>
    /**
     * Choose, which EmprestimoSolidario to update.
     */
    where: EmprestimoSolidarioWhereUniqueInput
  }

  /**
   * EmprestimoSolidario updateMany
   */
  export type EmprestimoSolidarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmprestimoSolidarios.
     */
    data: XOR<EmprestimoSolidarioUpdateManyMutationInput, EmprestimoSolidarioUncheckedUpdateManyInput>
    /**
     * Filter which EmprestimoSolidarios to update
     */
    where?: EmprestimoSolidarioWhereInput
    /**
     * Limit how many EmprestimoSolidarios to update.
     */
    limit?: number
  }

  /**
   * EmprestimoSolidario upsert
   */
  export type EmprestimoSolidarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmprestimoSolidario
     */
    select?: EmprestimoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmprestimoSolidario
     */
    omit?: EmprestimoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoSolidarioInclude<ExtArgs> | null
    /**
     * The filter to search for the EmprestimoSolidario to update in case it exists.
     */
    where: EmprestimoSolidarioWhereUniqueInput
    /**
     * In case the EmprestimoSolidario found by the `where` argument doesn't exist, create a new EmprestimoSolidario with this data.
     */
    create: XOR<EmprestimoSolidarioCreateInput, EmprestimoSolidarioUncheckedCreateInput>
    /**
     * In case the EmprestimoSolidario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmprestimoSolidarioUpdateInput, EmprestimoSolidarioUncheckedUpdateInput>
  }

  /**
   * EmprestimoSolidario delete
   */
  export type EmprestimoSolidarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmprestimoSolidario
     */
    select?: EmprestimoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmprestimoSolidario
     */
    omit?: EmprestimoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoSolidarioInclude<ExtArgs> | null
    /**
     * Filter which EmprestimoSolidario to delete.
     */
    where: EmprestimoSolidarioWhereUniqueInput
  }

  /**
   * EmprestimoSolidario deleteMany
   */
  export type EmprestimoSolidarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmprestimoSolidarios to delete
     */
    where?: EmprestimoSolidarioWhereInput
    /**
     * Limit how many EmprestimoSolidarios to delete.
     */
    limit?: number
  }

  /**
   * EmprestimoSolidario without action
   */
  export type EmprestimoSolidarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmprestimoSolidario
     */
    select?: EmprestimoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmprestimoSolidario
     */
    omit?: EmprestimoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprestimoSolidarioInclude<ExtArgs> | null
  }


  /**
   * Model CreditoSolidario
   */

  export type AggregateCreditoSolidario = {
    _count: CreditoSolidarioCountAggregateOutputType | null
    _avg: CreditoSolidarioAvgAggregateOutputType | null
    _sum: CreditoSolidarioSumAggregateOutputType | null
    _min: CreditoSolidarioMinAggregateOutputType | null
    _max: CreditoSolidarioMaxAggregateOutputType | null
  }

  export type CreditoSolidarioAvgAggregateOutputType = {
    solidario_id: number | null
    credito_id: number | null
  }

  export type CreditoSolidarioSumAggregateOutputType = {
    solidario_id: number | null
    credito_id: number | null
  }

  export type CreditoSolidarioMinAggregateOutputType = {
    estado: boolean | null
    solidario_id: number | null
    credito_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreditoSolidarioMaxAggregateOutputType = {
    estado: boolean | null
    solidario_id: number | null
    credito_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreditoSolidarioCountAggregateOutputType = {
    estado: number
    solidario_id: number
    credito_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CreditoSolidarioAvgAggregateInputType = {
    solidario_id?: true
    credito_id?: true
  }

  export type CreditoSolidarioSumAggregateInputType = {
    solidario_id?: true
    credito_id?: true
  }

  export type CreditoSolidarioMinAggregateInputType = {
    estado?: true
    solidario_id?: true
    credito_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreditoSolidarioMaxAggregateInputType = {
    estado?: true
    solidario_id?: true
    credito_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreditoSolidarioCountAggregateInputType = {
    estado?: true
    solidario_id?: true
    credito_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CreditoSolidarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditoSolidario to aggregate.
     */
    where?: CreditoSolidarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditoSolidarios to fetch.
     */
    orderBy?: CreditoSolidarioOrderByWithRelationInput | CreditoSolidarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditoSolidarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditoSolidarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditoSolidarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditoSolidarios
    **/
    _count?: true | CreditoSolidarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditoSolidarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditoSolidarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditoSolidarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditoSolidarioMaxAggregateInputType
  }

  export type GetCreditoSolidarioAggregateType<T extends CreditoSolidarioAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditoSolidario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditoSolidario[P]>
      : GetScalarType<T[P], AggregateCreditoSolidario[P]>
  }




  export type CreditoSolidarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditoSolidarioWhereInput
    orderBy?: CreditoSolidarioOrderByWithAggregationInput | CreditoSolidarioOrderByWithAggregationInput[]
    by: CreditoSolidarioScalarFieldEnum[] | CreditoSolidarioScalarFieldEnum
    having?: CreditoSolidarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditoSolidarioCountAggregateInputType | true
    _avg?: CreditoSolidarioAvgAggregateInputType
    _sum?: CreditoSolidarioSumAggregateInputType
    _min?: CreditoSolidarioMinAggregateInputType
    _max?: CreditoSolidarioMaxAggregateInputType
  }

  export type CreditoSolidarioGroupByOutputType = {
    estado: boolean
    solidario_id: number
    credito_id: number
    createdAt: Date
    updatedAt: Date
    _count: CreditoSolidarioCountAggregateOutputType | null
    _avg: CreditoSolidarioAvgAggregateOutputType | null
    _sum: CreditoSolidarioSumAggregateOutputType | null
    _min: CreditoSolidarioMinAggregateOutputType | null
    _max: CreditoSolidarioMaxAggregateOutputType | null
  }

  type GetCreditoSolidarioGroupByPayload<T extends CreditoSolidarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditoSolidarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditoSolidarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditoSolidarioGroupByOutputType[P]>
            : GetScalarType<T[P], CreditoSolidarioGroupByOutputType[P]>
        }
      >
    >


  export type CreditoSolidarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    estado?: boolean
    solidario_id?: boolean
    credito_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    solidario?: boolean | SolidarioDefaultArgs<ExtArgs>
    credito?: boolean | CreditoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditoSolidario"]>



  export type CreditoSolidarioSelectScalar = {
    estado?: boolean
    solidario_id?: boolean
    credito_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CreditoSolidarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"estado" | "solidario_id" | "credito_id" | "createdAt" | "updatedAt", ExtArgs["result"]["creditoSolidario"]>
  export type CreditoSolidarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solidario?: boolean | SolidarioDefaultArgs<ExtArgs>
    credito?: boolean | CreditoDefaultArgs<ExtArgs>
  }

  export type $CreditoSolidarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditoSolidario"
    objects: {
      solidario: Prisma.$SolidarioPayload<ExtArgs>
      credito: Prisma.$CreditoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      estado: boolean
      solidario_id: number
      credito_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["creditoSolidario"]>
    composites: {}
  }

  type CreditoSolidarioGetPayload<S extends boolean | null | undefined | CreditoSolidarioDefaultArgs> = $Result.GetResult<Prisma.$CreditoSolidarioPayload, S>

  type CreditoSolidarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditoSolidarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditoSolidarioCountAggregateInputType | true
    }

  export interface CreditoSolidarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditoSolidario'], meta: { name: 'CreditoSolidario' } }
    /**
     * Find zero or one CreditoSolidario that matches the filter.
     * @param {CreditoSolidarioFindUniqueArgs} args - Arguments to find a CreditoSolidario
     * @example
     * // Get one CreditoSolidario
     * const creditoSolidario = await prisma.creditoSolidario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditoSolidarioFindUniqueArgs>(args: SelectSubset<T, CreditoSolidarioFindUniqueArgs<ExtArgs>>): Prisma__CreditoSolidarioClient<$Result.GetResult<Prisma.$CreditoSolidarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditoSolidario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditoSolidarioFindUniqueOrThrowArgs} args - Arguments to find a CreditoSolidario
     * @example
     * // Get one CreditoSolidario
     * const creditoSolidario = await prisma.creditoSolidario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditoSolidarioFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditoSolidarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditoSolidarioClient<$Result.GetResult<Prisma.$CreditoSolidarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditoSolidario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditoSolidarioFindFirstArgs} args - Arguments to find a CreditoSolidario
     * @example
     * // Get one CreditoSolidario
     * const creditoSolidario = await prisma.creditoSolidario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditoSolidarioFindFirstArgs>(args?: SelectSubset<T, CreditoSolidarioFindFirstArgs<ExtArgs>>): Prisma__CreditoSolidarioClient<$Result.GetResult<Prisma.$CreditoSolidarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditoSolidario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditoSolidarioFindFirstOrThrowArgs} args - Arguments to find a CreditoSolidario
     * @example
     * // Get one CreditoSolidario
     * const creditoSolidario = await prisma.creditoSolidario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditoSolidarioFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditoSolidarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditoSolidarioClient<$Result.GetResult<Prisma.$CreditoSolidarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditoSolidarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditoSolidarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditoSolidarios
     * const creditoSolidarios = await prisma.creditoSolidario.findMany()
     * 
     * // Get first 10 CreditoSolidarios
     * const creditoSolidarios = await prisma.creditoSolidario.findMany({ take: 10 })
     * 
     * // Only select the `estado`
     * const creditoSolidarioWithEstadoOnly = await prisma.creditoSolidario.findMany({ select: { estado: true } })
     * 
     */
    findMany<T extends CreditoSolidarioFindManyArgs>(args?: SelectSubset<T, CreditoSolidarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditoSolidarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditoSolidario.
     * @param {CreditoSolidarioCreateArgs} args - Arguments to create a CreditoSolidario.
     * @example
     * // Create one CreditoSolidario
     * const CreditoSolidario = await prisma.creditoSolidario.create({
     *   data: {
     *     // ... data to create a CreditoSolidario
     *   }
     * })
     * 
     */
    create<T extends CreditoSolidarioCreateArgs>(args: SelectSubset<T, CreditoSolidarioCreateArgs<ExtArgs>>): Prisma__CreditoSolidarioClient<$Result.GetResult<Prisma.$CreditoSolidarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditoSolidarios.
     * @param {CreditoSolidarioCreateManyArgs} args - Arguments to create many CreditoSolidarios.
     * @example
     * // Create many CreditoSolidarios
     * const creditoSolidario = await prisma.creditoSolidario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditoSolidarioCreateManyArgs>(args?: SelectSubset<T, CreditoSolidarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CreditoSolidario.
     * @param {CreditoSolidarioDeleteArgs} args - Arguments to delete one CreditoSolidario.
     * @example
     * // Delete one CreditoSolidario
     * const CreditoSolidario = await prisma.creditoSolidario.delete({
     *   where: {
     *     // ... filter to delete one CreditoSolidario
     *   }
     * })
     * 
     */
    delete<T extends CreditoSolidarioDeleteArgs>(args: SelectSubset<T, CreditoSolidarioDeleteArgs<ExtArgs>>): Prisma__CreditoSolidarioClient<$Result.GetResult<Prisma.$CreditoSolidarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditoSolidario.
     * @param {CreditoSolidarioUpdateArgs} args - Arguments to update one CreditoSolidario.
     * @example
     * // Update one CreditoSolidario
     * const creditoSolidario = await prisma.creditoSolidario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditoSolidarioUpdateArgs>(args: SelectSubset<T, CreditoSolidarioUpdateArgs<ExtArgs>>): Prisma__CreditoSolidarioClient<$Result.GetResult<Prisma.$CreditoSolidarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditoSolidarios.
     * @param {CreditoSolidarioDeleteManyArgs} args - Arguments to filter CreditoSolidarios to delete.
     * @example
     * // Delete a few CreditoSolidarios
     * const { count } = await prisma.creditoSolidario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditoSolidarioDeleteManyArgs>(args?: SelectSubset<T, CreditoSolidarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditoSolidarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditoSolidarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditoSolidarios
     * const creditoSolidario = await prisma.creditoSolidario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditoSolidarioUpdateManyArgs>(args: SelectSubset<T, CreditoSolidarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CreditoSolidario.
     * @param {CreditoSolidarioUpsertArgs} args - Arguments to update or create a CreditoSolidario.
     * @example
     * // Update or create a CreditoSolidario
     * const creditoSolidario = await prisma.creditoSolidario.upsert({
     *   create: {
     *     // ... data to create a CreditoSolidario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditoSolidario we want to update
     *   }
     * })
     */
    upsert<T extends CreditoSolidarioUpsertArgs>(args: SelectSubset<T, CreditoSolidarioUpsertArgs<ExtArgs>>): Prisma__CreditoSolidarioClient<$Result.GetResult<Prisma.$CreditoSolidarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditoSolidarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditoSolidarioCountArgs} args - Arguments to filter CreditoSolidarios to count.
     * @example
     * // Count the number of CreditoSolidarios
     * const count = await prisma.creditoSolidario.count({
     *   where: {
     *     // ... the filter for the CreditoSolidarios we want to count
     *   }
     * })
    **/
    count<T extends CreditoSolidarioCountArgs>(
      args?: Subset<T, CreditoSolidarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditoSolidarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditoSolidario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditoSolidarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditoSolidarioAggregateArgs>(args: Subset<T, CreditoSolidarioAggregateArgs>): Prisma.PrismaPromise<GetCreditoSolidarioAggregateType<T>>

    /**
     * Group by CreditoSolidario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditoSolidarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditoSolidarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditoSolidarioGroupByArgs['orderBy'] }
        : { orderBy?: CreditoSolidarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditoSolidarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditoSolidarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditoSolidario model
   */
  readonly fields: CreditoSolidarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditoSolidario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditoSolidarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    solidario<T extends SolidarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SolidarioDefaultArgs<ExtArgs>>): Prisma__SolidarioClient<$Result.GetResult<Prisma.$SolidarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    credito<T extends CreditoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreditoDefaultArgs<ExtArgs>>): Prisma__CreditoClient<$Result.GetResult<Prisma.$CreditoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditoSolidario model
   */
  interface CreditoSolidarioFieldRefs {
    readonly estado: FieldRef<"CreditoSolidario", 'Boolean'>
    readonly solidario_id: FieldRef<"CreditoSolidario", 'Int'>
    readonly credito_id: FieldRef<"CreditoSolidario", 'Int'>
    readonly createdAt: FieldRef<"CreditoSolidario", 'DateTime'>
    readonly updatedAt: FieldRef<"CreditoSolidario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreditoSolidario findUnique
   */
  export type CreditoSolidarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditoSolidario
     */
    select?: CreditoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditoSolidario
     */
    omit?: CreditoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoSolidarioInclude<ExtArgs> | null
    /**
     * Filter, which CreditoSolidario to fetch.
     */
    where: CreditoSolidarioWhereUniqueInput
  }

  /**
   * CreditoSolidario findUniqueOrThrow
   */
  export type CreditoSolidarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditoSolidario
     */
    select?: CreditoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditoSolidario
     */
    omit?: CreditoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoSolidarioInclude<ExtArgs> | null
    /**
     * Filter, which CreditoSolidario to fetch.
     */
    where: CreditoSolidarioWhereUniqueInput
  }

  /**
   * CreditoSolidario findFirst
   */
  export type CreditoSolidarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditoSolidario
     */
    select?: CreditoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditoSolidario
     */
    omit?: CreditoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoSolidarioInclude<ExtArgs> | null
    /**
     * Filter, which CreditoSolidario to fetch.
     */
    where?: CreditoSolidarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditoSolidarios to fetch.
     */
    orderBy?: CreditoSolidarioOrderByWithRelationInput | CreditoSolidarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditoSolidarios.
     */
    cursor?: CreditoSolidarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditoSolidarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditoSolidarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditoSolidarios.
     */
    distinct?: CreditoSolidarioScalarFieldEnum | CreditoSolidarioScalarFieldEnum[]
  }

  /**
   * CreditoSolidario findFirstOrThrow
   */
  export type CreditoSolidarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditoSolidario
     */
    select?: CreditoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditoSolidario
     */
    omit?: CreditoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoSolidarioInclude<ExtArgs> | null
    /**
     * Filter, which CreditoSolidario to fetch.
     */
    where?: CreditoSolidarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditoSolidarios to fetch.
     */
    orderBy?: CreditoSolidarioOrderByWithRelationInput | CreditoSolidarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditoSolidarios.
     */
    cursor?: CreditoSolidarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditoSolidarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditoSolidarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditoSolidarios.
     */
    distinct?: CreditoSolidarioScalarFieldEnum | CreditoSolidarioScalarFieldEnum[]
  }

  /**
   * CreditoSolidario findMany
   */
  export type CreditoSolidarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditoSolidario
     */
    select?: CreditoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditoSolidario
     */
    omit?: CreditoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoSolidarioInclude<ExtArgs> | null
    /**
     * Filter, which CreditoSolidarios to fetch.
     */
    where?: CreditoSolidarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditoSolidarios to fetch.
     */
    orderBy?: CreditoSolidarioOrderByWithRelationInput | CreditoSolidarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditoSolidarios.
     */
    cursor?: CreditoSolidarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditoSolidarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditoSolidarios.
     */
    skip?: number
    distinct?: CreditoSolidarioScalarFieldEnum | CreditoSolidarioScalarFieldEnum[]
  }

  /**
   * CreditoSolidario create
   */
  export type CreditoSolidarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditoSolidario
     */
    select?: CreditoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditoSolidario
     */
    omit?: CreditoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoSolidarioInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditoSolidario.
     */
    data: XOR<CreditoSolidarioCreateInput, CreditoSolidarioUncheckedCreateInput>
  }

  /**
   * CreditoSolidario createMany
   */
  export type CreditoSolidarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditoSolidarios.
     */
    data: CreditoSolidarioCreateManyInput | CreditoSolidarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreditoSolidario update
   */
  export type CreditoSolidarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditoSolidario
     */
    select?: CreditoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditoSolidario
     */
    omit?: CreditoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoSolidarioInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditoSolidario.
     */
    data: XOR<CreditoSolidarioUpdateInput, CreditoSolidarioUncheckedUpdateInput>
    /**
     * Choose, which CreditoSolidario to update.
     */
    where: CreditoSolidarioWhereUniqueInput
  }

  /**
   * CreditoSolidario updateMany
   */
  export type CreditoSolidarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditoSolidarios.
     */
    data: XOR<CreditoSolidarioUpdateManyMutationInput, CreditoSolidarioUncheckedUpdateManyInput>
    /**
     * Filter which CreditoSolidarios to update
     */
    where?: CreditoSolidarioWhereInput
    /**
     * Limit how many CreditoSolidarios to update.
     */
    limit?: number
  }

  /**
   * CreditoSolidario upsert
   */
  export type CreditoSolidarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditoSolidario
     */
    select?: CreditoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditoSolidario
     */
    omit?: CreditoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoSolidarioInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditoSolidario to update in case it exists.
     */
    where: CreditoSolidarioWhereUniqueInput
    /**
     * In case the CreditoSolidario found by the `where` argument doesn't exist, create a new CreditoSolidario with this data.
     */
    create: XOR<CreditoSolidarioCreateInput, CreditoSolidarioUncheckedCreateInput>
    /**
     * In case the CreditoSolidario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditoSolidarioUpdateInput, CreditoSolidarioUncheckedUpdateInput>
  }

  /**
   * CreditoSolidario delete
   */
  export type CreditoSolidarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditoSolidario
     */
    select?: CreditoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditoSolidario
     */
    omit?: CreditoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoSolidarioInclude<ExtArgs> | null
    /**
     * Filter which CreditoSolidario to delete.
     */
    where: CreditoSolidarioWhereUniqueInput
  }

  /**
   * CreditoSolidario deleteMany
   */
  export type CreditoSolidarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditoSolidarios to delete
     */
    where?: CreditoSolidarioWhereInput
    /**
     * Limit how many CreditoSolidarios to delete.
     */
    limit?: number
  }

  /**
   * CreditoSolidario without action
   */
  export type CreditoSolidarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditoSolidario
     */
    select?: CreditoSolidarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditoSolidario
     */
    omit?: CreditoSolidarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditoSolidarioInclude<ExtArgs> | null
  }


  /**
   * Model Diversificacao
   */

  export type AggregateDiversificacao = {
    _count: DiversificacaoCountAggregateOutputType | null
    _avg: DiversificacaoAvgAggregateOutputType | null
    _sum: DiversificacaoSumAggregateOutputType | null
    _min: DiversificacaoMinAggregateOutputType | null
    _max: DiversificacaoMaxAggregateOutputType | null
  }

  export type DiversificacaoAvgAggregateOutputType = {
    investidor_id: number | null
    emprestimo_id: number | null
    taxa: number | null
  }

  export type DiversificacaoSumAggregateOutputType = {
    investidor_id: number | null
    emprestimo_id: number | null
    taxa: number | null
  }

  export type DiversificacaoMinAggregateOutputType = {
    estado: boolean | null
    investidor_id: number | null
    emprestimo_id: number | null
    taxa: number | null
    protencao: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiversificacaoMaxAggregateOutputType = {
    estado: boolean | null
    investidor_id: number | null
    emprestimo_id: number | null
    taxa: number | null
    protencao: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiversificacaoCountAggregateOutputType = {
    estado: number
    investidor_id: number
    emprestimo_id: number
    taxa: number
    protencao: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DiversificacaoAvgAggregateInputType = {
    investidor_id?: true
    emprestimo_id?: true
    taxa?: true
  }

  export type DiversificacaoSumAggregateInputType = {
    investidor_id?: true
    emprestimo_id?: true
    taxa?: true
  }

  export type DiversificacaoMinAggregateInputType = {
    estado?: true
    investidor_id?: true
    emprestimo_id?: true
    taxa?: true
    protencao?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiversificacaoMaxAggregateInputType = {
    estado?: true
    investidor_id?: true
    emprestimo_id?: true
    taxa?: true
    protencao?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiversificacaoCountAggregateInputType = {
    estado?: true
    investidor_id?: true
    emprestimo_id?: true
    taxa?: true
    protencao?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DiversificacaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diversificacao to aggregate.
     */
    where?: DiversificacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diversificacaos to fetch.
     */
    orderBy?: DiversificacaoOrderByWithRelationInput | DiversificacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiversificacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diversificacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diversificacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Diversificacaos
    **/
    _count?: true | DiversificacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiversificacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiversificacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiversificacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiversificacaoMaxAggregateInputType
  }

  export type GetDiversificacaoAggregateType<T extends DiversificacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateDiversificacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiversificacao[P]>
      : GetScalarType<T[P], AggregateDiversificacao[P]>
  }




  export type DiversificacaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiversificacaoWhereInput
    orderBy?: DiversificacaoOrderByWithAggregationInput | DiversificacaoOrderByWithAggregationInput[]
    by: DiversificacaoScalarFieldEnum[] | DiversificacaoScalarFieldEnum
    having?: DiversificacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiversificacaoCountAggregateInputType | true
    _avg?: DiversificacaoAvgAggregateInputType
    _sum?: DiversificacaoSumAggregateInputType
    _min?: DiversificacaoMinAggregateInputType
    _max?: DiversificacaoMaxAggregateInputType
  }

  export type DiversificacaoGroupByOutputType = {
    estado: boolean
    investidor_id: number
    emprestimo_id: number
    taxa: number
    protencao: boolean
    createdAt: Date
    updatedAt: Date
    _count: DiversificacaoCountAggregateOutputType | null
    _avg: DiversificacaoAvgAggregateOutputType | null
    _sum: DiversificacaoSumAggregateOutputType | null
    _min: DiversificacaoMinAggregateOutputType | null
    _max: DiversificacaoMaxAggregateOutputType | null
  }

  type GetDiversificacaoGroupByPayload<T extends DiversificacaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiversificacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiversificacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiversificacaoGroupByOutputType[P]>
            : GetScalarType<T[P], DiversificacaoGroupByOutputType[P]>
        }
      >
    >


  export type DiversificacaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    estado?: boolean
    investidor_id?: boolean
    emprestimo_id?: boolean
    taxa?: boolean
    protencao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    investidor?: boolean | InvestidorDefaultArgs<ExtArgs>
    emprestimo?: boolean | EmprestimoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diversificacao"]>



  export type DiversificacaoSelectScalar = {
    estado?: boolean
    investidor_id?: boolean
    emprestimo_id?: boolean
    taxa?: boolean
    protencao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DiversificacaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"estado" | "investidor_id" | "emprestimo_id" | "taxa" | "protencao" | "createdAt" | "updatedAt", ExtArgs["result"]["diversificacao"]>
  export type DiversificacaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investidor?: boolean | InvestidorDefaultArgs<ExtArgs>
    emprestimo?: boolean | EmprestimoDefaultArgs<ExtArgs>
  }

  export type $DiversificacaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Diversificacao"
    objects: {
      investidor: Prisma.$InvestidorPayload<ExtArgs>
      emprestimo: Prisma.$EmprestimoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      estado: boolean
      investidor_id: number
      emprestimo_id: number
      taxa: number
      protencao: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["diversificacao"]>
    composites: {}
  }

  type DiversificacaoGetPayload<S extends boolean | null | undefined | DiversificacaoDefaultArgs> = $Result.GetResult<Prisma.$DiversificacaoPayload, S>

  type DiversificacaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiversificacaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiversificacaoCountAggregateInputType | true
    }

  export interface DiversificacaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Diversificacao'], meta: { name: 'Diversificacao' } }
    /**
     * Find zero or one Diversificacao that matches the filter.
     * @param {DiversificacaoFindUniqueArgs} args - Arguments to find a Diversificacao
     * @example
     * // Get one Diversificacao
     * const diversificacao = await prisma.diversificacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiversificacaoFindUniqueArgs>(args: SelectSubset<T, DiversificacaoFindUniqueArgs<ExtArgs>>): Prisma__DiversificacaoClient<$Result.GetResult<Prisma.$DiversificacaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Diversificacao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiversificacaoFindUniqueOrThrowArgs} args - Arguments to find a Diversificacao
     * @example
     * // Get one Diversificacao
     * const diversificacao = await prisma.diversificacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiversificacaoFindUniqueOrThrowArgs>(args: SelectSubset<T, DiversificacaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiversificacaoClient<$Result.GetResult<Prisma.$DiversificacaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diversificacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversificacaoFindFirstArgs} args - Arguments to find a Diversificacao
     * @example
     * // Get one Diversificacao
     * const diversificacao = await prisma.diversificacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiversificacaoFindFirstArgs>(args?: SelectSubset<T, DiversificacaoFindFirstArgs<ExtArgs>>): Prisma__DiversificacaoClient<$Result.GetResult<Prisma.$DiversificacaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diversificacao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversificacaoFindFirstOrThrowArgs} args - Arguments to find a Diversificacao
     * @example
     * // Get one Diversificacao
     * const diversificacao = await prisma.diversificacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiversificacaoFindFirstOrThrowArgs>(args?: SelectSubset<T, DiversificacaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiversificacaoClient<$Result.GetResult<Prisma.$DiversificacaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Diversificacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversificacaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diversificacaos
     * const diversificacaos = await prisma.diversificacao.findMany()
     * 
     * // Get first 10 Diversificacaos
     * const diversificacaos = await prisma.diversificacao.findMany({ take: 10 })
     * 
     * // Only select the `estado`
     * const diversificacaoWithEstadoOnly = await prisma.diversificacao.findMany({ select: { estado: true } })
     * 
     */
    findMany<T extends DiversificacaoFindManyArgs>(args?: SelectSubset<T, DiversificacaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiversificacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Diversificacao.
     * @param {DiversificacaoCreateArgs} args - Arguments to create a Diversificacao.
     * @example
     * // Create one Diversificacao
     * const Diversificacao = await prisma.diversificacao.create({
     *   data: {
     *     // ... data to create a Diversificacao
     *   }
     * })
     * 
     */
    create<T extends DiversificacaoCreateArgs>(args: SelectSubset<T, DiversificacaoCreateArgs<ExtArgs>>): Prisma__DiversificacaoClient<$Result.GetResult<Prisma.$DiversificacaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Diversificacaos.
     * @param {DiversificacaoCreateManyArgs} args - Arguments to create many Diversificacaos.
     * @example
     * // Create many Diversificacaos
     * const diversificacao = await prisma.diversificacao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiversificacaoCreateManyArgs>(args?: SelectSubset<T, DiversificacaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Diversificacao.
     * @param {DiversificacaoDeleteArgs} args - Arguments to delete one Diversificacao.
     * @example
     * // Delete one Diversificacao
     * const Diversificacao = await prisma.diversificacao.delete({
     *   where: {
     *     // ... filter to delete one Diversificacao
     *   }
     * })
     * 
     */
    delete<T extends DiversificacaoDeleteArgs>(args: SelectSubset<T, DiversificacaoDeleteArgs<ExtArgs>>): Prisma__DiversificacaoClient<$Result.GetResult<Prisma.$DiversificacaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Diversificacao.
     * @param {DiversificacaoUpdateArgs} args - Arguments to update one Diversificacao.
     * @example
     * // Update one Diversificacao
     * const diversificacao = await prisma.diversificacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiversificacaoUpdateArgs>(args: SelectSubset<T, DiversificacaoUpdateArgs<ExtArgs>>): Prisma__DiversificacaoClient<$Result.GetResult<Prisma.$DiversificacaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Diversificacaos.
     * @param {DiversificacaoDeleteManyArgs} args - Arguments to filter Diversificacaos to delete.
     * @example
     * // Delete a few Diversificacaos
     * const { count } = await prisma.diversificacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiversificacaoDeleteManyArgs>(args?: SelectSubset<T, DiversificacaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diversificacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversificacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diversificacaos
     * const diversificacao = await prisma.diversificacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiversificacaoUpdateManyArgs>(args: SelectSubset<T, DiversificacaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diversificacao.
     * @param {DiversificacaoUpsertArgs} args - Arguments to update or create a Diversificacao.
     * @example
     * // Update or create a Diversificacao
     * const diversificacao = await prisma.diversificacao.upsert({
     *   create: {
     *     // ... data to create a Diversificacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diversificacao we want to update
     *   }
     * })
     */
    upsert<T extends DiversificacaoUpsertArgs>(args: SelectSubset<T, DiversificacaoUpsertArgs<ExtArgs>>): Prisma__DiversificacaoClient<$Result.GetResult<Prisma.$DiversificacaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Diversificacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversificacaoCountArgs} args - Arguments to filter Diversificacaos to count.
     * @example
     * // Count the number of Diversificacaos
     * const count = await prisma.diversificacao.count({
     *   where: {
     *     // ... the filter for the Diversificacaos we want to count
     *   }
     * })
    **/
    count<T extends DiversificacaoCountArgs>(
      args?: Subset<T, DiversificacaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiversificacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diversificacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversificacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiversificacaoAggregateArgs>(args: Subset<T, DiversificacaoAggregateArgs>): Prisma.PrismaPromise<GetDiversificacaoAggregateType<T>>

    /**
     * Group by Diversificacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversificacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiversificacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiversificacaoGroupByArgs['orderBy'] }
        : { orderBy?: DiversificacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiversificacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiversificacaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Diversificacao model
   */
  readonly fields: DiversificacaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Diversificacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiversificacaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    investidor<T extends InvestidorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestidorDefaultArgs<ExtArgs>>): Prisma__InvestidorClient<$Result.GetResult<Prisma.$InvestidorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    emprestimo<T extends EmprestimoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmprestimoDefaultArgs<ExtArgs>>): Prisma__EmprestimoClient<$Result.GetResult<Prisma.$EmprestimoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Diversificacao model
   */
  interface DiversificacaoFieldRefs {
    readonly estado: FieldRef<"Diversificacao", 'Boolean'>
    readonly investidor_id: FieldRef<"Diversificacao", 'Int'>
    readonly emprestimo_id: FieldRef<"Diversificacao", 'Int'>
    readonly taxa: FieldRef<"Diversificacao", 'Int'>
    readonly protencao: FieldRef<"Diversificacao", 'Boolean'>
    readonly createdAt: FieldRef<"Diversificacao", 'DateTime'>
    readonly updatedAt: FieldRef<"Diversificacao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Diversificacao findUnique
   */
  export type DiversificacaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversificacao
     */
    select?: DiversificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diversificacao
     */
    omit?: DiversificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversificacaoInclude<ExtArgs> | null
    /**
     * Filter, which Diversificacao to fetch.
     */
    where: DiversificacaoWhereUniqueInput
  }

  /**
   * Diversificacao findUniqueOrThrow
   */
  export type DiversificacaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversificacao
     */
    select?: DiversificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diversificacao
     */
    omit?: DiversificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversificacaoInclude<ExtArgs> | null
    /**
     * Filter, which Diversificacao to fetch.
     */
    where: DiversificacaoWhereUniqueInput
  }

  /**
   * Diversificacao findFirst
   */
  export type DiversificacaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversificacao
     */
    select?: DiversificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diversificacao
     */
    omit?: DiversificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversificacaoInclude<ExtArgs> | null
    /**
     * Filter, which Diversificacao to fetch.
     */
    where?: DiversificacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diversificacaos to fetch.
     */
    orderBy?: DiversificacaoOrderByWithRelationInput | DiversificacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diversificacaos.
     */
    cursor?: DiversificacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diversificacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diversificacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diversificacaos.
     */
    distinct?: DiversificacaoScalarFieldEnum | DiversificacaoScalarFieldEnum[]
  }

  /**
   * Diversificacao findFirstOrThrow
   */
  export type DiversificacaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversificacao
     */
    select?: DiversificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diversificacao
     */
    omit?: DiversificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversificacaoInclude<ExtArgs> | null
    /**
     * Filter, which Diversificacao to fetch.
     */
    where?: DiversificacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diversificacaos to fetch.
     */
    orderBy?: DiversificacaoOrderByWithRelationInput | DiversificacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diversificacaos.
     */
    cursor?: DiversificacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diversificacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diversificacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diversificacaos.
     */
    distinct?: DiversificacaoScalarFieldEnum | DiversificacaoScalarFieldEnum[]
  }

  /**
   * Diversificacao findMany
   */
  export type DiversificacaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversificacao
     */
    select?: DiversificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diversificacao
     */
    omit?: DiversificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversificacaoInclude<ExtArgs> | null
    /**
     * Filter, which Diversificacaos to fetch.
     */
    where?: DiversificacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diversificacaos to fetch.
     */
    orderBy?: DiversificacaoOrderByWithRelationInput | DiversificacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Diversificacaos.
     */
    cursor?: DiversificacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diversificacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diversificacaos.
     */
    skip?: number
    distinct?: DiversificacaoScalarFieldEnum | DiversificacaoScalarFieldEnum[]
  }

  /**
   * Diversificacao create
   */
  export type DiversificacaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversificacao
     */
    select?: DiversificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diversificacao
     */
    omit?: DiversificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversificacaoInclude<ExtArgs> | null
    /**
     * The data needed to create a Diversificacao.
     */
    data: XOR<DiversificacaoCreateInput, DiversificacaoUncheckedCreateInput>
  }

  /**
   * Diversificacao createMany
   */
  export type DiversificacaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Diversificacaos.
     */
    data: DiversificacaoCreateManyInput | DiversificacaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diversificacao update
   */
  export type DiversificacaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversificacao
     */
    select?: DiversificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diversificacao
     */
    omit?: DiversificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversificacaoInclude<ExtArgs> | null
    /**
     * The data needed to update a Diversificacao.
     */
    data: XOR<DiversificacaoUpdateInput, DiversificacaoUncheckedUpdateInput>
    /**
     * Choose, which Diversificacao to update.
     */
    where: DiversificacaoWhereUniqueInput
  }

  /**
   * Diversificacao updateMany
   */
  export type DiversificacaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Diversificacaos.
     */
    data: XOR<DiversificacaoUpdateManyMutationInput, DiversificacaoUncheckedUpdateManyInput>
    /**
     * Filter which Diversificacaos to update
     */
    where?: DiversificacaoWhereInput
    /**
     * Limit how many Diversificacaos to update.
     */
    limit?: number
  }

  /**
   * Diversificacao upsert
   */
  export type DiversificacaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversificacao
     */
    select?: DiversificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diversificacao
     */
    omit?: DiversificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversificacaoInclude<ExtArgs> | null
    /**
     * The filter to search for the Diversificacao to update in case it exists.
     */
    where: DiversificacaoWhereUniqueInput
    /**
     * In case the Diversificacao found by the `where` argument doesn't exist, create a new Diversificacao with this data.
     */
    create: XOR<DiversificacaoCreateInput, DiversificacaoUncheckedCreateInput>
    /**
     * In case the Diversificacao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiversificacaoUpdateInput, DiversificacaoUncheckedUpdateInput>
  }

  /**
   * Diversificacao delete
   */
  export type DiversificacaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversificacao
     */
    select?: DiversificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diversificacao
     */
    omit?: DiversificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversificacaoInclude<ExtArgs> | null
    /**
     * Filter which Diversificacao to delete.
     */
    where: DiversificacaoWhereUniqueInput
  }

  /**
   * Diversificacao deleteMany
   */
  export type DiversificacaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diversificacaos to delete
     */
    where?: DiversificacaoWhereInput
    /**
     * Limit how many Diversificacaos to delete.
     */
    limit?: number
  }

  /**
   * Diversificacao without action
   */
  export type DiversificacaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversificacao
     */
    select?: DiversificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diversificacao
     */
    omit?: DiversificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversificacaoInclude<ExtArgs> | null
  }


  /**
   * Model Saque
   */

  export type AggregateSaque = {
    _count: SaqueCountAggregateOutputType | null
    _avg: SaqueAvgAggregateOutputType | null
    _sum: SaqueSumAggregateOutputType | null
    _min: SaqueMinAggregateOutputType | null
    _max: SaqueMaxAggregateOutputType | null
  }

  export type SaqueAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    taxa: number | null
    user_id: number | null
  }

  export type SaqueSumAggregateOutputType = {
    id: number | null
    valor: number | null
    taxa: number | null
    user_id: number | null
  }

  export type SaqueMinAggregateOutputType = {
    id: number | null
    valor: number | null
    taxa: number | null
    estado: boolean | null
    pendencia: boolean | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaqueMaxAggregateOutputType = {
    id: number | null
    valor: number | null
    taxa: number | null
    estado: boolean | null
    pendencia: boolean | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaqueCountAggregateOutputType = {
    id: number
    valor: number
    taxa: number
    estado: number
    pendencia: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SaqueAvgAggregateInputType = {
    id?: true
    valor?: true
    taxa?: true
    user_id?: true
  }

  export type SaqueSumAggregateInputType = {
    id?: true
    valor?: true
    taxa?: true
    user_id?: true
  }

  export type SaqueMinAggregateInputType = {
    id?: true
    valor?: true
    taxa?: true
    estado?: true
    pendencia?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaqueMaxAggregateInputType = {
    id?: true
    valor?: true
    taxa?: true
    estado?: true
    pendencia?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaqueCountAggregateInputType = {
    id?: true
    valor?: true
    taxa?: true
    estado?: true
    pendencia?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SaqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Saque to aggregate.
     */
    where?: SaqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Saques to fetch.
     */
    orderBy?: SaqueOrderByWithRelationInput | SaqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Saques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Saques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Saques
    **/
    _count?: true | SaqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaqueMaxAggregateInputType
  }

  export type GetSaqueAggregateType<T extends SaqueAggregateArgs> = {
        [P in keyof T & keyof AggregateSaque]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaque[P]>
      : GetScalarType<T[P], AggregateSaque[P]>
  }




  export type SaqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaqueWhereInput
    orderBy?: SaqueOrderByWithAggregationInput | SaqueOrderByWithAggregationInput[]
    by: SaqueScalarFieldEnum[] | SaqueScalarFieldEnum
    having?: SaqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaqueCountAggregateInputType | true
    _avg?: SaqueAvgAggregateInputType
    _sum?: SaqueSumAggregateInputType
    _min?: SaqueMinAggregateInputType
    _max?: SaqueMaxAggregateInputType
  }

  export type SaqueGroupByOutputType = {
    id: number
    valor: number
    taxa: number
    estado: boolean
    pendencia: boolean
    user_id: number
    createdAt: Date
    updatedAt: Date
    _count: SaqueCountAggregateOutputType | null
    _avg: SaqueAvgAggregateOutputType | null
    _sum: SaqueSumAggregateOutputType | null
    _min: SaqueMinAggregateOutputType | null
    _max: SaqueMaxAggregateOutputType | null
  }

  type GetSaqueGroupByPayload<T extends SaqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaqueGroupByOutputType[P]>
            : GetScalarType<T[P], SaqueGroupByOutputType[P]>
        }
      >
    >


  export type SaqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    taxa?: boolean
    estado?: boolean
    pendencia?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saque"]>



  export type SaqueSelectScalar = {
    id?: boolean
    valor?: boolean
    taxa?: boolean
    estado?: boolean
    pendencia?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SaqueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "valor" | "taxa" | "estado" | "pendencia" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["saque"]>
  export type SaqueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SaquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Saque"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      valor: number
      taxa: number
      estado: boolean
      pendencia: boolean
      user_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["saque"]>
    composites: {}
  }

  type SaqueGetPayload<S extends boolean | null | undefined | SaqueDefaultArgs> = $Result.GetResult<Prisma.$SaquePayload, S>

  type SaqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaqueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaqueCountAggregateInputType | true
    }

  export interface SaqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Saque'], meta: { name: 'Saque' } }
    /**
     * Find zero or one Saque that matches the filter.
     * @param {SaqueFindUniqueArgs} args - Arguments to find a Saque
     * @example
     * // Get one Saque
     * const saque = await prisma.saque.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaqueFindUniqueArgs>(args: SelectSubset<T, SaqueFindUniqueArgs<ExtArgs>>): Prisma__SaqueClient<$Result.GetResult<Prisma.$SaquePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Saque that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaqueFindUniqueOrThrowArgs} args - Arguments to find a Saque
     * @example
     * // Get one Saque
     * const saque = await prisma.saque.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaqueFindUniqueOrThrowArgs>(args: SelectSubset<T, SaqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaqueClient<$Result.GetResult<Prisma.$SaquePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Saque that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaqueFindFirstArgs} args - Arguments to find a Saque
     * @example
     * // Get one Saque
     * const saque = await prisma.saque.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaqueFindFirstArgs>(args?: SelectSubset<T, SaqueFindFirstArgs<ExtArgs>>): Prisma__SaqueClient<$Result.GetResult<Prisma.$SaquePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Saque that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaqueFindFirstOrThrowArgs} args - Arguments to find a Saque
     * @example
     * // Get one Saque
     * const saque = await prisma.saque.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaqueFindFirstOrThrowArgs>(args?: SelectSubset<T, SaqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaqueClient<$Result.GetResult<Prisma.$SaquePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Saques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Saques
     * const saques = await prisma.saque.findMany()
     * 
     * // Get first 10 Saques
     * const saques = await prisma.saque.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saqueWithIdOnly = await prisma.saque.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaqueFindManyArgs>(args?: SelectSubset<T, SaqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaquePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Saque.
     * @param {SaqueCreateArgs} args - Arguments to create a Saque.
     * @example
     * // Create one Saque
     * const Saque = await prisma.saque.create({
     *   data: {
     *     // ... data to create a Saque
     *   }
     * })
     * 
     */
    create<T extends SaqueCreateArgs>(args: SelectSubset<T, SaqueCreateArgs<ExtArgs>>): Prisma__SaqueClient<$Result.GetResult<Prisma.$SaquePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Saques.
     * @param {SaqueCreateManyArgs} args - Arguments to create many Saques.
     * @example
     * // Create many Saques
     * const saque = await prisma.saque.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaqueCreateManyArgs>(args?: SelectSubset<T, SaqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Saque.
     * @param {SaqueDeleteArgs} args - Arguments to delete one Saque.
     * @example
     * // Delete one Saque
     * const Saque = await prisma.saque.delete({
     *   where: {
     *     // ... filter to delete one Saque
     *   }
     * })
     * 
     */
    delete<T extends SaqueDeleteArgs>(args: SelectSubset<T, SaqueDeleteArgs<ExtArgs>>): Prisma__SaqueClient<$Result.GetResult<Prisma.$SaquePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Saque.
     * @param {SaqueUpdateArgs} args - Arguments to update one Saque.
     * @example
     * // Update one Saque
     * const saque = await prisma.saque.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaqueUpdateArgs>(args: SelectSubset<T, SaqueUpdateArgs<ExtArgs>>): Prisma__SaqueClient<$Result.GetResult<Prisma.$SaquePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Saques.
     * @param {SaqueDeleteManyArgs} args - Arguments to filter Saques to delete.
     * @example
     * // Delete a few Saques
     * const { count } = await prisma.saque.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaqueDeleteManyArgs>(args?: SelectSubset<T, SaqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Saques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Saques
     * const saque = await prisma.saque.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaqueUpdateManyArgs>(args: SelectSubset<T, SaqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Saque.
     * @param {SaqueUpsertArgs} args - Arguments to update or create a Saque.
     * @example
     * // Update or create a Saque
     * const saque = await prisma.saque.upsert({
     *   create: {
     *     // ... data to create a Saque
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Saque we want to update
     *   }
     * })
     */
    upsert<T extends SaqueUpsertArgs>(args: SelectSubset<T, SaqueUpsertArgs<ExtArgs>>): Prisma__SaqueClient<$Result.GetResult<Prisma.$SaquePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Saques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaqueCountArgs} args - Arguments to filter Saques to count.
     * @example
     * // Count the number of Saques
     * const count = await prisma.saque.count({
     *   where: {
     *     // ... the filter for the Saques we want to count
     *   }
     * })
    **/
    count<T extends SaqueCountArgs>(
      args?: Subset<T, SaqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Saque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaqueAggregateArgs>(args: Subset<T, SaqueAggregateArgs>): Prisma.PrismaPromise<GetSaqueAggregateType<T>>

    /**
     * Group by Saque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaqueGroupByArgs['orderBy'] }
        : { orderBy?: SaqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Saque model
   */
  readonly fields: SaqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Saque.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Saque model
   */
  interface SaqueFieldRefs {
    readonly id: FieldRef<"Saque", 'Int'>
    readonly valor: FieldRef<"Saque", 'Float'>
    readonly taxa: FieldRef<"Saque", 'Int'>
    readonly estado: FieldRef<"Saque", 'Boolean'>
    readonly pendencia: FieldRef<"Saque", 'Boolean'>
    readonly user_id: FieldRef<"Saque", 'Int'>
    readonly createdAt: FieldRef<"Saque", 'DateTime'>
    readonly updatedAt: FieldRef<"Saque", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Saque findUnique
   */
  export type SaqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saque
     */
    select?: SaqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saque
     */
    omit?: SaqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaqueInclude<ExtArgs> | null
    /**
     * Filter, which Saque to fetch.
     */
    where: SaqueWhereUniqueInput
  }

  /**
   * Saque findUniqueOrThrow
   */
  export type SaqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saque
     */
    select?: SaqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saque
     */
    omit?: SaqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaqueInclude<ExtArgs> | null
    /**
     * Filter, which Saque to fetch.
     */
    where: SaqueWhereUniqueInput
  }

  /**
   * Saque findFirst
   */
  export type SaqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saque
     */
    select?: SaqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saque
     */
    omit?: SaqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaqueInclude<ExtArgs> | null
    /**
     * Filter, which Saque to fetch.
     */
    where?: SaqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Saques to fetch.
     */
    orderBy?: SaqueOrderByWithRelationInput | SaqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Saques.
     */
    cursor?: SaqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Saques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Saques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Saques.
     */
    distinct?: SaqueScalarFieldEnum | SaqueScalarFieldEnum[]
  }

  /**
   * Saque findFirstOrThrow
   */
  export type SaqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saque
     */
    select?: SaqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saque
     */
    omit?: SaqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaqueInclude<ExtArgs> | null
    /**
     * Filter, which Saque to fetch.
     */
    where?: SaqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Saques to fetch.
     */
    orderBy?: SaqueOrderByWithRelationInput | SaqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Saques.
     */
    cursor?: SaqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Saques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Saques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Saques.
     */
    distinct?: SaqueScalarFieldEnum | SaqueScalarFieldEnum[]
  }

  /**
   * Saque findMany
   */
  export type SaqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saque
     */
    select?: SaqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saque
     */
    omit?: SaqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaqueInclude<ExtArgs> | null
    /**
     * Filter, which Saques to fetch.
     */
    where?: SaqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Saques to fetch.
     */
    orderBy?: SaqueOrderByWithRelationInput | SaqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Saques.
     */
    cursor?: SaqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Saques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Saques.
     */
    skip?: number
    distinct?: SaqueScalarFieldEnum | SaqueScalarFieldEnum[]
  }

  /**
   * Saque create
   */
  export type SaqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saque
     */
    select?: SaqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saque
     */
    omit?: SaqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaqueInclude<ExtArgs> | null
    /**
     * The data needed to create a Saque.
     */
    data: XOR<SaqueCreateInput, SaqueUncheckedCreateInput>
  }

  /**
   * Saque createMany
   */
  export type SaqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Saques.
     */
    data: SaqueCreateManyInput | SaqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Saque update
   */
  export type SaqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saque
     */
    select?: SaqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saque
     */
    omit?: SaqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaqueInclude<ExtArgs> | null
    /**
     * The data needed to update a Saque.
     */
    data: XOR<SaqueUpdateInput, SaqueUncheckedUpdateInput>
    /**
     * Choose, which Saque to update.
     */
    where: SaqueWhereUniqueInput
  }

  /**
   * Saque updateMany
   */
  export type SaqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Saques.
     */
    data: XOR<SaqueUpdateManyMutationInput, SaqueUncheckedUpdateManyInput>
    /**
     * Filter which Saques to update
     */
    where?: SaqueWhereInput
    /**
     * Limit how many Saques to update.
     */
    limit?: number
  }

  /**
   * Saque upsert
   */
  export type SaqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saque
     */
    select?: SaqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saque
     */
    omit?: SaqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaqueInclude<ExtArgs> | null
    /**
     * The filter to search for the Saque to update in case it exists.
     */
    where: SaqueWhereUniqueInput
    /**
     * In case the Saque found by the `where` argument doesn't exist, create a new Saque with this data.
     */
    create: XOR<SaqueCreateInput, SaqueUncheckedCreateInput>
    /**
     * In case the Saque was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaqueUpdateInput, SaqueUncheckedUpdateInput>
  }

  /**
   * Saque delete
   */
  export type SaqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saque
     */
    select?: SaqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saque
     */
    omit?: SaqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaqueInclude<ExtArgs> | null
    /**
     * Filter which Saque to delete.
     */
    where: SaqueWhereUniqueInput
  }

  /**
   * Saque deleteMany
   */
  export type SaqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Saques to delete
     */
    where?: SaqueWhereInput
    /**
     * Limit how many Saques to delete.
     */
    limit?: number
  }

  /**
   * Saque without action
   */
  export type SaqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saque
     */
    select?: SaqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saque
     */
    omit?: SaqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaqueInclude<ExtArgs> | null
  }


  /**
   * Model Deposito
   */

  export type AggregateDeposito = {
    _count: DepositoCountAggregateOutputType | null
    _avg: DepositoAvgAggregateOutputType | null
    _sum: DepositoSumAggregateOutputType | null
    _min: DepositoMinAggregateOutputType | null
    _max: DepositoMaxAggregateOutputType | null
  }

  export type DepositoAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    user_id: number | null
  }

  export type DepositoSumAggregateOutputType = {
    id: number | null
    valor: number | null
    user_id: number | null
  }

  export type DepositoMinAggregateOutputType = {
    id: number | null
    valor: number | null
    estado: boolean | null
    pendencia: boolean | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepositoMaxAggregateOutputType = {
    id: number | null
    valor: number | null
    estado: boolean | null
    pendencia: boolean | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepositoCountAggregateOutputType = {
    id: number
    valor: number
    estado: number
    pendencia: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepositoAvgAggregateInputType = {
    id?: true
    valor?: true
    user_id?: true
  }

  export type DepositoSumAggregateInputType = {
    id?: true
    valor?: true
    user_id?: true
  }

  export type DepositoMinAggregateInputType = {
    id?: true
    valor?: true
    estado?: true
    pendencia?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepositoMaxAggregateInputType = {
    id?: true
    valor?: true
    estado?: true
    pendencia?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepositoCountAggregateInputType = {
    id?: true
    valor?: true
    estado?: true
    pendencia?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepositoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deposito to aggregate.
     */
    where?: DepositoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depositos to fetch.
     */
    orderBy?: DepositoOrderByWithRelationInput | DepositoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepositoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depositos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depositos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Depositos
    **/
    _count?: true | DepositoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepositoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepositoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepositoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepositoMaxAggregateInputType
  }

  export type GetDepositoAggregateType<T extends DepositoAggregateArgs> = {
        [P in keyof T & keyof AggregateDeposito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeposito[P]>
      : GetScalarType<T[P], AggregateDeposito[P]>
  }




  export type DepositoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepositoWhereInput
    orderBy?: DepositoOrderByWithAggregationInput | DepositoOrderByWithAggregationInput[]
    by: DepositoScalarFieldEnum[] | DepositoScalarFieldEnum
    having?: DepositoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepositoCountAggregateInputType | true
    _avg?: DepositoAvgAggregateInputType
    _sum?: DepositoSumAggregateInputType
    _min?: DepositoMinAggregateInputType
    _max?: DepositoMaxAggregateInputType
  }

  export type DepositoGroupByOutputType = {
    id: number
    valor: number
    estado: boolean
    pendencia: boolean
    user_id: number
    createdAt: Date
    updatedAt: Date
    _count: DepositoCountAggregateOutputType | null
    _avg: DepositoAvgAggregateOutputType | null
    _sum: DepositoSumAggregateOutputType | null
    _min: DepositoMinAggregateOutputType | null
    _max: DepositoMaxAggregateOutputType | null
  }

  type GetDepositoGroupByPayload<T extends DepositoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepositoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepositoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepositoGroupByOutputType[P]>
            : GetScalarType<T[P], DepositoGroupByOutputType[P]>
        }
      >
    >


  export type DepositoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    estado?: boolean
    pendencia?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deposito"]>



  export type DepositoSelectScalar = {
    id?: boolean
    valor?: boolean
    estado?: boolean
    pendencia?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepositoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "valor" | "estado" | "pendencia" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["deposito"]>
  export type DepositoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DepositoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deposito"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      valor: number
      estado: boolean
      pendencia: boolean
      user_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deposito"]>
    composites: {}
  }

  type DepositoGetPayload<S extends boolean | null | undefined | DepositoDefaultArgs> = $Result.GetResult<Prisma.$DepositoPayload, S>

  type DepositoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepositoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepositoCountAggregateInputType | true
    }

  export interface DepositoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deposito'], meta: { name: 'Deposito' } }
    /**
     * Find zero or one Deposito that matches the filter.
     * @param {DepositoFindUniqueArgs} args - Arguments to find a Deposito
     * @example
     * // Get one Deposito
     * const deposito = await prisma.deposito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepositoFindUniqueArgs>(args: SelectSubset<T, DepositoFindUniqueArgs<ExtArgs>>): Prisma__DepositoClient<$Result.GetResult<Prisma.$DepositoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Deposito that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepositoFindUniqueOrThrowArgs} args - Arguments to find a Deposito
     * @example
     * // Get one Deposito
     * const deposito = await prisma.deposito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepositoFindUniqueOrThrowArgs>(args: SelectSubset<T, DepositoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepositoClient<$Result.GetResult<Prisma.$DepositoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deposito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositoFindFirstArgs} args - Arguments to find a Deposito
     * @example
     * // Get one Deposito
     * const deposito = await prisma.deposito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepositoFindFirstArgs>(args?: SelectSubset<T, DepositoFindFirstArgs<ExtArgs>>): Prisma__DepositoClient<$Result.GetResult<Prisma.$DepositoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deposito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositoFindFirstOrThrowArgs} args - Arguments to find a Deposito
     * @example
     * // Get one Deposito
     * const deposito = await prisma.deposito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepositoFindFirstOrThrowArgs>(args?: SelectSubset<T, DepositoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepositoClient<$Result.GetResult<Prisma.$DepositoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Depositos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Depositos
     * const depositos = await prisma.deposito.findMany()
     * 
     * // Get first 10 Depositos
     * const depositos = await prisma.deposito.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const depositoWithIdOnly = await prisma.deposito.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepositoFindManyArgs>(args?: SelectSubset<T, DepositoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Deposito.
     * @param {DepositoCreateArgs} args - Arguments to create a Deposito.
     * @example
     * // Create one Deposito
     * const Deposito = await prisma.deposito.create({
     *   data: {
     *     // ... data to create a Deposito
     *   }
     * })
     * 
     */
    create<T extends DepositoCreateArgs>(args: SelectSubset<T, DepositoCreateArgs<ExtArgs>>): Prisma__DepositoClient<$Result.GetResult<Prisma.$DepositoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Depositos.
     * @param {DepositoCreateManyArgs} args - Arguments to create many Depositos.
     * @example
     * // Create many Depositos
     * const deposito = await prisma.deposito.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepositoCreateManyArgs>(args?: SelectSubset<T, DepositoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Deposito.
     * @param {DepositoDeleteArgs} args - Arguments to delete one Deposito.
     * @example
     * // Delete one Deposito
     * const Deposito = await prisma.deposito.delete({
     *   where: {
     *     // ... filter to delete one Deposito
     *   }
     * })
     * 
     */
    delete<T extends DepositoDeleteArgs>(args: SelectSubset<T, DepositoDeleteArgs<ExtArgs>>): Prisma__DepositoClient<$Result.GetResult<Prisma.$DepositoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Deposito.
     * @param {DepositoUpdateArgs} args - Arguments to update one Deposito.
     * @example
     * // Update one Deposito
     * const deposito = await prisma.deposito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepositoUpdateArgs>(args: SelectSubset<T, DepositoUpdateArgs<ExtArgs>>): Prisma__DepositoClient<$Result.GetResult<Prisma.$DepositoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Depositos.
     * @param {DepositoDeleteManyArgs} args - Arguments to filter Depositos to delete.
     * @example
     * // Delete a few Depositos
     * const { count } = await prisma.deposito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepositoDeleteManyArgs>(args?: SelectSubset<T, DepositoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Depositos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Depositos
     * const deposito = await prisma.deposito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepositoUpdateManyArgs>(args: SelectSubset<T, DepositoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deposito.
     * @param {DepositoUpsertArgs} args - Arguments to update or create a Deposito.
     * @example
     * // Update or create a Deposito
     * const deposito = await prisma.deposito.upsert({
     *   create: {
     *     // ... data to create a Deposito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deposito we want to update
     *   }
     * })
     */
    upsert<T extends DepositoUpsertArgs>(args: SelectSubset<T, DepositoUpsertArgs<ExtArgs>>): Prisma__DepositoClient<$Result.GetResult<Prisma.$DepositoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Depositos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositoCountArgs} args - Arguments to filter Depositos to count.
     * @example
     * // Count the number of Depositos
     * const count = await prisma.deposito.count({
     *   where: {
     *     // ... the filter for the Depositos we want to count
     *   }
     * })
    **/
    count<T extends DepositoCountArgs>(
      args?: Subset<T, DepositoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepositoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deposito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepositoAggregateArgs>(args: Subset<T, DepositoAggregateArgs>): Prisma.PrismaPromise<GetDepositoAggregateType<T>>

    /**
     * Group by Deposito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepositoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepositoGroupByArgs['orderBy'] }
        : { orderBy?: DepositoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepositoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepositoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deposito model
   */
  readonly fields: DepositoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deposito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepositoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deposito model
   */
  interface DepositoFieldRefs {
    readonly id: FieldRef<"Deposito", 'Int'>
    readonly valor: FieldRef<"Deposito", 'Float'>
    readonly estado: FieldRef<"Deposito", 'Boolean'>
    readonly pendencia: FieldRef<"Deposito", 'Boolean'>
    readonly user_id: FieldRef<"Deposito", 'Int'>
    readonly createdAt: FieldRef<"Deposito", 'DateTime'>
    readonly updatedAt: FieldRef<"Deposito", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Deposito findUnique
   */
  export type DepositoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposito
     */
    select?: DepositoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposito
     */
    omit?: DepositoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositoInclude<ExtArgs> | null
    /**
     * Filter, which Deposito to fetch.
     */
    where: DepositoWhereUniqueInput
  }

  /**
   * Deposito findUniqueOrThrow
   */
  export type DepositoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposito
     */
    select?: DepositoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposito
     */
    omit?: DepositoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositoInclude<ExtArgs> | null
    /**
     * Filter, which Deposito to fetch.
     */
    where: DepositoWhereUniqueInput
  }

  /**
   * Deposito findFirst
   */
  export type DepositoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposito
     */
    select?: DepositoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposito
     */
    omit?: DepositoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositoInclude<ExtArgs> | null
    /**
     * Filter, which Deposito to fetch.
     */
    where?: DepositoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depositos to fetch.
     */
    orderBy?: DepositoOrderByWithRelationInput | DepositoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Depositos.
     */
    cursor?: DepositoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depositos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depositos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Depositos.
     */
    distinct?: DepositoScalarFieldEnum | DepositoScalarFieldEnum[]
  }

  /**
   * Deposito findFirstOrThrow
   */
  export type DepositoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposito
     */
    select?: DepositoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposito
     */
    omit?: DepositoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositoInclude<ExtArgs> | null
    /**
     * Filter, which Deposito to fetch.
     */
    where?: DepositoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depositos to fetch.
     */
    orderBy?: DepositoOrderByWithRelationInput | DepositoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Depositos.
     */
    cursor?: DepositoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depositos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depositos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Depositos.
     */
    distinct?: DepositoScalarFieldEnum | DepositoScalarFieldEnum[]
  }

  /**
   * Deposito findMany
   */
  export type DepositoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposito
     */
    select?: DepositoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposito
     */
    omit?: DepositoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositoInclude<ExtArgs> | null
    /**
     * Filter, which Depositos to fetch.
     */
    where?: DepositoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depositos to fetch.
     */
    orderBy?: DepositoOrderByWithRelationInput | DepositoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Depositos.
     */
    cursor?: DepositoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depositos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depositos.
     */
    skip?: number
    distinct?: DepositoScalarFieldEnum | DepositoScalarFieldEnum[]
  }

  /**
   * Deposito create
   */
  export type DepositoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposito
     */
    select?: DepositoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposito
     */
    omit?: DepositoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositoInclude<ExtArgs> | null
    /**
     * The data needed to create a Deposito.
     */
    data: XOR<DepositoCreateInput, DepositoUncheckedCreateInput>
  }

  /**
   * Deposito createMany
   */
  export type DepositoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Depositos.
     */
    data: DepositoCreateManyInput | DepositoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deposito update
   */
  export type DepositoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposito
     */
    select?: DepositoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposito
     */
    omit?: DepositoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositoInclude<ExtArgs> | null
    /**
     * The data needed to update a Deposito.
     */
    data: XOR<DepositoUpdateInput, DepositoUncheckedUpdateInput>
    /**
     * Choose, which Deposito to update.
     */
    where: DepositoWhereUniqueInput
  }

  /**
   * Deposito updateMany
   */
  export type DepositoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Depositos.
     */
    data: XOR<DepositoUpdateManyMutationInput, DepositoUncheckedUpdateManyInput>
    /**
     * Filter which Depositos to update
     */
    where?: DepositoWhereInput
    /**
     * Limit how many Depositos to update.
     */
    limit?: number
  }

  /**
   * Deposito upsert
   */
  export type DepositoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposito
     */
    select?: DepositoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposito
     */
    omit?: DepositoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositoInclude<ExtArgs> | null
    /**
     * The filter to search for the Deposito to update in case it exists.
     */
    where: DepositoWhereUniqueInput
    /**
     * In case the Deposito found by the `where` argument doesn't exist, create a new Deposito with this data.
     */
    create: XOR<DepositoCreateInput, DepositoUncheckedCreateInput>
    /**
     * In case the Deposito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepositoUpdateInput, DepositoUncheckedUpdateInput>
  }

  /**
   * Deposito delete
   */
  export type DepositoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposito
     */
    select?: DepositoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposito
     */
    omit?: DepositoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositoInclude<ExtArgs> | null
    /**
     * Filter which Deposito to delete.
     */
    where: DepositoWhereUniqueInput
  }

  /**
   * Deposito deleteMany
   */
  export type DepositoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Depositos to delete
     */
    where?: DepositoWhereInput
    /**
     * Limit how many Depositos to delete.
     */
    limit?: number
  }

  /**
   * Deposito without action
   */
  export type DepositoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposito
     */
    select?: DepositoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposito
     */
    omit?: DepositoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositoInclude<ExtArgs> | null
  }


  /**
   * Model Carteira
   */

  export type AggregateCarteira = {
    _count: CarteiraCountAggregateOutputType | null
    _avg: CarteiraAvgAggregateOutputType | null
    _sum: CarteiraSumAggregateOutputType | null
    _min: CarteiraMinAggregateOutputType | null
    _max: CarteiraMaxAggregateOutputType | null
  }

  export type CarteiraAvgAggregateOutputType = {
    id: number | null
    saldo: number | null
    numero: number | null
    codigo: number | null
    user_id: number | null
  }

  export type CarteiraSumAggregateOutputType = {
    id: number | null
    saldo: number | null
    numero: number | null
    codigo: number | null
    user_id: number | null
  }

  export type CarteiraMinAggregateOutputType = {
    id: number | null
    saldo: number | null
    estado: boolean | null
    numero: number | null
    codigo: number | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CarteiraMaxAggregateOutputType = {
    id: number | null
    saldo: number | null
    estado: boolean | null
    numero: number | null
    codigo: number | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CarteiraCountAggregateOutputType = {
    id: number
    saldo: number
    estado: number
    numero: number
    codigo: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CarteiraAvgAggregateInputType = {
    id?: true
    saldo?: true
    numero?: true
    codigo?: true
    user_id?: true
  }

  export type CarteiraSumAggregateInputType = {
    id?: true
    saldo?: true
    numero?: true
    codigo?: true
    user_id?: true
  }

  export type CarteiraMinAggregateInputType = {
    id?: true
    saldo?: true
    estado?: true
    numero?: true
    codigo?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CarteiraMaxAggregateInputType = {
    id?: true
    saldo?: true
    estado?: true
    numero?: true
    codigo?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CarteiraCountAggregateInputType = {
    id?: true
    saldo?: true
    estado?: true
    numero?: true
    codigo?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CarteiraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carteira to aggregate.
     */
    where?: CarteiraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carteiras to fetch.
     */
    orderBy?: CarteiraOrderByWithRelationInput | CarteiraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CarteiraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carteiras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carteiras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carteiras
    **/
    _count?: true | CarteiraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarteiraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarteiraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarteiraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarteiraMaxAggregateInputType
  }

  export type GetCarteiraAggregateType<T extends CarteiraAggregateArgs> = {
        [P in keyof T & keyof AggregateCarteira]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarteira[P]>
      : GetScalarType<T[P], AggregateCarteira[P]>
  }




  export type CarteiraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarteiraWhereInput
    orderBy?: CarteiraOrderByWithAggregationInput | CarteiraOrderByWithAggregationInput[]
    by: CarteiraScalarFieldEnum[] | CarteiraScalarFieldEnum
    having?: CarteiraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarteiraCountAggregateInputType | true
    _avg?: CarteiraAvgAggregateInputType
    _sum?: CarteiraSumAggregateInputType
    _min?: CarteiraMinAggregateInputType
    _max?: CarteiraMaxAggregateInputType
  }

  export type CarteiraGroupByOutputType = {
    id: number
    saldo: number
    estado: boolean
    numero: number
    codigo: number
    user_id: number
    createdAt: Date
    updatedAt: Date
    _count: CarteiraCountAggregateOutputType | null
    _avg: CarteiraAvgAggregateOutputType | null
    _sum: CarteiraSumAggregateOutputType | null
    _min: CarteiraMinAggregateOutputType | null
    _max: CarteiraMaxAggregateOutputType | null
  }

  type GetCarteiraGroupByPayload<T extends CarteiraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarteiraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarteiraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarteiraGroupByOutputType[P]>
            : GetScalarType<T[P], CarteiraGroupByOutputType[P]>
        }
      >
    >


  export type CarteiraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saldo?: boolean
    estado?: boolean
    numero?: boolean
    codigo?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carteira"]>



  export type CarteiraSelectScalar = {
    id?: boolean
    saldo?: boolean
    estado?: boolean
    numero?: boolean
    codigo?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CarteiraOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "saldo" | "estado" | "numero" | "codigo" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["carteira"]>
  export type CarteiraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CarteiraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Carteira"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      saldo: number
      estado: boolean
      numero: number
      codigo: number
      user_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["carteira"]>
    composites: {}
  }

  type CarteiraGetPayload<S extends boolean | null | undefined | CarteiraDefaultArgs> = $Result.GetResult<Prisma.$CarteiraPayload, S>

  type CarteiraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CarteiraFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CarteiraCountAggregateInputType | true
    }

  export interface CarteiraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Carteira'], meta: { name: 'Carteira' } }
    /**
     * Find zero or one Carteira that matches the filter.
     * @param {CarteiraFindUniqueArgs} args - Arguments to find a Carteira
     * @example
     * // Get one Carteira
     * const carteira = await prisma.carteira.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CarteiraFindUniqueArgs>(args: SelectSubset<T, CarteiraFindUniqueArgs<ExtArgs>>): Prisma__CarteiraClient<$Result.GetResult<Prisma.$CarteiraPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Carteira that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CarteiraFindUniqueOrThrowArgs} args - Arguments to find a Carteira
     * @example
     * // Get one Carteira
     * const carteira = await prisma.carteira.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CarteiraFindUniqueOrThrowArgs>(args: SelectSubset<T, CarteiraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CarteiraClient<$Result.GetResult<Prisma.$CarteiraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Carteira that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteiraFindFirstArgs} args - Arguments to find a Carteira
     * @example
     * // Get one Carteira
     * const carteira = await prisma.carteira.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CarteiraFindFirstArgs>(args?: SelectSubset<T, CarteiraFindFirstArgs<ExtArgs>>): Prisma__CarteiraClient<$Result.GetResult<Prisma.$CarteiraPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Carteira that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteiraFindFirstOrThrowArgs} args - Arguments to find a Carteira
     * @example
     * // Get one Carteira
     * const carteira = await prisma.carteira.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CarteiraFindFirstOrThrowArgs>(args?: SelectSubset<T, CarteiraFindFirstOrThrowArgs<ExtArgs>>): Prisma__CarteiraClient<$Result.GetResult<Prisma.$CarteiraPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carteiras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteiraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carteiras
     * const carteiras = await prisma.carteira.findMany()
     * 
     * // Get first 10 Carteiras
     * const carteiras = await prisma.carteira.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const carteiraWithIdOnly = await prisma.carteira.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CarteiraFindManyArgs>(args?: SelectSubset<T, CarteiraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarteiraPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Carteira.
     * @param {CarteiraCreateArgs} args - Arguments to create a Carteira.
     * @example
     * // Create one Carteira
     * const Carteira = await prisma.carteira.create({
     *   data: {
     *     // ... data to create a Carteira
     *   }
     * })
     * 
     */
    create<T extends CarteiraCreateArgs>(args: SelectSubset<T, CarteiraCreateArgs<ExtArgs>>): Prisma__CarteiraClient<$Result.GetResult<Prisma.$CarteiraPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carteiras.
     * @param {CarteiraCreateManyArgs} args - Arguments to create many Carteiras.
     * @example
     * // Create many Carteiras
     * const carteira = await prisma.carteira.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CarteiraCreateManyArgs>(args?: SelectSubset<T, CarteiraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Carteira.
     * @param {CarteiraDeleteArgs} args - Arguments to delete one Carteira.
     * @example
     * // Delete one Carteira
     * const Carteira = await prisma.carteira.delete({
     *   where: {
     *     // ... filter to delete one Carteira
     *   }
     * })
     * 
     */
    delete<T extends CarteiraDeleteArgs>(args: SelectSubset<T, CarteiraDeleteArgs<ExtArgs>>): Prisma__CarteiraClient<$Result.GetResult<Prisma.$CarteiraPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Carteira.
     * @param {CarteiraUpdateArgs} args - Arguments to update one Carteira.
     * @example
     * // Update one Carteira
     * const carteira = await prisma.carteira.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CarteiraUpdateArgs>(args: SelectSubset<T, CarteiraUpdateArgs<ExtArgs>>): Prisma__CarteiraClient<$Result.GetResult<Prisma.$CarteiraPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carteiras.
     * @param {CarteiraDeleteManyArgs} args - Arguments to filter Carteiras to delete.
     * @example
     * // Delete a few Carteiras
     * const { count } = await prisma.carteira.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CarteiraDeleteManyArgs>(args?: SelectSubset<T, CarteiraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carteiras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteiraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carteiras
     * const carteira = await prisma.carteira.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CarteiraUpdateManyArgs>(args: SelectSubset<T, CarteiraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Carteira.
     * @param {CarteiraUpsertArgs} args - Arguments to update or create a Carteira.
     * @example
     * // Update or create a Carteira
     * const carteira = await prisma.carteira.upsert({
     *   create: {
     *     // ... data to create a Carteira
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Carteira we want to update
     *   }
     * })
     */
    upsert<T extends CarteiraUpsertArgs>(args: SelectSubset<T, CarteiraUpsertArgs<ExtArgs>>): Prisma__CarteiraClient<$Result.GetResult<Prisma.$CarteiraPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carteiras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteiraCountArgs} args - Arguments to filter Carteiras to count.
     * @example
     * // Count the number of Carteiras
     * const count = await prisma.carteira.count({
     *   where: {
     *     // ... the filter for the Carteiras we want to count
     *   }
     * })
    **/
    count<T extends CarteiraCountArgs>(
      args?: Subset<T, CarteiraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarteiraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Carteira.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteiraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarteiraAggregateArgs>(args: Subset<T, CarteiraAggregateArgs>): Prisma.PrismaPromise<GetCarteiraAggregateType<T>>

    /**
     * Group by Carteira.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteiraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarteiraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarteiraGroupByArgs['orderBy'] }
        : { orderBy?: CarteiraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarteiraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarteiraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Carteira model
   */
  readonly fields: CarteiraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Carteira.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarteiraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Carteira model
   */
  interface CarteiraFieldRefs {
    readonly id: FieldRef<"Carteira", 'Int'>
    readonly saldo: FieldRef<"Carteira", 'Float'>
    readonly estado: FieldRef<"Carteira", 'Boolean'>
    readonly numero: FieldRef<"Carteira", 'Int'>
    readonly codigo: FieldRef<"Carteira", 'Int'>
    readonly user_id: FieldRef<"Carteira", 'Int'>
    readonly createdAt: FieldRef<"Carteira", 'DateTime'>
    readonly updatedAt: FieldRef<"Carteira", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Carteira findUnique
   */
  export type CarteiraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteira
     */
    select?: CarteiraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteira
     */
    omit?: CarteiraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarteiraInclude<ExtArgs> | null
    /**
     * Filter, which Carteira to fetch.
     */
    where: CarteiraWhereUniqueInput
  }

  /**
   * Carteira findUniqueOrThrow
   */
  export type CarteiraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteira
     */
    select?: CarteiraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteira
     */
    omit?: CarteiraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarteiraInclude<ExtArgs> | null
    /**
     * Filter, which Carteira to fetch.
     */
    where: CarteiraWhereUniqueInput
  }

  /**
   * Carteira findFirst
   */
  export type CarteiraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteira
     */
    select?: CarteiraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteira
     */
    omit?: CarteiraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarteiraInclude<ExtArgs> | null
    /**
     * Filter, which Carteira to fetch.
     */
    where?: CarteiraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carteiras to fetch.
     */
    orderBy?: CarteiraOrderByWithRelationInput | CarteiraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carteiras.
     */
    cursor?: CarteiraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carteiras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carteiras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carteiras.
     */
    distinct?: CarteiraScalarFieldEnum | CarteiraScalarFieldEnum[]
  }

  /**
   * Carteira findFirstOrThrow
   */
  export type CarteiraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteira
     */
    select?: CarteiraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteira
     */
    omit?: CarteiraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarteiraInclude<ExtArgs> | null
    /**
     * Filter, which Carteira to fetch.
     */
    where?: CarteiraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carteiras to fetch.
     */
    orderBy?: CarteiraOrderByWithRelationInput | CarteiraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carteiras.
     */
    cursor?: CarteiraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carteiras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carteiras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carteiras.
     */
    distinct?: CarteiraScalarFieldEnum | CarteiraScalarFieldEnum[]
  }

  /**
   * Carteira findMany
   */
  export type CarteiraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteira
     */
    select?: CarteiraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteira
     */
    omit?: CarteiraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarteiraInclude<ExtArgs> | null
    /**
     * Filter, which Carteiras to fetch.
     */
    where?: CarteiraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carteiras to fetch.
     */
    orderBy?: CarteiraOrderByWithRelationInput | CarteiraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carteiras.
     */
    cursor?: CarteiraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carteiras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carteiras.
     */
    skip?: number
    distinct?: CarteiraScalarFieldEnum | CarteiraScalarFieldEnum[]
  }

  /**
   * Carteira create
   */
  export type CarteiraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteira
     */
    select?: CarteiraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteira
     */
    omit?: CarteiraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarteiraInclude<ExtArgs> | null
    /**
     * The data needed to create a Carteira.
     */
    data: XOR<CarteiraCreateInput, CarteiraUncheckedCreateInput>
  }

  /**
   * Carteira createMany
   */
  export type CarteiraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carteiras.
     */
    data: CarteiraCreateManyInput | CarteiraCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Carteira update
   */
  export type CarteiraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteira
     */
    select?: CarteiraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteira
     */
    omit?: CarteiraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarteiraInclude<ExtArgs> | null
    /**
     * The data needed to update a Carteira.
     */
    data: XOR<CarteiraUpdateInput, CarteiraUncheckedUpdateInput>
    /**
     * Choose, which Carteira to update.
     */
    where: CarteiraWhereUniqueInput
  }

  /**
   * Carteira updateMany
   */
  export type CarteiraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carteiras.
     */
    data: XOR<CarteiraUpdateManyMutationInput, CarteiraUncheckedUpdateManyInput>
    /**
     * Filter which Carteiras to update
     */
    where?: CarteiraWhereInput
    /**
     * Limit how many Carteiras to update.
     */
    limit?: number
  }

  /**
   * Carteira upsert
   */
  export type CarteiraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteira
     */
    select?: CarteiraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteira
     */
    omit?: CarteiraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarteiraInclude<ExtArgs> | null
    /**
     * The filter to search for the Carteira to update in case it exists.
     */
    where: CarteiraWhereUniqueInput
    /**
     * In case the Carteira found by the `where` argument doesn't exist, create a new Carteira with this data.
     */
    create: XOR<CarteiraCreateInput, CarteiraUncheckedCreateInput>
    /**
     * In case the Carteira was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarteiraUpdateInput, CarteiraUncheckedUpdateInput>
  }

  /**
   * Carteira delete
   */
  export type CarteiraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteira
     */
    select?: CarteiraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteira
     */
    omit?: CarteiraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarteiraInclude<ExtArgs> | null
    /**
     * Filter which Carteira to delete.
     */
    where: CarteiraWhereUniqueInput
  }

  /**
   * Carteira deleteMany
   */
  export type CarteiraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carteiras to delete
     */
    where?: CarteiraWhereInput
    /**
     * Limit how many Carteiras to delete.
     */
    limit?: number
  }

  /**
   * Carteira without action
   */
  export type CarteiraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteira
     */
    select?: CarteiraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteira
     */
    omit?: CarteiraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarteiraInclude<ExtArgs> | null
  }


  /**
   * Model Pagamento
   */

  export type AggregatePagamento = {
    _count: PagamentoCountAggregateOutputType | null
    _avg: PagamentoAvgAggregateOutputType | null
    _sum: PagamentoSumAggregateOutputType | null
    _min: PagamentoMinAggregateOutputType | null
    _max: PagamentoMaxAggregateOutputType | null
  }

  export type PagamentoAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    prestacao: number | null
    devedor_id: number | null
  }

  export type PagamentoSumAggregateOutputType = {
    id: number | null
    valor: number | null
    prestacao: number | null
    devedor_id: number | null
  }

  export type PagamentoMinAggregateOutputType = {
    id: number | null
    valor: number | null
    detalhe: string | null
    prestacao: number | null
    estado: boolean | null
    pendencia: boolean | null
    devedor_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PagamentoMaxAggregateOutputType = {
    id: number | null
    valor: number | null
    detalhe: string | null
    prestacao: number | null
    estado: boolean | null
    pendencia: boolean | null
    devedor_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PagamentoCountAggregateOutputType = {
    id: number
    valor: number
    detalhe: number
    prestacao: number
    estado: number
    pendencia: number
    devedor_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PagamentoAvgAggregateInputType = {
    id?: true
    valor?: true
    prestacao?: true
    devedor_id?: true
  }

  export type PagamentoSumAggregateInputType = {
    id?: true
    valor?: true
    prestacao?: true
    devedor_id?: true
  }

  export type PagamentoMinAggregateInputType = {
    id?: true
    valor?: true
    detalhe?: true
    prestacao?: true
    estado?: true
    pendencia?: true
    devedor_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PagamentoMaxAggregateInputType = {
    id?: true
    valor?: true
    detalhe?: true
    prestacao?: true
    estado?: true
    pendencia?: true
    devedor_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PagamentoCountAggregateInputType = {
    id?: true
    valor?: true
    detalhe?: true
    prestacao?: true
    estado?: true
    pendencia?: true
    devedor_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PagamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagamento to aggregate.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pagamentos
    **/
    _count?: true | PagamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagamentoMaxAggregateInputType
  }

  export type GetPagamentoAggregateType<T extends PagamentoAggregateArgs> = {
        [P in keyof T & keyof AggregatePagamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePagamento[P]>
      : GetScalarType<T[P], AggregatePagamento[P]>
  }




  export type PagamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagamentoWhereInput
    orderBy?: PagamentoOrderByWithAggregationInput | PagamentoOrderByWithAggregationInput[]
    by: PagamentoScalarFieldEnum[] | PagamentoScalarFieldEnum
    having?: PagamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagamentoCountAggregateInputType | true
    _avg?: PagamentoAvgAggregateInputType
    _sum?: PagamentoSumAggregateInputType
    _min?: PagamentoMinAggregateInputType
    _max?: PagamentoMaxAggregateInputType
  }

  export type PagamentoGroupByOutputType = {
    id: number
    valor: number
    detalhe: string
    prestacao: number
    estado: boolean
    pendencia: boolean
    devedor_id: number
    createdAt: Date
    updatedAt: Date
    _count: PagamentoCountAggregateOutputType | null
    _avg: PagamentoAvgAggregateOutputType | null
    _sum: PagamentoSumAggregateOutputType | null
    _min: PagamentoMinAggregateOutputType | null
    _max: PagamentoMaxAggregateOutputType | null
  }

  type GetPagamentoGroupByPayload<T extends PagamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagamentoGroupByOutputType[P]>
            : GetScalarType<T[P], PagamentoGroupByOutputType[P]>
        }
      >
    >


  export type PagamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    detalhe?: boolean
    prestacao?: boolean
    estado?: boolean
    pendencia?: boolean
    devedor_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    devedor?: boolean | DevedorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagamento"]>



  export type PagamentoSelectScalar = {
    id?: boolean
    valor?: boolean
    detalhe?: boolean
    prestacao?: boolean
    estado?: boolean
    pendencia?: boolean
    devedor_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PagamentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "valor" | "detalhe" | "prestacao" | "estado" | "pendencia" | "devedor_id" | "createdAt" | "updatedAt", ExtArgs["result"]["pagamento"]>
  export type PagamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devedor?: boolean | DevedorDefaultArgs<ExtArgs>
  }

  export type $PagamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pagamento"
    objects: {
      devedor: Prisma.$DevedorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      valor: number
      detalhe: string
      prestacao: number
      estado: boolean
      pendencia: boolean
      devedor_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pagamento"]>
    composites: {}
  }

  type PagamentoGetPayload<S extends boolean | null | undefined | PagamentoDefaultArgs> = $Result.GetResult<Prisma.$PagamentoPayload, S>

  type PagamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PagamentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PagamentoCountAggregateInputType | true
    }

  export interface PagamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pagamento'], meta: { name: 'Pagamento' } }
    /**
     * Find zero or one Pagamento that matches the filter.
     * @param {PagamentoFindUniqueArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PagamentoFindUniqueArgs>(args: SelectSubset<T, PagamentoFindUniqueArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pagamento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PagamentoFindUniqueOrThrowArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PagamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, PagamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pagamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindFirstArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PagamentoFindFirstArgs>(args?: SelectSubset<T, PagamentoFindFirstArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pagamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindFirstOrThrowArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PagamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, PagamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pagamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagamentos
     * const pagamentos = await prisma.pagamento.findMany()
     * 
     * // Get first 10 Pagamentos
     * const pagamentos = await prisma.pagamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagamentoWithIdOnly = await prisma.pagamento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PagamentoFindManyArgs>(args?: SelectSubset<T, PagamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pagamento.
     * @param {PagamentoCreateArgs} args - Arguments to create a Pagamento.
     * @example
     * // Create one Pagamento
     * const Pagamento = await prisma.pagamento.create({
     *   data: {
     *     // ... data to create a Pagamento
     *   }
     * })
     * 
     */
    create<T extends PagamentoCreateArgs>(args: SelectSubset<T, PagamentoCreateArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pagamentos.
     * @param {PagamentoCreateManyArgs} args - Arguments to create many Pagamentos.
     * @example
     * // Create many Pagamentos
     * const pagamento = await prisma.pagamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PagamentoCreateManyArgs>(args?: SelectSubset<T, PagamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pagamento.
     * @param {PagamentoDeleteArgs} args - Arguments to delete one Pagamento.
     * @example
     * // Delete one Pagamento
     * const Pagamento = await prisma.pagamento.delete({
     *   where: {
     *     // ... filter to delete one Pagamento
     *   }
     * })
     * 
     */
    delete<T extends PagamentoDeleteArgs>(args: SelectSubset<T, PagamentoDeleteArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pagamento.
     * @param {PagamentoUpdateArgs} args - Arguments to update one Pagamento.
     * @example
     * // Update one Pagamento
     * const pagamento = await prisma.pagamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PagamentoUpdateArgs>(args: SelectSubset<T, PagamentoUpdateArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pagamentos.
     * @param {PagamentoDeleteManyArgs} args - Arguments to filter Pagamentos to delete.
     * @example
     * // Delete a few Pagamentos
     * const { count } = await prisma.pagamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PagamentoDeleteManyArgs>(args?: SelectSubset<T, PagamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagamentos
     * const pagamento = await prisma.pagamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PagamentoUpdateManyArgs>(args: SelectSubset<T, PagamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pagamento.
     * @param {PagamentoUpsertArgs} args - Arguments to update or create a Pagamento.
     * @example
     * // Update or create a Pagamento
     * const pagamento = await prisma.pagamento.upsert({
     *   create: {
     *     // ... data to create a Pagamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pagamento we want to update
     *   }
     * })
     */
    upsert<T extends PagamentoUpsertArgs>(args: SelectSubset<T, PagamentoUpsertArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoCountArgs} args - Arguments to filter Pagamentos to count.
     * @example
     * // Count the number of Pagamentos
     * const count = await prisma.pagamento.count({
     *   where: {
     *     // ... the filter for the Pagamentos we want to count
     *   }
     * })
    **/
    count<T extends PagamentoCountArgs>(
      args?: Subset<T, PagamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagamentoAggregateArgs>(args: Subset<T, PagamentoAggregateArgs>): Prisma.PrismaPromise<GetPagamentoAggregateType<T>>

    /**
     * Group by Pagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagamentoGroupByArgs['orderBy'] }
        : { orderBy?: PagamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pagamento model
   */
  readonly fields: PagamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pagamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PagamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    devedor<T extends DevedorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DevedorDefaultArgs<ExtArgs>>): Prisma__DevedorClient<$Result.GetResult<Prisma.$DevedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pagamento model
   */
  interface PagamentoFieldRefs {
    readonly id: FieldRef<"Pagamento", 'Int'>
    readonly valor: FieldRef<"Pagamento", 'Float'>
    readonly detalhe: FieldRef<"Pagamento", 'String'>
    readonly prestacao: FieldRef<"Pagamento", 'Int'>
    readonly estado: FieldRef<"Pagamento", 'Boolean'>
    readonly pendencia: FieldRef<"Pagamento", 'Boolean'>
    readonly devedor_id: FieldRef<"Pagamento", 'Int'>
    readonly createdAt: FieldRef<"Pagamento", 'DateTime'>
    readonly updatedAt: FieldRef<"Pagamento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pagamento findUnique
   */
  export type PagamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento findUniqueOrThrow
   */
  export type PagamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento findFirst
   */
  export type PagamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagamentos.
     */
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento findFirstOrThrow
   */
  export type PagamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagamentos.
     */
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento findMany
   */
  export type PagamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamentos to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento create
   */
  export type PagamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pagamento.
     */
    data: XOR<PagamentoCreateInput, PagamentoUncheckedCreateInput>
  }

  /**
   * Pagamento createMany
   */
  export type PagamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pagamentos.
     */
    data: PagamentoCreateManyInput | PagamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pagamento update
   */
  export type PagamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pagamento.
     */
    data: XOR<PagamentoUpdateInput, PagamentoUncheckedUpdateInput>
    /**
     * Choose, which Pagamento to update.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento updateMany
   */
  export type PagamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pagamentos.
     */
    data: XOR<PagamentoUpdateManyMutationInput, PagamentoUncheckedUpdateManyInput>
    /**
     * Filter which Pagamentos to update
     */
    where?: PagamentoWhereInput
    /**
     * Limit how many Pagamentos to update.
     */
    limit?: number
  }

  /**
   * Pagamento upsert
   */
  export type PagamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pagamento to update in case it exists.
     */
    where: PagamentoWhereUniqueInput
    /**
     * In case the Pagamento found by the `where` argument doesn't exist, create a new Pagamento with this data.
     */
    create: XOR<PagamentoCreateInput, PagamentoUncheckedCreateInput>
    /**
     * In case the Pagamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PagamentoUpdateInput, PagamentoUncheckedUpdateInput>
  }

  /**
   * Pagamento delete
   */
  export type PagamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter which Pagamento to delete.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento deleteMany
   */
  export type PagamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagamentos to delete
     */
    where?: PagamentoWhereInput
    /**
     * Limit how many Pagamentos to delete.
     */
    limit?: number
  }

  /**
   * Pagamento without action
   */
  export type PagamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
  }


  /**
   * Model Reembolso
   */

  export type AggregateReembolso = {
    _count: ReembolsoCountAggregateOutputType | null
    _avg: ReembolsoAvgAggregateOutputType | null
    _sum: ReembolsoSumAggregateOutputType | null
    _min: ReembolsoMinAggregateOutputType | null
    _max: ReembolsoMaxAggregateOutputType | null
  }

  export type ReembolsoAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    prestacao: number | null
    proponente_id: number | null
  }

  export type ReembolsoSumAggregateOutputType = {
    id: number | null
    valor: number | null
    prestacao: number | null
    proponente_id: number | null
  }

  export type ReembolsoMinAggregateOutputType = {
    id: number | null
    valor: number | null
    prestacao: number | null
    estado: boolean | null
    detalhe: string | null
    proponente_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReembolsoMaxAggregateOutputType = {
    id: number | null
    valor: number | null
    prestacao: number | null
    estado: boolean | null
    detalhe: string | null
    proponente_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReembolsoCountAggregateOutputType = {
    id: number
    valor: number
    prestacao: number
    estado: number
    detalhe: number
    proponente_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReembolsoAvgAggregateInputType = {
    id?: true
    valor?: true
    prestacao?: true
    proponente_id?: true
  }

  export type ReembolsoSumAggregateInputType = {
    id?: true
    valor?: true
    prestacao?: true
    proponente_id?: true
  }

  export type ReembolsoMinAggregateInputType = {
    id?: true
    valor?: true
    prestacao?: true
    estado?: true
    detalhe?: true
    proponente_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReembolsoMaxAggregateInputType = {
    id?: true
    valor?: true
    prestacao?: true
    estado?: true
    detalhe?: true
    proponente_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReembolsoCountAggregateInputType = {
    id?: true
    valor?: true
    prestacao?: true
    estado?: true
    detalhe?: true
    proponente_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReembolsoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reembolso to aggregate.
     */
    where?: ReembolsoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reembolsos to fetch.
     */
    orderBy?: ReembolsoOrderByWithRelationInput | ReembolsoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReembolsoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reembolsos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reembolsos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reembolsos
    **/
    _count?: true | ReembolsoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReembolsoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReembolsoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReembolsoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReembolsoMaxAggregateInputType
  }

  export type GetReembolsoAggregateType<T extends ReembolsoAggregateArgs> = {
        [P in keyof T & keyof AggregateReembolso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReembolso[P]>
      : GetScalarType<T[P], AggregateReembolso[P]>
  }




  export type ReembolsoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReembolsoWhereInput
    orderBy?: ReembolsoOrderByWithAggregationInput | ReembolsoOrderByWithAggregationInput[]
    by: ReembolsoScalarFieldEnum[] | ReembolsoScalarFieldEnum
    having?: ReembolsoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReembolsoCountAggregateInputType | true
    _avg?: ReembolsoAvgAggregateInputType
    _sum?: ReembolsoSumAggregateInputType
    _min?: ReembolsoMinAggregateInputType
    _max?: ReembolsoMaxAggregateInputType
  }

  export type ReembolsoGroupByOutputType = {
    id: number
    valor: number
    prestacao: number
    estado: boolean
    detalhe: string
    proponente_id: number
    createdAt: Date
    updatedAt: Date
    _count: ReembolsoCountAggregateOutputType | null
    _avg: ReembolsoAvgAggregateOutputType | null
    _sum: ReembolsoSumAggregateOutputType | null
    _min: ReembolsoMinAggregateOutputType | null
    _max: ReembolsoMaxAggregateOutputType | null
  }

  type GetReembolsoGroupByPayload<T extends ReembolsoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReembolsoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReembolsoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReembolsoGroupByOutputType[P]>
            : GetScalarType<T[P], ReembolsoGroupByOutputType[P]>
        }
      >
    >


  export type ReembolsoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    prestacao?: boolean
    estado?: boolean
    detalhe?: boolean
    proponente_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proponente?: boolean | ProponenteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reembolso"]>



  export type ReembolsoSelectScalar = {
    id?: boolean
    valor?: boolean
    prestacao?: boolean
    estado?: boolean
    detalhe?: boolean
    proponente_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReembolsoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "valor" | "prestacao" | "estado" | "detalhe" | "proponente_id" | "createdAt" | "updatedAt", ExtArgs["result"]["reembolso"]>
  export type ReembolsoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proponente?: boolean | ProponenteDefaultArgs<ExtArgs>
  }

  export type $ReembolsoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reembolso"
    objects: {
      proponente: Prisma.$ProponentePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      valor: number
      prestacao: number
      estado: boolean
      detalhe: string
      proponente_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reembolso"]>
    composites: {}
  }

  type ReembolsoGetPayload<S extends boolean | null | undefined | ReembolsoDefaultArgs> = $Result.GetResult<Prisma.$ReembolsoPayload, S>

  type ReembolsoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReembolsoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReembolsoCountAggregateInputType | true
    }

  export interface ReembolsoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reembolso'], meta: { name: 'Reembolso' } }
    /**
     * Find zero or one Reembolso that matches the filter.
     * @param {ReembolsoFindUniqueArgs} args - Arguments to find a Reembolso
     * @example
     * // Get one Reembolso
     * const reembolso = await prisma.reembolso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReembolsoFindUniqueArgs>(args: SelectSubset<T, ReembolsoFindUniqueArgs<ExtArgs>>): Prisma__ReembolsoClient<$Result.GetResult<Prisma.$ReembolsoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reembolso that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReembolsoFindUniqueOrThrowArgs} args - Arguments to find a Reembolso
     * @example
     * // Get one Reembolso
     * const reembolso = await prisma.reembolso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReembolsoFindUniqueOrThrowArgs>(args: SelectSubset<T, ReembolsoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReembolsoClient<$Result.GetResult<Prisma.$ReembolsoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reembolso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReembolsoFindFirstArgs} args - Arguments to find a Reembolso
     * @example
     * // Get one Reembolso
     * const reembolso = await prisma.reembolso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReembolsoFindFirstArgs>(args?: SelectSubset<T, ReembolsoFindFirstArgs<ExtArgs>>): Prisma__ReembolsoClient<$Result.GetResult<Prisma.$ReembolsoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reembolso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReembolsoFindFirstOrThrowArgs} args - Arguments to find a Reembolso
     * @example
     * // Get one Reembolso
     * const reembolso = await prisma.reembolso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReembolsoFindFirstOrThrowArgs>(args?: SelectSubset<T, ReembolsoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReembolsoClient<$Result.GetResult<Prisma.$ReembolsoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reembolsos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReembolsoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reembolsos
     * const reembolsos = await prisma.reembolso.findMany()
     * 
     * // Get first 10 Reembolsos
     * const reembolsos = await prisma.reembolso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reembolsoWithIdOnly = await prisma.reembolso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReembolsoFindManyArgs>(args?: SelectSubset<T, ReembolsoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReembolsoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reembolso.
     * @param {ReembolsoCreateArgs} args - Arguments to create a Reembolso.
     * @example
     * // Create one Reembolso
     * const Reembolso = await prisma.reembolso.create({
     *   data: {
     *     // ... data to create a Reembolso
     *   }
     * })
     * 
     */
    create<T extends ReembolsoCreateArgs>(args: SelectSubset<T, ReembolsoCreateArgs<ExtArgs>>): Prisma__ReembolsoClient<$Result.GetResult<Prisma.$ReembolsoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reembolsos.
     * @param {ReembolsoCreateManyArgs} args - Arguments to create many Reembolsos.
     * @example
     * // Create many Reembolsos
     * const reembolso = await prisma.reembolso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReembolsoCreateManyArgs>(args?: SelectSubset<T, ReembolsoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reembolso.
     * @param {ReembolsoDeleteArgs} args - Arguments to delete one Reembolso.
     * @example
     * // Delete one Reembolso
     * const Reembolso = await prisma.reembolso.delete({
     *   where: {
     *     // ... filter to delete one Reembolso
     *   }
     * })
     * 
     */
    delete<T extends ReembolsoDeleteArgs>(args: SelectSubset<T, ReembolsoDeleteArgs<ExtArgs>>): Prisma__ReembolsoClient<$Result.GetResult<Prisma.$ReembolsoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reembolso.
     * @param {ReembolsoUpdateArgs} args - Arguments to update one Reembolso.
     * @example
     * // Update one Reembolso
     * const reembolso = await prisma.reembolso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReembolsoUpdateArgs>(args: SelectSubset<T, ReembolsoUpdateArgs<ExtArgs>>): Prisma__ReembolsoClient<$Result.GetResult<Prisma.$ReembolsoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reembolsos.
     * @param {ReembolsoDeleteManyArgs} args - Arguments to filter Reembolsos to delete.
     * @example
     * // Delete a few Reembolsos
     * const { count } = await prisma.reembolso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReembolsoDeleteManyArgs>(args?: SelectSubset<T, ReembolsoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reembolsos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReembolsoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reembolsos
     * const reembolso = await prisma.reembolso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReembolsoUpdateManyArgs>(args: SelectSubset<T, ReembolsoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reembolso.
     * @param {ReembolsoUpsertArgs} args - Arguments to update or create a Reembolso.
     * @example
     * // Update or create a Reembolso
     * const reembolso = await prisma.reembolso.upsert({
     *   create: {
     *     // ... data to create a Reembolso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reembolso we want to update
     *   }
     * })
     */
    upsert<T extends ReembolsoUpsertArgs>(args: SelectSubset<T, ReembolsoUpsertArgs<ExtArgs>>): Prisma__ReembolsoClient<$Result.GetResult<Prisma.$ReembolsoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reembolsos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReembolsoCountArgs} args - Arguments to filter Reembolsos to count.
     * @example
     * // Count the number of Reembolsos
     * const count = await prisma.reembolso.count({
     *   where: {
     *     // ... the filter for the Reembolsos we want to count
     *   }
     * })
    **/
    count<T extends ReembolsoCountArgs>(
      args?: Subset<T, ReembolsoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReembolsoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reembolso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReembolsoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReembolsoAggregateArgs>(args: Subset<T, ReembolsoAggregateArgs>): Prisma.PrismaPromise<GetReembolsoAggregateType<T>>

    /**
     * Group by Reembolso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReembolsoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReembolsoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReembolsoGroupByArgs['orderBy'] }
        : { orderBy?: ReembolsoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReembolsoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReembolsoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reembolso model
   */
  readonly fields: ReembolsoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reembolso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReembolsoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proponente<T extends ProponenteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProponenteDefaultArgs<ExtArgs>>): Prisma__ProponenteClient<$Result.GetResult<Prisma.$ProponentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reembolso model
   */
  interface ReembolsoFieldRefs {
    readonly id: FieldRef<"Reembolso", 'Int'>
    readonly valor: FieldRef<"Reembolso", 'Float'>
    readonly prestacao: FieldRef<"Reembolso", 'Int'>
    readonly estado: FieldRef<"Reembolso", 'Boolean'>
    readonly detalhe: FieldRef<"Reembolso", 'String'>
    readonly proponente_id: FieldRef<"Reembolso", 'Int'>
    readonly createdAt: FieldRef<"Reembolso", 'DateTime'>
    readonly updatedAt: FieldRef<"Reembolso", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reembolso findUnique
   */
  export type ReembolsoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reembolso
     */
    select?: ReembolsoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reembolso
     */
    omit?: ReembolsoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReembolsoInclude<ExtArgs> | null
    /**
     * Filter, which Reembolso to fetch.
     */
    where: ReembolsoWhereUniqueInput
  }

  /**
   * Reembolso findUniqueOrThrow
   */
  export type ReembolsoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reembolso
     */
    select?: ReembolsoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reembolso
     */
    omit?: ReembolsoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReembolsoInclude<ExtArgs> | null
    /**
     * Filter, which Reembolso to fetch.
     */
    where: ReembolsoWhereUniqueInput
  }

  /**
   * Reembolso findFirst
   */
  export type ReembolsoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reembolso
     */
    select?: ReembolsoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reembolso
     */
    omit?: ReembolsoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReembolsoInclude<ExtArgs> | null
    /**
     * Filter, which Reembolso to fetch.
     */
    where?: ReembolsoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reembolsos to fetch.
     */
    orderBy?: ReembolsoOrderByWithRelationInput | ReembolsoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reembolsos.
     */
    cursor?: ReembolsoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reembolsos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reembolsos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reembolsos.
     */
    distinct?: ReembolsoScalarFieldEnum | ReembolsoScalarFieldEnum[]
  }

  /**
   * Reembolso findFirstOrThrow
   */
  export type ReembolsoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reembolso
     */
    select?: ReembolsoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reembolso
     */
    omit?: ReembolsoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReembolsoInclude<ExtArgs> | null
    /**
     * Filter, which Reembolso to fetch.
     */
    where?: ReembolsoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reembolsos to fetch.
     */
    orderBy?: ReembolsoOrderByWithRelationInput | ReembolsoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reembolsos.
     */
    cursor?: ReembolsoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reembolsos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reembolsos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reembolsos.
     */
    distinct?: ReembolsoScalarFieldEnum | ReembolsoScalarFieldEnum[]
  }

  /**
   * Reembolso findMany
   */
  export type ReembolsoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reembolso
     */
    select?: ReembolsoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reembolso
     */
    omit?: ReembolsoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReembolsoInclude<ExtArgs> | null
    /**
     * Filter, which Reembolsos to fetch.
     */
    where?: ReembolsoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reembolsos to fetch.
     */
    orderBy?: ReembolsoOrderByWithRelationInput | ReembolsoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reembolsos.
     */
    cursor?: ReembolsoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reembolsos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reembolsos.
     */
    skip?: number
    distinct?: ReembolsoScalarFieldEnum | ReembolsoScalarFieldEnum[]
  }

  /**
   * Reembolso create
   */
  export type ReembolsoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reembolso
     */
    select?: ReembolsoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reembolso
     */
    omit?: ReembolsoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReembolsoInclude<ExtArgs> | null
    /**
     * The data needed to create a Reembolso.
     */
    data: XOR<ReembolsoCreateInput, ReembolsoUncheckedCreateInput>
  }

  /**
   * Reembolso createMany
   */
  export type ReembolsoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reembolsos.
     */
    data: ReembolsoCreateManyInput | ReembolsoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reembolso update
   */
  export type ReembolsoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reembolso
     */
    select?: ReembolsoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reembolso
     */
    omit?: ReembolsoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReembolsoInclude<ExtArgs> | null
    /**
     * The data needed to update a Reembolso.
     */
    data: XOR<ReembolsoUpdateInput, ReembolsoUncheckedUpdateInput>
    /**
     * Choose, which Reembolso to update.
     */
    where: ReembolsoWhereUniqueInput
  }

  /**
   * Reembolso updateMany
   */
  export type ReembolsoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reembolsos.
     */
    data: XOR<ReembolsoUpdateManyMutationInput, ReembolsoUncheckedUpdateManyInput>
    /**
     * Filter which Reembolsos to update
     */
    where?: ReembolsoWhereInput
    /**
     * Limit how many Reembolsos to update.
     */
    limit?: number
  }

  /**
   * Reembolso upsert
   */
  export type ReembolsoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reembolso
     */
    select?: ReembolsoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reembolso
     */
    omit?: ReembolsoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReembolsoInclude<ExtArgs> | null
    /**
     * The filter to search for the Reembolso to update in case it exists.
     */
    where: ReembolsoWhereUniqueInput
    /**
     * In case the Reembolso found by the `where` argument doesn't exist, create a new Reembolso with this data.
     */
    create: XOR<ReembolsoCreateInput, ReembolsoUncheckedCreateInput>
    /**
     * In case the Reembolso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReembolsoUpdateInput, ReembolsoUncheckedUpdateInput>
  }

  /**
   * Reembolso delete
   */
  export type ReembolsoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reembolso
     */
    select?: ReembolsoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reembolso
     */
    omit?: ReembolsoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReembolsoInclude<ExtArgs> | null
    /**
     * Filter which Reembolso to delete.
     */
    where: ReembolsoWhereUniqueInput
  }

  /**
   * Reembolso deleteMany
   */
  export type ReembolsoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reembolsos to delete
     */
    where?: ReembolsoWhereInput
    /**
     * Limit how many Reembolsos to delete.
     */
    limit?: number
  }

  /**
   * Reembolso without action
   */
  export type ReembolsoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reembolso
     */
    select?: ReembolsoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reembolso
     */
    omit?: ReembolsoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReembolsoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    primeiro_nome: 'primeiro_nome',
    segundo_nome: 'segundo_nome',
    password: 'password',
    genero: 'genero',
    bilhete: 'bilhete',
    telemovel: 'telemovel',
    email: 'email',
    estado: 'estado'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EmpregoScalarFieldEnum: {
    id: 'id',
    data_inicio: 'data_inicio',
    sector: 'sector',
    cargo: 'cargo',
    area: 'area',
    estado: 'estado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmpregoScalarFieldEnum = (typeof EmpregoScalarFieldEnum)[keyof typeof EmpregoScalarFieldEnum]


  export const ResidenciaScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    data_inicio: 'data_inicio',
    estado: 'estado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResidenciaScalarFieldEnum = (typeof ResidenciaScalarFieldEnum)[keyof typeof ResidenciaScalarFieldEnum]


  export const PapelScalarFieldEnum: {
    id: 'id',
    perfil: 'perfil',
    user_id: 'user_id',
    estado: 'estado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PapelScalarFieldEnum = (typeof PapelScalarFieldEnum)[keyof typeof PapelScalarFieldEnum]


  export const PessoaScalarFieldEnum: {
    id: 'id',
    estado_civil: 'estado_civil',
    provincia: 'provincia',
    municipio: 'municipio',
    profissao: 'profissao',
    estado: 'estado',
    nivel_instrucao: 'nivel_instrucao',
    data_nascimento: 'data_nascimento',
    user_id: 'user_id',
    emprego_id: 'emprego_id',
    residencia_id: 'residencia_id'
  };

  export type PessoaScalarFieldEnum = (typeof PessoaScalarFieldEnum)[keyof typeof PessoaScalarFieldEnum]


  export const ContaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    salario: 'salario',
    iban: 'iban',
    estado: 'estado',
    pessoa_id: 'pessoa_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContaScalarFieldEnum = (typeof ContaScalarFieldEnum)[keyof typeof ContaScalarFieldEnum]


  export const ConjugueScalarFieldEnum: {
    id: 'id',
    nome_completo: 'nome_completo',
    dependentes: 'dependentes',
    nivel_instrucao: 'nivel_instrucao',
    estado: 'estado',
    data_nascimento: 'data_nascimento',
    pessoa_id: 'pessoa_id'
  };

  export type ConjugueScalarFieldEnum = (typeof ConjugueScalarFieldEnum)[keyof typeof ConjugueScalarFieldEnum]


  export const DocumentoScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    titulo: 'titulo',
    extensao: 'extensao',
    tamanho: 'tamanho',
    nome_original: 'nome_original',
    nome_salvado: 'nome_salvado',
    estado: 'estado',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentoScalarFieldEnum = (typeof DocumentoScalarFieldEnum)[keyof typeof DocumentoScalarFieldEnum]


  export const DevedorScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    solicitacao: 'solicitacao',
    adimplencia: 'adimplencia',
    inadimplencia: 'inadimplencia',
    estado: 'estado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DevedorScalarFieldEnum = (typeof DevedorScalarFieldEnum)[keyof typeof DevedorScalarFieldEnum]


  export const InvestidorScalarFieldEnum: {
    id: 'id',
    maior_risco: 'maior_risco',
    maior_seguranca: 'maior_seguranca',
    saque_antecipado: 'saque_antecipado',
    fundo_protegido: 'fundo_protegido',
    estado: 'estado',
    partilhar_emprestimo: 'partilhar_emprestimo',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvestidorScalarFieldEnum = (typeof InvestidorScalarFieldEnum)[keyof typeof InvestidorScalarFieldEnum]


  export const ReclamacaoScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    estado: 'estado',
    assunto: 'assunto',
    conteudo: 'conteudo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReclamacaoScalarFieldEnum = (typeof ReclamacaoScalarFieldEnum)[keyof typeof ReclamacaoScalarFieldEnum]


  export const ProponenteScalarFieldEnum: {
    id: 'id',
    solicitacao: 'solicitacao',
    reembolsar: 'reembolsar',
    satisfeitos: 'satisfeitos',
    insatisfeitos: 'insatisfeitos',
    estado: 'estado',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProponenteScalarFieldEnum = (typeof ProponenteScalarFieldEnum)[keyof typeof ProponenteScalarFieldEnum]


  export const SolidarioScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    parentesco: 'parentesco',
    taxa: 'taxa',
    estado: 'estado',
    pessoa_id: 'pessoa_id',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SolidarioScalarFieldEnum = (typeof SolidarioScalarFieldEnum)[keyof typeof SolidarioScalarFieldEnum]


  export const MovelScalarFieldEnum: {
    id: 'id',
    modelo: 'modelo',
    matricula: 'matricula',
    detalhes: 'detalhes',
    devedor_id: 'devedor_id',
    estado: 'estado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MovelScalarFieldEnum = (typeof MovelScalarFieldEnum)[keyof typeof MovelScalarFieldEnum]


  export const CreditoScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    valor: 'valor',
    prestacao: 'prestacao',
    juro: 'juro',
    termino: 'termino',
    estado: 'estado',
    pendencia: 'pendencia',
    progresso: 'progresso',
    devedor_id: 'devedor_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CreditoScalarFieldEnum = (typeof CreditoScalarFieldEnum)[keyof typeof CreditoScalarFieldEnum]


  export const EmprestimoScalarFieldEnum: {
    id: 'id',
    valor: 'valor',
    juro_proponente: 'juro_proponente',
    taxa_investidor: 'taxa_investidor',
    prestacao: 'prestacao',
    termino: 'termino',
    estado: 'estado',
    pendencia: 'pendencia',
    progresso: 'progresso',
    proponente_id: 'proponente_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmprestimoScalarFieldEnum = (typeof EmprestimoScalarFieldEnum)[keyof typeof EmprestimoScalarFieldEnum]


  export const EmprestimoSolidarioScalarFieldEnum: {
    estado: 'estado',
    solidario_id: 'solidario_id',
    emprestimo_id: 'emprestimo_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmprestimoSolidarioScalarFieldEnum = (typeof EmprestimoSolidarioScalarFieldEnum)[keyof typeof EmprestimoSolidarioScalarFieldEnum]


  export const CreditoSolidarioScalarFieldEnum: {
    estado: 'estado',
    solidario_id: 'solidario_id',
    credito_id: 'credito_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CreditoSolidarioScalarFieldEnum = (typeof CreditoSolidarioScalarFieldEnum)[keyof typeof CreditoSolidarioScalarFieldEnum]


  export const DiversificacaoScalarFieldEnum: {
    estado: 'estado',
    investidor_id: 'investidor_id',
    emprestimo_id: 'emprestimo_id',
    taxa: 'taxa',
    protencao: 'protencao',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DiversificacaoScalarFieldEnum = (typeof DiversificacaoScalarFieldEnum)[keyof typeof DiversificacaoScalarFieldEnum]


  export const SaqueScalarFieldEnum: {
    id: 'id',
    valor: 'valor',
    taxa: 'taxa',
    estado: 'estado',
    pendencia: 'pendencia',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SaqueScalarFieldEnum = (typeof SaqueScalarFieldEnum)[keyof typeof SaqueScalarFieldEnum]


  export const DepositoScalarFieldEnum: {
    id: 'id',
    valor: 'valor',
    estado: 'estado',
    pendencia: 'pendencia',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepositoScalarFieldEnum = (typeof DepositoScalarFieldEnum)[keyof typeof DepositoScalarFieldEnum]


  export const CarteiraScalarFieldEnum: {
    id: 'id',
    saldo: 'saldo',
    estado: 'estado',
    numero: 'numero',
    codigo: 'codigo',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CarteiraScalarFieldEnum = (typeof CarteiraScalarFieldEnum)[keyof typeof CarteiraScalarFieldEnum]


  export const PagamentoScalarFieldEnum: {
    id: 'id',
    valor: 'valor',
    detalhe: 'detalhe',
    prestacao: 'prestacao',
    estado: 'estado',
    pendencia: 'pendencia',
    devedor_id: 'devedor_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PagamentoScalarFieldEnum = (typeof PagamentoScalarFieldEnum)[keyof typeof PagamentoScalarFieldEnum]


  export const ReembolsoScalarFieldEnum: {
    id: 'id',
    valor: 'valor',
    prestacao: 'prestacao',
    estado: 'estado',
    detalhe: 'detalhe',
    proponente_id: 'proponente_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReembolsoScalarFieldEnum = (typeof ReembolsoScalarFieldEnum)[keyof typeof ReembolsoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const UserOrderByRelevanceFieldEnum: {
    primeiro_nome: 'primeiro_nome',
    segundo_nome: 'segundo_nome',
    password: 'password',
    bilhete: 'bilhete',
    telemovel: 'telemovel',
    email: 'email'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const EmpregoOrderByRelevanceFieldEnum: {
    cargo: 'cargo'
  };

  export type EmpregoOrderByRelevanceFieldEnum = (typeof EmpregoOrderByRelevanceFieldEnum)[keyof typeof EmpregoOrderByRelevanceFieldEnum]


  export const PessoaOrderByRelevanceFieldEnum: {
    provincia: 'provincia',
    municipio: 'municipio',
    profissao: 'profissao',
    nivel_instrucao: 'nivel_instrucao'
  };

  export type PessoaOrderByRelevanceFieldEnum = (typeof PessoaOrderByRelevanceFieldEnum)[keyof typeof PessoaOrderByRelevanceFieldEnum]


  export const ContaOrderByRelevanceFieldEnum: {
    nome: 'nome',
    iban: 'iban'
  };

  export type ContaOrderByRelevanceFieldEnum = (typeof ContaOrderByRelevanceFieldEnum)[keyof typeof ContaOrderByRelevanceFieldEnum]


  export const ConjugueOrderByRelevanceFieldEnum: {
    nome_completo: 'nome_completo',
    nivel_instrucao: 'nivel_instrucao'
  };

  export type ConjugueOrderByRelevanceFieldEnum = (typeof ConjugueOrderByRelevanceFieldEnum)[keyof typeof ConjugueOrderByRelevanceFieldEnum]


  export const DocumentoOrderByRelevanceFieldEnum: {
    titulo: 'titulo',
    extensao: 'extensao',
    tamanho: 'tamanho',
    nome_original: 'nome_original',
    nome_salvado: 'nome_salvado'
  };

  export type DocumentoOrderByRelevanceFieldEnum = (typeof DocumentoOrderByRelevanceFieldEnum)[keyof typeof DocumentoOrderByRelevanceFieldEnum]


  export const ReclamacaoOrderByRelevanceFieldEnum: {
    assunto: 'assunto',
    conteudo: 'conteudo'
  };

  export type ReclamacaoOrderByRelevanceFieldEnum = (typeof ReclamacaoOrderByRelevanceFieldEnum)[keyof typeof ReclamacaoOrderByRelevanceFieldEnum]


  export const MovelOrderByRelevanceFieldEnum: {
    matricula: 'matricula',
    detalhes: 'detalhes'
  };

  export type MovelOrderByRelevanceFieldEnum = (typeof MovelOrderByRelevanceFieldEnum)[keyof typeof MovelOrderByRelevanceFieldEnum]


  export const PagamentoOrderByRelevanceFieldEnum: {
    detalhe: 'detalhe'
  };

  export type PagamentoOrderByRelevanceFieldEnum = (typeof PagamentoOrderByRelevanceFieldEnum)[keyof typeof PagamentoOrderByRelevanceFieldEnum]


  export const ReembolsoOrderByRelevanceFieldEnum: {
    detalhe: 'detalhe'
  };

  export type ReembolsoOrderByRelevanceFieldEnum = (typeof ReembolsoOrderByRelevanceFieldEnum)[keyof typeof ReembolsoOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Genero'
   */
  export type EnumGeneroFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Genero'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Sector'
   */
  export type EnumSectorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sector'>
    


  /**
   * Reference to a field of type 'Area'
   */
  export type EnumAreaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Area'>
    


  /**
   * Reference to a field of type 'Propriedade'
   */
  export type EnumPropriedadeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Propriedade'>
    


  /**
   * Reference to a field of type 'Perfil'
   */
  export type EnumPerfilFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Perfil'>
    


  /**
   * Reference to a field of type 'Estado'
   */
  export type EnumEstadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Estado'>
    


  /**
   * Reference to a field of type 'Comprovativo'
   */
  export type EnumComprovativoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Comprovativo'>
    


  /**
   * Reference to a field of type 'Aval'
   */
  export type EnumAvalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Aval'>
    


  /**
   * Reference to a field of type 'Parentesco'
   */
  export type EnumParentescoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Parentesco'>
    


  /**
   * Reference to a field of type 'Modelo'
   */
  export type EnumModeloFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Modelo'>
    


  /**
   * Reference to a field of type 'Produto'
   */
  export type EnumProdutoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Produto'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Progresso'
   */
  export type EnumProgressoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Progresso'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    primeiro_nome?: StringFilter<"User"> | string
    segundo_nome?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    genero?: EnumGeneroFilter<"User"> | $Enums.Genero
    bilhete?: StringFilter<"User"> | string
    telemovel?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    estado?: BoolFilter<"User"> | boolean
    pessoa?: XOR<PessoaNullableScalarRelationFilter, PessoaWhereInput> | null
    documento?: DocumentoListRelationFilter
    devedor?: XOR<DevedorNullableScalarRelationFilter, DevedorWhereInput> | null
    investidor?: XOR<InvestidorNullableScalarRelationFilter, InvestidorWhereInput> | null
    reclamacao?: ReclamacaoListRelationFilter
    proponente?: XOR<ProponenteNullableScalarRelationFilter, ProponenteWhereInput> | null
    saque?: SaqueListRelationFilter
    deposito?: DepositoListRelationFilter
    carteira?: XOR<CarteiraNullableScalarRelationFilter, CarteiraWhereInput> | null
    papel?: XOR<PapelNullableScalarRelationFilter, PapelWhereInput> | null
    solidario?: SolidarioListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    primeiro_nome?: SortOrder
    segundo_nome?: SortOrder
    password?: SortOrder
    genero?: SortOrder
    bilhete?: SortOrder
    telemovel?: SortOrder
    email?: SortOrder
    estado?: SortOrder
    pessoa?: PessoaOrderByWithRelationInput
    documento?: DocumentoOrderByRelationAggregateInput
    devedor?: DevedorOrderByWithRelationInput
    investidor?: InvestidorOrderByWithRelationInput
    reclamacao?: ReclamacaoOrderByRelationAggregateInput
    proponente?: ProponenteOrderByWithRelationInput
    saque?: SaqueOrderByRelationAggregateInput
    deposito?: DepositoOrderByRelationAggregateInput
    carteira?: CarteiraOrderByWithRelationInput
    papel?: PapelOrderByWithRelationInput
    solidario?: SolidarioOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    password?: string
    bilhete?: string
    telemovel?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    primeiro_nome?: StringFilter<"User"> | string
    segundo_nome?: StringFilter<"User"> | string
    genero?: EnumGeneroFilter<"User"> | $Enums.Genero
    estado?: BoolFilter<"User"> | boolean
    pessoa?: XOR<PessoaNullableScalarRelationFilter, PessoaWhereInput> | null
    documento?: DocumentoListRelationFilter
    devedor?: XOR<DevedorNullableScalarRelationFilter, DevedorWhereInput> | null
    investidor?: XOR<InvestidorNullableScalarRelationFilter, InvestidorWhereInput> | null
    reclamacao?: ReclamacaoListRelationFilter
    proponente?: XOR<ProponenteNullableScalarRelationFilter, ProponenteWhereInput> | null
    saque?: SaqueListRelationFilter
    deposito?: DepositoListRelationFilter
    carteira?: XOR<CarteiraNullableScalarRelationFilter, CarteiraWhereInput> | null
    papel?: XOR<PapelNullableScalarRelationFilter, PapelWhereInput> | null
    solidario?: SolidarioListRelationFilter
  }, "id" | "password" | "bilhete" | "telemovel" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    primeiro_nome?: SortOrder
    segundo_nome?: SortOrder
    password?: SortOrder
    genero?: SortOrder
    bilhete?: SortOrder
    telemovel?: SortOrder
    email?: SortOrder
    estado?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    primeiro_nome?: StringWithAggregatesFilter<"User"> | string
    segundo_nome?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    genero?: EnumGeneroWithAggregatesFilter<"User"> | $Enums.Genero
    bilhete?: StringWithAggregatesFilter<"User"> | string
    telemovel?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    estado?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type EmpregoWhereInput = {
    AND?: EmpregoWhereInput | EmpregoWhereInput[]
    OR?: EmpregoWhereInput[]
    NOT?: EmpregoWhereInput | EmpregoWhereInput[]
    id?: IntFilter<"Emprego"> | number
    data_inicio?: DateTimeFilter<"Emprego"> | Date | string
    sector?: EnumSectorFilter<"Emprego"> | $Enums.Sector
    cargo?: StringFilter<"Emprego"> | string
    area?: EnumAreaFilter<"Emprego"> | $Enums.Area
    estado?: BoolFilter<"Emprego"> | boolean
    createdAt?: DateTimeFilter<"Emprego"> | Date | string
    updatedAt?: DateTimeFilter<"Emprego"> | Date | string
    pessoa?: PessoaListRelationFilter
  }

  export type EmpregoOrderByWithRelationInput = {
    id?: SortOrder
    data_inicio?: SortOrder
    sector?: SortOrder
    cargo?: SortOrder
    area?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pessoa?: PessoaOrderByRelationAggregateInput
    _relevance?: EmpregoOrderByRelevanceInput
  }

  export type EmpregoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmpregoWhereInput | EmpregoWhereInput[]
    OR?: EmpregoWhereInput[]
    NOT?: EmpregoWhereInput | EmpregoWhereInput[]
    data_inicio?: DateTimeFilter<"Emprego"> | Date | string
    sector?: EnumSectorFilter<"Emprego"> | $Enums.Sector
    cargo?: StringFilter<"Emprego"> | string
    area?: EnumAreaFilter<"Emprego"> | $Enums.Area
    estado?: BoolFilter<"Emprego"> | boolean
    createdAt?: DateTimeFilter<"Emprego"> | Date | string
    updatedAt?: DateTimeFilter<"Emprego"> | Date | string
    pessoa?: PessoaListRelationFilter
  }, "id">

  export type EmpregoOrderByWithAggregationInput = {
    id?: SortOrder
    data_inicio?: SortOrder
    sector?: SortOrder
    cargo?: SortOrder
    area?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmpregoCountOrderByAggregateInput
    _avg?: EmpregoAvgOrderByAggregateInput
    _max?: EmpregoMaxOrderByAggregateInput
    _min?: EmpregoMinOrderByAggregateInput
    _sum?: EmpregoSumOrderByAggregateInput
  }

  export type EmpregoScalarWhereWithAggregatesInput = {
    AND?: EmpregoScalarWhereWithAggregatesInput | EmpregoScalarWhereWithAggregatesInput[]
    OR?: EmpregoScalarWhereWithAggregatesInput[]
    NOT?: EmpregoScalarWhereWithAggregatesInput | EmpregoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Emprego"> | number
    data_inicio?: DateTimeWithAggregatesFilter<"Emprego"> | Date | string
    sector?: EnumSectorWithAggregatesFilter<"Emprego"> | $Enums.Sector
    cargo?: StringWithAggregatesFilter<"Emprego"> | string
    area?: EnumAreaWithAggregatesFilter<"Emprego"> | $Enums.Area
    estado?: BoolWithAggregatesFilter<"Emprego"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Emprego"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Emprego"> | Date | string
  }

  export type ResidenciaWhereInput = {
    AND?: ResidenciaWhereInput | ResidenciaWhereInput[]
    OR?: ResidenciaWhereInput[]
    NOT?: ResidenciaWhereInput | ResidenciaWhereInput[]
    id?: IntFilter<"Residencia"> | number
    tipo?: EnumPropriedadeFilter<"Residencia"> | $Enums.Propriedade
    data_inicio?: DateTimeFilter<"Residencia"> | Date | string
    estado?: BoolFilter<"Residencia"> | boolean
    createdAt?: DateTimeFilter<"Residencia"> | Date | string
    updatedAt?: DateTimeFilter<"Residencia"> | Date | string
    pessoa?: PessoaListRelationFilter
  }

  export type ResidenciaOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    data_inicio?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pessoa?: PessoaOrderByRelationAggregateInput
  }

  export type ResidenciaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ResidenciaWhereInput | ResidenciaWhereInput[]
    OR?: ResidenciaWhereInput[]
    NOT?: ResidenciaWhereInput | ResidenciaWhereInput[]
    tipo?: EnumPropriedadeFilter<"Residencia"> | $Enums.Propriedade
    data_inicio?: DateTimeFilter<"Residencia"> | Date | string
    estado?: BoolFilter<"Residencia"> | boolean
    createdAt?: DateTimeFilter<"Residencia"> | Date | string
    updatedAt?: DateTimeFilter<"Residencia"> | Date | string
    pessoa?: PessoaListRelationFilter
  }, "id">

  export type ResidenciaOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    data_inicio?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResidenciaCountOrderByAggregateInput
    _avg?: ResidenciaAvgOrderByAggregateInput
    _max?: ResidenciaMaxOrderByAggregateInput
    _min?: ResidenciaMinOrderByAggregateInput
    _sum?: ResidenciaSumOrderByAggregateInput
  }

  export type ResidenciaScalarWhereWithAggregatesInput = {
    AND?: ResidenciaScalarWhereWithAggregatesInput | ResidenciaScalarWhereWithAggregatesInput[]
    OR?: ResidenciaScalarWhereWithAggregatesInput[]
    NOT?: ResidenciaScalarWhereWithAggregatesInput | ResidenciaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Residencia"> | number
    tipo?: EnumPropriedadeWithAggregatesFilter<"Residencia"> | $Enums.Propriedade
    data_inicio?: DateTimeWithAggregatesFilter<"Residencia"> | Date | string
    estado?: BoolWithAggregatesFilter<"Residencia"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Residencia"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Residencia"> | Date | string
  }

  export type PapelWhereInput = {
    AND?: PapelWhereInput | PapelWhereInput[]
    OR?: PapelWhereInput[]
    NOT?: PapelWhereInput | PapelWhereInput[]
    id?: IntFilter<"Papel"> | number
    perfil?: EnumPerfilFilter<"Papel"> | $Enums.Perfil
    user_id?: IntFilter<"Papel"> | number
    estado?: BoolFilter<"Papel"> | boolean
    createdAt?: DateTimeFilter<"Papel"> | Date | string
    updatedAt?: DateTimeFilter<"Papel"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PapelOrderByWithRelationInput = {
    id?: SortOrder
    perfil?: SortOrder
    user_id?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PapelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: PapelWhereInput | PapelWhereInput[]
    OR?: PapelWhereInput[]
    NOT?: PapelWhereInput | PapelWhereInput[]
    perfil?: EnumPerfilFilter<"Papel"> | $Enums.Perfil
    estado?: BoolFilter<"Papel"> | boolean
    createdAt?: DateTimeFilter<"Papel"> | Date | string
    updatedAt?: DateTimeFilter<"Papel"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "user_id">

  export type PapelOrderByWithAggregationInput = {
    id?: SortOrder
    perfil?: SortOrder
    user_id?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PapelCountOrderByAggregateInput
    _avg?: PapelAvgOrderByAggregateInput
    _max?: PapelMaxOrderByAggregateInput
    _min?: PapelMinOrderByAggregateInput
    _sum?: PapelSumOrderByAggregateInput
  }

  export type PapelScalarWhereWithAggregatesInput = {
    AND?: PapelScalarWhereWithAggregatesInput | PapelScalarWhereWithAggregatesInput[]
    OR?: PapelScalarWhereWithAggregatesInput[]
    NOT?: PapelScalarWhereWithAggregatesInput | PapelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Papel"> | number
    perfil?: EnumPerfilWithAggregatesFilter<"Papel"> | $Enums.Perfil
    user_id?: IntWithAggregatesFilter<"Papel"> | number
    estado?: BoolWithAggregatesFilter<"Papel"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Papel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Papel"> | Date | string
  }

  export type PessoaWhereInput = {
    AND?: PessoaWhereInput | PessoaWhereInput[]
    OR?: PessoaWhereInput[]
    NOT?: PessoaWhereInput | PessoaWhereInput[]
    id?: IntFilter<"Pessoa"> | number
    estado_civil?: EnumEstadoFilter<"Pessoa"> | $Enums.Estado
    provincia?: StringFilter<"Pessoa"> | string
    municipio?: StringFilter<"Pessoa"> | string
    profissao?: StringFilter<"Pessoa"> | string
    estado?: BoolFilter<"Pessoa"> | boolean
    nivel_instrucao?: StringFilter<"Pessoa"> | string
    data_nascimento?: DateTimeFilter<"Pessoa"> | Date | string
    user_id?: IntFilter<"Pessoa"> | number
    emprego_id?: IntFilter<"Pessoa"> | number
    residencia_id?: IntFilter<"Pessoa"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    emprego?: XOR<EmpregoScalarRelationFilter, EmpregoWhereInput>
    residencia?: XOR<ResidenciaScalarRelationFilter, ResidenciaWhereInput>
    conjugue?: XOR<ConjugueNullableScalarRelationFilter, ConjugueWhereInput> | null
    solidario?: XOR<SolidarioNullableScalarRelationFilter, SolidarioWhereInput> | null
    conta?: XOR<ContaNullableScalarRelationFilter, ContaWhereInput> | null
  }

  export type PessoaOrderByWithRelationInput = {
    id?: SortOrder
    estado_civil?: SortOrder
    provincia?: SortOrder
    municipio?: SortOrder
    profissao?: SortOrder
    estado?: SortOrder
    nivel_instrucao?: SortOrder
    data_nascimento?: SortOrder
    user_id?: SortOrder
    emprego_id?: SortOrder
    residencia_id?: SortOrder
    user?: UserOrderByWithRelationInput
    emprego?: EmpregoOrderByWithRelationInput
    residencia?: ResidenciaOrderByWithRelationInput
    conjugue?: ConjugueOrderByWithRelationInput
    solidario?: SolidarioOrderByWithRelationInput
    conta?: ContaOrderByWithRelationInput
    _relevance?: PessoaOrderByRelevanceInput
  }

  export type PessoaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: PessoaWhereInput | PessoaWhereInput[]
    OR?: PessoaWhereInput[]
    NOT?: PessoaWhereInput | PessoaWhereInput[]
    estado_civil?: EnumEstadoFilter<"Pessoa"> | $Enums.Estado
    provincia?: StringFilter<"Pessoa"> | string
    municipio?: StringFilter<"Pessoa"> | string
    profissao?: StringFilter<"Pessoa"> | string
    estado?: BoolFilter<"Pessoa"> | boolean
    nivel_instrucao?: StringFilter<"Pessoa"> | string
    data_nascimento?: DateTimeFilter<"Pessoa"> | Date | string
    emprego_id?: IntFilter<"Pessoa"> | number
    residencia_id?: IntFilter<"Pessoa"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    emprego?: XOR<EmpregoScalarRelationFilter, EmpregoWhereInput>
    residencia?: XOR<ResidenciaScalarRelationFilter, ResidenciaWhereInput>
    conjugue?: XOR<ConjugueNullableScalarRelationFilter, ConjugueWhereInput> | null
    solidario?: XOR<SolidarioNullableScalarRelationFilter, SolidarioWhereInput> | null
    conta?: XOR<ContaNullableScalarRelationFilter, ContaWhereInput> | null
  }, "id" | "user_id">

  export type PessoaOrderByWithAggregationInput = {
    id?: SortOrder
    estado_civil?: SortOrder
    provincia?: SortOrder
    municipio?: SortOrder
    profissao?: SortOrder
    estado?: SortOrder
    nivel_instrucao?: SortOrder
    data_nascimento?: SortOrder
    user_id?: SortOrder
    emprego_id?: SortOrder
    residencia_id?: SortOrder
    _count?: PessoaCountOrderByAggregateInput
    _avg?: PessoaAvgOrderByAggregateInput
    _max?: PessoaMaxOrderByAggregateInput
    _min?: PessoaMinOrderByAggregateInput
    _sum?: PessoaSumOrderByAggregateInput
  }

  export type PessoaScalarWhereWithAggregatesInput = {
    AND?: PessoaScalarWhereWithAggregatesInput | PessoaScalarWhereWithAggregatesInput[]
    OR?: PessoaScalarWhereWithAggregatesInput[]
    NOT?: PessoaScalarWhereWithAggregatesInput | PessoaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pessoa"> | number
    estado_civil?: EnumEstadoWithAggregatesFilter<"Pessoa"> | $Enums.Estado
    provincia?: StringWithAggregatesFilter<"Pessoa"> | string
    municipio?: StringWithAggregatesFilter<"Pessoa"> | string
    profissao?: StringWithAggregatesFilter<"Pessoa"> | string
    estado?: BoolWithAggregatesFilter<"Pessoa"> | boolean
    nivel_instrucao?: StringWithAggregatesFilter<"Pessoa"> | string
    data_nascimento?: DateTimeWithAggregatesFilter<"Pessoa"> | Date | string
    user_id?: IntWithAggregatesFilter<"Pessoa"> | number
    emprego_id?: IntWithAggregatesFilter<"Pessoa"> | number
    residencia_id?: IntWithAggregatesFilter<"Pessoa"> | number
  }

  export type ContaWhereInput = {
    AND?: ContaWhereInput | ContaWhereInput[]
    OR?: ContaWhereInput[]
    NOT?: ContaWhereInput | ContaWhereInput[]
    id?: IntFilter<"Conta"> | number
    nome?: StringFilter<"Conta"> | string
    salario?: IntFilter<"Conta"> | number
    iban?: StringFilter<"Conta"> | string
    estado?: BoolFilter<"Conta"> | boolean
    pessoa_id?: IntFilter<"Conta"> | number
    createdAt?: DateTimeFilter<"Conta"> | Date | string
    updatedAt?: DateTimeFilter<"Conta"> | Date | string
    pessoa?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
  }

  export type ContaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    salario?: SortOrder
    iban?: SortOrder
    estado?: SortOrder
    pessoa_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pessoa?: PessoaOrderByWithRelationInput
    _relevance?: ContaOrderByRelevanceInput
  }

  export type ContaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pessoa_id?: number
    AND?: ContaWhereInput | ContaWhereInput[]
    OR?: ContaWhereInput[]
    NOT?: ContaWhereInput | ContaWhereInput[]
    nome?: StringFilter<"Conta"> | string
    salario?: IntFilter<"Conta"> | number
    iban?: StringFilter<"Conta"> | string
    estado?: BoolFilter<"Conta"> | boolean
    createdAt?: DateTimeFilter<"Conta"> | Date | string
    updatedAt?: DateTimeFilter<"Conta"> | Date | string
    pessoa?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
  }, "id" | "pessoa_id">

  export type ContaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    salario?: SortOrder
    iban?: SortOrder
    estado?: SortOrder
    pessoa_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContaCountOrderByAggregateInput
    _avg?: ContaAvgOrderByAggregateInput
    _max?: ContaMaxOrderByAggregateInput
    _min?: ContaMinOrderByAggregateInput
    _sum?: ContaSumOrderByAggregateInput
  }

  export type ContaScalarWhereWithAggregatesInput = {
    AND?: ContaScalarWhereWithAggregatesInput | ContaScalarWhereWithAggregatesInput[]
    OR?: ContaScalarWhereWithAggregatesInput[]
    NOT?: ContaScalarWhereWithAggregatesInput | ContaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Conta"> | number
    nome?: StringWithAggregatesFilter<"Conta"> | string
    salario?: IntWithAggregatesFilter<"Conta"> | number
    iban?: StringWithAggregatesFilter<"Conta"> | string
    estado?: BoolWithAggregatesFilter<"Conta"> | boolean
    pessoa_id?: IntWithAggregatesFilter<"Conta"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Conta"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conta"> | Date | string
  }

  export type ConjugueWhereInput = {
    AND?: ConjugueWhereInput | ConjugueWhereInput[]
    OR?: ConjugueWhereInput[]
    NOT?: ConjugueWhereInput | ConjugueWhereInput[]
    id?: IntFilter<"Conjugue"> | number
    nome_completo?: StringFilter<"Conjugue"> | string
    dependentes?: IntFilter<"Conjugue"> | number
    nivel_instrucao?: StringFilter<"Conjugue"> | string
    estado?: BoolFilter<"Conjugue"> | boolean
    data_nascimento?: DateTimeFilter<"Conjugue"> | Date | string
    pessoa_id?: IntFilter<"Conjugue"> | number
    pessoa?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
  }

  export type ConjugueOrderByWithRelationInput = {
    id?: SortOrder
    nome_completo?: SortOrder
    dependentes?: SortOrder
    nivel_instrucao?: SortOrder
    estado?: SortOrder
    data_nascimento?: SortOrder
    pessoa_id?: SortOrder
    pessoa?: PessoaOrderByWithRelationInput
    _relevance?: ConjugueOrderByRelevanceInput
  }

  export type ConjugueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pessoa_id?: number
    AND?: ConjugueWhereInput | ConjugueWhereInput[]
    OR?: ConjugueWhereInput[]
    NOT?: ConjugueWhereInput | ConjugueWhereInput[]
    nome_completo?: StringFilter<"Conjugue"> | string
    dependentes?: IntFilter<"Conjugue"> | number
    nivel_instrucao?: StringFilter<"Conjugue"> | string
    estado?: BoolFilter<"Conjugue"> | boolean
    data_nascimento?: DateTimeFilter<"Conjugue"> | Date | string
    pessoa?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
  }, "id" | "pessoa_id">

  export type ConjugueOrderByWithAggregationInput = {
    id?: SortOrder
    nome_completo?: SortOrder
    dependentes?: SortOrder
    nivel_instrucao?: SortOrder
    estado?: SortOrder
    data_nascimento?: SortOrder
    pessoa_id?: SortOrder
    _count?: ConjugueCountOrderByAggregateInput
    _avg?: ConjugueAvgOrderByAggregateInput
    _max?: ConjugueMaxOrderByAggregateInput
    _min?: ConjugueMinOrderByAggregateInput
    _sum?: ConjugueSumOrderByAggregateInput
  }

  export type ConjugueScalarWhereWithAggregatesInput = {
    AND?: ConjugueScalarWhereWithAggregatesInput | ConjugueScalarWhereWithAggregatesInput[]
    OR?: ConjugueScalarWhereWithAggregatesInput[]
    NOT?: ConjugueScalarWhereWithAggregatesInput | ConjugueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Conjugue"> | number
    nome_completo?: StringWithAggregatesFilter<"Conjugue"> | string
    dependentes?: IntWithAggregatesFilter<"Conjugue"> | number
    nivel_instrucao?: StringWithAggregatesFilter<"Conjugue"> | string
    estado?: BoolWithAggregatesFilter<"Conjugue"> | boolean
    data_nascimento?: DateTimeWithAggregatesFilter<"Conjugue"> | Date | string
    pessoa_id?: IntWithAggregatesFilter<"Conjugue"> | number
  }

  export type DocumentoWhereInput = {
    AND?: DocumentoWhereInput | DocumentoWhereInput[]
    OR?: DocumentoWhereInput[]
    NOT?: DocumentoWhereInput | DocumentoWhereInput[]
    id?: IntFilter<"Documento"> | number
    tipo?: EnumComprovativoFilter<"Documento"> | $Enums.Comprovativo
    titulo?: StringFilter<"Documento"> | string
    extensao?: StringFilter<"Documento"> | string
    tamanho?: StringFilter<"Documento"> | string
    nome_original?: StringFilter<"Documento"> | string
    nome_salvado?: StringFilter<"Documento"> | string
    estado?: BoolFilter<"Documento"> | boolean
    user_id?: IntFilter<"Documento"> | number
    createdAt?: DateTimeFilter<"Documento"> | Date | string
    updatedAt?: DateTimeFilter<"Documento"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DocumentoOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    extensao?: SortOrder
    tamanho?: SortOrder
    nome_original?: SortOrder
    nome_salvado?: SortOrder
    estado?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: DocumentoOrderByRelevanceInput
  }

  export type DocumentoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DocumentoWhereInput | DocumentoWhereInput[]
    OR?: DocumentoWhereInput[]
    NOT?: DocumentoWhereInput | DocumentoWhereInput[]
    tipo?: EnumComprovativoFilter<"Documento"> | $Enums.Comprovativo
    titulo?: StringFilter<"Documento"> | string
    extensao?: StringFilter<"Documento"> | string
    tamanho?: StringFilter<"Documento"> | string
    nome_original?: StringFilter<"Documento"> | string
    nome_salvado?: StringFilter<"Documento"> | string
    estado?: BoolFilter<"Documento"> | boolean
    user_id?: IntFilter<"Documento"> | number
    createdAt?: DateTimeFilter<"Documento"> | Date | string
    updatedAt?: DateTimeFilter<"Documento"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DocumentoOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    extensao?: SortOrder
    tamanho?: SortOrder
    nome_original?: SortOrder
    nome_salvado?: SortOrder
    estado?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentoCountOrderByAggregateInput
    _avg?: DocumentoAvgOrderByAggregateInput
    _max?: DocumentoMaxOrderByAggregateInput
    _min?: DocumentoMinOrderByAggregateInput
    _sum?: DocumentoSumOrderByAggregateInput
  }

  export type DocumentoScalarWhereWithAggregatesInput = {
    AND?: DocumentoScalarWhereWithAggregatesInput | DocumentoScalarWhereWithAggregatesInput[]
    OR?: DocumentoScalarWhereWithAggregatesInput[]
    NOT?: DocumentoScalarWhereWithAggregatesInput | DocumentoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Documento"> | number
    tipo?: EnumComprovativoWithAggregatesFilter<"Documento"> | $Enums.Comprovativo
    titulo?: StringWithAggregatesFilter<"Documento"> | string
    extensao?: StringWithAggregatesFilter<"Documento"> | string
    tamanho?: StringWithAggregatesFilter<"Documento"> | string
    nome_original?: StringWithAggregatesFilter<"Documento"> | string
    nome_salvado?: StringWithAggregatesFilter<"Documento"> | string
    estado?: BoolWithAggregatesFilter<"Documento"> | boolean
    user_id?: IntWithAggregatesFilter<"Documento"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Documento"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Documento"> | Date | string
  }

  export type DevedorWhereInput = {
    AND?: DevedorWhereInput | DevedorWhereInput[]
    OR?: DevedorWhereInput[]
    NOT?: DevedorWhereInput | DevedorWhereInput[]
    id?: IntFilter<"Devedor"> | number
    user_id?: IntFilter<"Devedor"> | number
    solicitacao?: IntFilter<"Devedor"> | number
    adimplencia?: IntFilter<"Devedor"> | number
    inadimplencia?: IntFilter<"Devedor"> | number
    estado?: BoolFilter<"Devedor"> | boolean
    createdAt?: DateTimeFilter<"Devedor"> | Date | string
    updatedAt?: DateTimeFilter<"Devedor"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    credito?: CreditoListRelationFilter
    movel?: MovelListRelationFilter
    pagamento?: PagamentoListRelationFilter
  }

  export type DevedorOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    solicitacao?: SortOrder
    adimplencia?: SortOrder
    inadimplencia?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    credito?: CreditoOrderByRelationAggregateInput
    movel?: MovelOrderByRelationAggregateInput
    pagamento?: PagamentoOrderByRelationAggregateInput
  }

  export type DevedorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: DevedorWhereInput | DevedorWhereInput[]
    OR?: DevedorWhereInput[]
    NOT?: DevedorWhereInput | DevedorWhereInput[]
    solicitacao?: IntFilter<"Devedor"> | number
    adimplencia?: IntFilter<"Devedor"> | number
    inadimplencia?: IntFilter<"Devedor"> | number
    estado?: BoolFilter<"Devedor"> | boolean
    createdAt?: DateTimeFilter<"Devedor"> | Date | string
    updatedAt?: DateTimeFilter<"Devedor"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    credito?: CreditoListRelationFilter
    movel?: MovelListRelationFilter
    pagamento?: PagamentoListRelationFilter
  }, "id" | "user_id">

  export type DevedorOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    solicitacao?: SortOrder
    adimplencia?: SortOrder
    inadimplencia?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DevedorCountOrderByAggregateInput
    _avg?: DevedorAvgOrderByAggregateInput
    _max?: DevedorMaxOrderByAggregateInput
    _min?: DevedorMinOrderByAggregateInput
    _sum?: DevedorSumOrderByAggregateInput
  }

  export type DevedorScalarWhereWithAggregatesInput = {
    AND?: DevedorScalarWhereWithAggregatesInput | DevedorScalarWhereWithAggregatesInput[]
    OR?: DevedorScalarWhereWithAggregatesInput[]
    NOT?: DevedorScalarWhereWithAggregatesInput | DevedorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Devedor"> | number
    user_id?: IntWithAggregatesFilter<"Devedor"> | number
    solicitacao?: IntWithAggregatesFilter<"Devedor"> | number
    adimplencia?: IntWithAggregatesFilter<"Devedor"> | number
    inadimplencia?: IntWithAggregatesFilter<"Devedor"> | number
    estado?: BoolWithAggregatesFilter<"Devedor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Devedor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Devedor"> | Date | string
  }

  export type InvestidorWhereInput = {
    AND?: InvestidorWhereInput | InvestidorWhereInput[]
    OR?: InvestidorWhereInput[]
    NOT?: InvestidorWhereInput | InvestidorWhereInput[]
    id?: IntFilter<"Investidor"> | number
    maior_risco?: BoolFilter<"Investidor"> | boolean
    maior_seguranca?: BoolFilter<"Investidor"> | boolean
    saque_antecipado?: BoolFilter<"Investidor"> | boolean
    fundo_protegido?: BoolFilter<"Investidor"> | boolean
    estado?: BoolFilter<"Investidor"> | boolean
    partilhar_emprestimo?: BoolFilter<"Investidor"> | boolean
    user_id?: IntFilter<"Investidor"> | number
    createdAt?: DateTimeFilter<"Investidor"> | Date | string
    updatedAt?: DateTimeFilter<"Investidor"> | Date | string
    diversificacao?: DiversificacaoListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InvestidorOrderByWithRelationInput = {
    id?: SortOrder
    maior_risco?: SortOrder
    maior_seguranca?: SortOrder
    saque_antecipado?: SortOrder
    fundo_protegido?: SortOrder
    estado?: SortOrder
    partilhar_emprestimo?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    diversificacao?: DiversificacaoOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type InvestidorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: InvestidorWhereInput | InvestidorWhereInput[]
    OR?: InvestidorWhereInput[]
    NOT?: InvestidorWhereInput | InvestidorWhereInput[]
    maior_risco?: BoolFilter<"Investidor"> | boolean
    maior_seguranca?: BoolFilter<"Investidor"> | boolean
    saque_antecipado?: BoolFilter<"Investidor"> | boolean
    fundo_protegido?: BoolFilter<"Investidor"> | boolean
    estado?: BoolFilter<"Investidor"> | boolean
    partilhar_emprestimo?: BoolFilter<"Investidor"> | boolean
    createdAt?: DateTimeFilter<"Investidor"> | Date | string
    updatedAt?: DateTimeFilter<"Investidor"> | Date | string
    diversificacao?: DiversificacaoListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "user_id">

  export type InvestidorOrderByWithAggregationInput = {
    id?: SortOrder
    maior_risco?: SortOrder
    maior_seguranca?: SortOrder
    saque_antecipado?: SortOrder
    fundo_protegido?: SortOrder
    estado?: SortOrder
    partilhar_emprestimo?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvestidorCountOrderByAggregateInput
    _avg?: InvestidorAvgOrderByAggregateInput
    _max?: InvestidorMaxOrderByAggregateInput
    _min?: InvestidorMinOrderByAggregateInput
    _sum?: InvestidorSumOrderByAggregateInput
  }

  export type InvestidorScalarWhereWithAggregatesInput = {
    AND?: InvestidorScalarWhereWithAggregatesInput | InvestidorScalarWhereWithAggregatesInput[]
    OR?: InvestidorScalarWhereWithAggregatesInput[]
    NOT?: InvestidorScalarWhereWithAggregatesInput | InvestidorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Investidor"> | number
    maior_risco?: BoolWithAggregatesFilter<"Investidor"> | boolean
    maior_seguranca?: BoolWithAggregatesFilter<"Investidor"> | boolean
    saque_antecipado?: BoolWithAggregatesFilter<"Investidor"> | boolean
    fundo_protegido?: BoolWithAggregatesFilter<"Investidor"> | boolean
    estado?: BoolWithAggregatesFilter<"Investidor"> | boolean
    partilhar_emprestimo?: BoolWithAggregatesFilter<"Investidor"> | boolean
    user_id?: IntWithAggregatesFilter<"Investidor"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Investidor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Investidor"> | Date | string
  }

  export type ReclamacaoWhereInput = {
    AND?: ReclamacaoWhereInput | ReclamacaoWhereInput[]
    OR?: ReclamacaoWhereInput[]
    NOT?: ReclamacaoWhereInput | ReclamacaoWhereInput[]
    id?: IntFilter<"Reclamacao"> | number
    user_id?: IntFilter<"Reclamacao"> | number
    estado?: BoolFilter<"Reclamacao"> | boolean
    assunto?: StringFilter<"Reclamacao"> | string
    conteudo?: StringFilter<"Reclamacao"> | string
    createdAt?: DateTimeFilter<"Reclamacao"> | Date | string
    updatedAt?: DateTimeFilter<"Reclamacao"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReclamacaoOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    estado?: SortOrder
    assunto?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: ReclamacaoOrderByRelevanceInput
  }

  export type ReclamacaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReclamacaoWhereInput | ReclamacaoWhereInput[]
    OR?: ReclamacaoWhereInput[]
    NOT?: ReclamacaoWhereInput | ReclamacaoWhereInput[]
    user_id?: IntFilter<"Reclamacao"> | number
    estado?: BoolFilter<"Reclamacao"> | boolean
    assunto?: StringFilter<"Reclamacao"> | string
    conteudo?: StringFilter<"Reclamacao"> | string
    createdAt?: DateTimeFilter<"Reclamacao"> | Date | string
    updatedAt?: DateTimeFilter<"Reclamacao"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReclamacaoOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    estado?: SortOrder
    assunto?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReclamacaoCountOrderByAggregateInput
    _avg?: ReclamacaoAvgOrderByAggregateInput
    _max?: ReclamacaoMaxOrderByAggregateInput
    _min?: ReclamacaoMinOrderByAggregateInput
    _sum?: ReclamacaoSumOrderByAggregateInput
  }

  export type ReclamacaoScalarWhereWithAggregatesInput = {
    AND?: ReclamacaoScalarWhereWithAggregatesInput | ReclamacaoScalarWhereWithAggregatesInput[]
    OR?: ReclamacaoScalarWhereWithAggregatesInput[]
    NOT?: ReclamacaoScalarWhereWithAggregatesInput | ReclamacaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Reclamacao"> | number
    user_id?: IntWithAggregatesFilter<"Reclamacao"> | number
    estado?: BoolWithAggregatesFilter<"Reclamacao"> | boolean
    assunto?: StringWithAggregatesFilter<"Reclamacao"> | string
    conteudo?: StringWithAggregatesFilter<"Reclamacao"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Reclamacao"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reclamacao"> | Date | string
  }

  export type ProponenteWhereInput = {
    AND?: ProponenteWhereInput | ProponenteWhereInput[]
    OR?: ProponenteWhereInput[]
    NOT?: ProponenteWhereInput | ProponenteWhereInput[]
    id?: IntFilter<"Proponente"> | number
    solicitacao?: IntFilter<"Proponente"> | number
    reembolsar?: IntFilter<"Proponente"> | number
    satisfeitos?: IntFilter<"Proponente"> | number
    insatisfeitos?: IntFilter<"Proponente"> | number
    estado?: BoolFilter<"Proponente"> | boolean
    user_id?: IntFilter<"Proponente"> | number
    createdAt?: DateTimeFilter<"Proponente"> | Date | string
    updatedAt?: DateTimeFilter<"Proponente"> | Date | string
    emprestimo?: EmprestimoListRelationFilter
    reembolso?: ReembolsoListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProponenteOrderByWithRelationInput = {
    id?: SortOrder
    solicitacao?: SortOrder
    reembolsar?: SortOrder
    satisfeitos?: SortOrder
    insatisfeitos?: SortOrder
    estado?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emprestimo?: EmprestimoOrderByRelationAggregateInput
    reembolso?: ReembolsoOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type ProponenteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: ProponenteWhereInput | ProponenteWhereInput[]
    OR?: ProponenteWhereInput[]
    NOT?: ProponenteWhereInput | ProponenteWhereInput[]
    solicitacao?: IntFilter<"Proponente"> | number
    reembolsar?: IntFilter<"Proponente"> | number
    satisfeitos?: IntFilter<"Proponente"> | number
    insatisfeitos?: IntFilter<"Proponente"> | number
    estado?: BoolFilter<"Proponente"> | boolean
    createdAt?: DateTimeFilter<"Proponente"> | Date | string
    updatedAt?: DateTimeFilter<"Proponente"> | Date | string
    emprestimo?: EmprestimoListRelationFilter
    reembolso?: ReembolsoListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "user_id">

  export type ProponenteOrderByWithAggregationInput = {
    id?: SortOrder
    solicitacao?: SortOrder
    reembolsar?: SortOrder
    satisfeitos?: SortOrder
    insatisfeitos?: SortOrder
    estado?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProponenteCountOrderByAggregateInput
    _avg?: ProponenteAvgOrderByAggregateInput
    _max?: ProponenteMaxOrderByAggregateInput
    _min?: ProponenteMinOrderByAggregateInput
    _sum?: ProponenteSumOrderByAggregateInput
  }

  export type ProponenteScalarWhereWithAggregatesInput = {
    AND?: ProponenteScalarWhereWithAggregatesInput | ProponenteScalarWhereWithAggregatesInput[]
    OR?: ProponenteScalarWhereWithAggregatesInput[]
    NOT?: ProponenteScalarWhereWithAggregatesInput | ProponenteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Proponente"> | number
    solicitacao?: IntWithAggregatesFilter<"Proponente"> | number
    reembolsar?: IntWithAggregatesFilter<"Proponente"> | number
    satisfeitos?: IntWithAggregatesFilter<"Proponente"> | number
    insatisfeitos?: IntWithAggregatesFilter<"Proponente"> | number
    estado?: BoolWithAggregatesFilter<"Proponente"> | boolean
    user_id?: IntWithAggregatesFilter<"Proponente"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Proponente"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Proponente"> | Date | string
  }

  export type SolidarioWhereInput = {
    AND?: SolidarioWhereInput | SolidarioWhereInput[]
    OR?: SolidarioWhereInput[]
    NOT?: SolidarioWhereInput | SolidarioWhereInput[]
    id?: IntFilter<"Solidario"> | number
    tipo?: EnumAvalFilter<"Solidario"> | $Enums.Aval
    parentesco?: EnumParentescoFilter<"Solidario"> | $Enums.Parentesco
    taxa?: IntFilter<"Solidario"> | number
    estado?: BoolFilter<"Solidario"> | boolean
    pessoa_id?: IntFilter<"Solidario"> | number
    user_id?: IntFilter<"Solidario"> | number
    createdAt?: DateTimeFilter<"Solidario"> | Date | string
    updatedAt?: DateTimeFilter<"Solidario"> | Date | string
    pessoa?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
    emprestimo?: EmprestimoSolidarioListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    credito?: CreditoSolidarioListRelationFilter
  }

  export type SolidarioOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    parentesco?: SortOrder
    taxa?: SortOrder
    estado?: SortOrder
    pessoa_id?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pessoa?: PessoaOrderByWithRelationInput
    emprestimo?: EmprestimoSolidarioOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    credito?: CreditoSolidarioOrderByRelationAggregateInput
  }

  export type SolidarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pessoa_id?: number
    AND?: SolidarioWhereInput | SolidarioWhereInput[]
    OR?: SolidarioWhereInput[]
    NOT?: SolidarioWhereInput | SolidarioWhereInput[]
    tipo?: EnumAvalFilter<"Solidario"> | $Enums.Aval
    parentesco?: EnumParentescoFilter<"Solidario"> | $Enums.Parentesco
    taxa?: IntFilter<"Solidario"> | number
    estado?: BoolFilter<"Solidario"> | boolean
    user_id?: IntFilter<"Solidario"> | number
    createdAt?: DateTimeFilter<"Solidario"> | Date | string
    updatedAt?: DateTimeFilter<"Solidario"> | Date | string
    pessoa?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
    emprestimo?: EmprestimoSolidarioListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    credito?: CreditoSolidarioListRelationFilter
  }, "id" | "pessoa_id">

  export type SolidarioOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    parentesco?: SortOrder
    taxa?: SortOrder
    estado?: SortOrder
    pessoa_id?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SolidarioCountOrderByAggregateInput
    _avg?: SolidarioAvgOrderByAggregateInput
    _max?: SolidarioMaxOrderByAggregateInput
    _min?: SolidarioMinOrderByAggregateInput
    _sum?: SolidarioSumOrderByAggregateInput
  }

  export type SolidarioScalarWhereWithAggregatesInput = {
    AND?: SolidarioScalarWhereWithAggregatesInput | SolidarioScalarWhereWithAggregatesInput[]
    OR?: SolidarioScalarWhereWithAggregatesInput[]
    NOT?: SolidarioScalarWhereWithAggregatesInput | SolidarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Solidario"> | number
    tipo?: EnumAvalWithAggregatesFilter<"Solidario"> | $Enums.Aval
    parentesco?: EnumParentescoWithAggregatesFilter<"Solidario"> | $Enums.Parentesco
    taxa?: IntWithAggregatesFilter<"Solidario"> | number
    estado?: BoolWithAggregatesFilter<"Solidario"> | boolean
    pessoa_id?: IntWithAggregatesFilter<"Solidario"> | number
    user_id?: IntWithAggregatesFilter<"Solidario"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Solidario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Solidario"> | Date | string
  }

  export type MovelWhereInput = {
    AND?: MovelWhereInput | MovelWhereInput[]
    OR?: MovelWhereInput[]
    NOT?: MovelWhereInput | MovelWhereInput[]
    id?: IntFilter<"Movel"> | number
    modelo?: EnumModeloFilter<"Movel"> | $Enums.Modelo
    matricula?: StringFilter<"Movel"> | string
    detalhes?: StringFilter<"Movel"> | string
    devedor_id?: IntFilter<"Movel"> | number
    estado?: BoolFilter<"Movel"> | boolean
    createdAt?: DateTimeFilter<"Movel"> | Date | string
    updatedAt?: DateTimeFilter<"Movel"> | Date | string
    devedor?: XOR<DevedorScalarRelationFilter, DevedorWhereInput>
  }

  export type MovelOrderByWithRelationInput = {
    id?: SortOrder
    modelo?: SortOrder
    matricula?: SortOrder
    detalhes?: SortOrder
    devedor_id?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    devedor?: DevedorOrderByWithRelationInput
    _relevance?: MovelOrderByRelevanceInput
  }

  export type MovelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MovelWhereInput | MovelWhereInput[]
    OR?: MovelWhereInput[]
    NOT?: MovelWhereInput | MovelWhereInput[]
    modelo?: EnumModeloFilter<"Movel"> | $Enums.Modelo
    matricula?: StringFilter<"Movel"> | string
    detalhes?: StringFilter<"Movel"> | string
    devedor_id?: IntFilter<"Movel"> | number
    estado?: BoolFilter<"Movel"> | boolean
    createdAt?: DateTimeFilter<"Movel"> | Date | string
    updatedAt?: DateTimeFilter<"Movel"> | Date | string
    devedor?: XOR<DevedorScalarRelationFilter, DevedorWhereInput>
  }, "id">

  export type MovelOrderByWithAggregationInput = {
    id?: SortOrder
    modelo?: SortOrder
    matricula?: SortOrder
    detalhes?: SortOrder
    devedor_id?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MovelCountOrderByAggregateInput
    _avg?: MovelAvgOrderByAggregateInput
    _max?: MovelMaxOrderByAggregateInput
    _min?: MovelMinOrderByAggregateInput
    _sum?: MovelSumOrderByAggregateInput
  }

  export type MovelScalarWhereWithAggregatesInput = {
    AND?: MovelScalarWhereWithAggregatesInput | MovelScalarWhereWithAggregatesInput[]
    OR?: MovelScalarWhereWithAggregatesInput[]
    NOT?: MovelScalarWhereWithAggregatesInput | MovelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Movel"> | number
    modelo?: EnumModeloWithAggregatesFilter<"Movel"> | $Enums.Modelo
    matricula?: StringWithAggregatesFilter<"Movel"> | string
    detalhes?: StringWithAggregatesFilter<"Movel"> | string
    devedor_id?: IntWithAggregatesFilter<"Movel"> | number
    estado?: BoolWithAggregatesFilter<"Movel"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Movel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Movel"> | Date | string
  }

  export type CreditoWhereInput = {
    AND?: CreditoWhereInput | CreditoWhereInput[]
    OR?: CreditoWhereInput[]
    NOT?: CreditoWhereInput | CreditoWhereInput[]
    id?: IntFilter<"Credito"> | number
    tipo?: EnumProdutoFilter<"Credito"> | $Enums.Produto
    valor?: FloatFilter<"Credito"> | number
    prestacao?: IntFilter<"Credito"> | number
    juro?: IntFilter<"Credito"> | number
    termino?: DateTimeFilter<"Credito"> | Date | string
    estado?: BoolFilter<"Credito"> | boolean
    pendencia?: BoolFilter<"Credito"> | boolean
    progresso?: EnumProgressoFilter<"Credito"> | $Enums.Progresso
    devedor_id?: IntFilter<"Credito"> | number
    createdAt?: DateTimeFilter<"Credito"> | Date | string
    updatedAt?: DateTimeFilter<"Credito"> | Date | string
    solidario?: CreditoSolidarioListRelationFilter
    devedor?: XOR<DevedorScalarRelationFilter, DevedorWhereInput>
  }

  export type CreditoOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    prestacao?: SortOrder
    juro?: SortOrder
    termino?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    progresso?: SortOrder
    devedor_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    solidario?: CreditoSolidarioOrderByRelationAggregateInput
    devedor?: DevedorOrderByWithRelationInput
  }

  export type CreditoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CreditoWhereInput | CreditoWhereInput[]
    OR?: CreditoWhereInput[]
    NOT?: CreditoWhereInput | CreditoWhereInput[]
    tipo?: EnumProdutoFilter<"Credito"> | $Enums.Produto
    valor?: FloatFilter<"Credito"> | number
    prestacao?: IntFilter<"Credito"> | number
    juro?: IntFilter<"Credito"> | number
    termino?: DateTimeFilter<"Credito"> | Date | string
    estado?: BoolFilter<"Credito"> | boolean
    pendencia?: BoolFilter<"Credito"> | boolean
    progresso?: EnumProgressoFilter<"Credito"> | $Enums.Progresso
    devedor_id?: IntFilter<"Credito"> | number
    createdAt?: DateTimeFilter<"Credito"> | Date | string
    updatedAt?: DateTimeFilter<"Credito"> | Date | string
    solidario?: CreditoSolidarioListRelationFilter
    devedor?: XOR<DevedorScalarRelationFilter, DevedorWhereInput>
  }, "id">

  export type CreditoOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    prestacao?: SortOrder
    juro?: SortOrder
    termino?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    progresso?: SortOrder
    devedor_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CreditoCountOrderByAggregateInput
    _avg?: CreditoAvgOrderByAggregateInput
    _max?: CreditoMaxOrderByAggregateInput
    _min?: CreditoMinOrderByAggregateInput
    _sum?: CreditoSumOrderByAggregateInput
  }

  export type CreditoScalarWhereWithAggregatesInput = {
    AND?: CreditoScalarWhereWithAggregatesInput | CreditoScalarWhereWithAggregatesInput[]
    OR?: CreditoScalarWhereWithAggregatesInput[]
    NOT?: CreditoScalarWhereWithAggregatesInput | CreditoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Credito"> | number
    tipo?: EnumProdutoWithAggregatesFilter<"Credito"> | $Enums.Produto
    valor?: FloatWithAggregatesFilter<"Credito"> | number
    prestacao?: IntWithAggregatesFilter<"Credito"> | number
    juro?: IntWithAggregatesFilter<"Credito"> | number
    termino?: DateTimeWithAggregatesFilter<"Credito"> | Date | string
    estado?: BoolWithAggregatesFilter<"Credito"> | boolean
    pendencia?: BoolWithAggregatesFilter<"Credito"> | boolean
    progresso?: EnumProgressoWithAggregatesFilter<"Credito"> | $Enums.Progresso
    devedor_id?: IntWithAggregatesFilter<"Credito"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Credito"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Credito"> | Date | string
  }

  export type EmprestimoWhereInput = {
    AND?: EmprestimoWhereInput | EmprestimoWhereInput[]
    OR?: EmprestimoWhereInput[]
    NOT?: EmprestimoWhereInput | EmprestimoWhereInput[]
    id?: IntFilter<"Emprestimo"> | number
    valor?: FloatFilter<"Emprestimo"> | number
    juro_proponente?: IntFilter<"Emprestimo"> | number
    taxa_investidor?: IntFilter<"Emprestimo"> | number
    prestacao?: IntFilter<"Emprestimo"> | number
    termino?: DateTimeFilter<"Emprestimo"> | Date | string
    estado?: BoolFilter<"Emprestimo"> | boolean
    pendencia?: BoolFilter<"Emprestimo"> | boolean
    progresso?: EnumProgressoFilter<"Emprestimo"> | $Enums.Progresso
    proponente_id?: IntFilter<"Emprestimo"> | number
    createdAt?: DateTimeFilter<"Emprestimo"> | Date | string
    updatedAt?: DateTimeFilter<"Emprestimo"> | Date | string
    diversificacao?: DiversificacaoListRelationFilter
    solidario?: EmprestimoSolidarioListRelationFilter
    proponente?: XOR<ProponenteScalarRelationFilter, ProponenteWhereInput>
  }

  export type EmprestimoOrderByWithRelationInput = {
    id?: SortOrder
    valor?: SortOrder
    juro_proponente?: SortOrder
    taxa_investidor?: SortOrder
    prestacao?: SortOrder
    termino?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    progresso?: SortOrder
    proponente_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    diversificacao?: DiversificacaoOrderByRelationAggregateInput
    solidario?: EmprestimoSolidarioOrderByRelationAggregateInput
    proponente?: ProponenteOrderByWithRelationInput
  }

  export type EmprestimoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmprestimoWhereInput | EmprestimoWhereInput[]
    OR?: EmprestimoWhereInput[]
    NOT?: EmprestimoWhereInput | EmprestimoWhereInput[]
    valor?: FloatFilter<"Emprestimo"> | number
    juro_proponente?: IntFilter<"Emprestimo"> | number
    taxa_investidor?: IntFilter<"Emprestimo"> | number
    prestacao?: IntFilter<"Emprestimo"> | number
    termino?: DateTimeFilter<"Emprestimo"> | Date | string
    estado?: BoolFilter<"Emprestimo"> | boolean
    pendencia?: BoolFilter<"Emprestimo"> | boolean
    progresso?: EnumProgressoFilter<"Emprestimo"> | $Enums.Progresso
    proponente_id?: IntFilter<"Emprestimo"> | number
    createdAt?: DateTimeFilter<"Emprestimo"> | Date | string
    updatedAt?: DateTimeFilter<"Emprestimo"> | Date | string
    diversificacao?: DiversificacaoListRelationFilter
    solidario?: EmprestimoSolidarioListRelationFilter
    proponente?: XOR<ProponenteScalarRelationFilter, ProponenteWhereInput>
  }, "id">

  export type EmprestimoOrderByWithAggregationInput = {
    id?: SortOrder
    valor?: SortOrder
    juro_proponente?: SortOrder
    taxa_investidor?: SortOrder
    prestacao?: SortOrder
    termino?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    progresso?: SortOrder
    proponente_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmprestimoCountOrderByAggregateInput
    _avg?: EmprestimoAvgOrderByAggregateInput
    _max?: EmprestimoMaxOrderByAggregateInput
    _min?: EmprestimoMinOrderByAggregateInput
    _sum?: EmprestimoSumOrderByAggregateInput
  }

  export type EmprestimoScalarWhereWithAggregatesInput = {
    AND?: EmprestimoScalarWhereWithAggregatesInput | EmprestimoScalarWhereWithAggregatesInput[]
    OR?: EmprestimoScalarWhereWithAggregatesInput[]
    NOT?: EmprestimoScalarWhereWithAggregatesInput | EmprestimoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Emprestimo"> | number
    valor?: FloatWithAggregatesFilter<"Emprestimo"> | number
    juro_proponente?: IntWithAggregatesFilter<"Emprestimo"> | number
    taxa_investidor?: IntWithAggregatesFilter<"Emprestimo"> | number
    prestacao?: IntWithAggregatesFilter<"Emprestimo"> | number
    termino?: DateTimeWithAggregatesFilter<"Emprestimo"> | Date | string
    estado?: BoolWithAggregatesFilter<"Emprestimo"> | boolean
    pendencia?: BoolWithAggregatesFilter<"Emprestimo"> | boolean
    progresso?: EnumProgressoWithAggregatesFilter<"Emprestimo"> | $Enums.Progresso
    proponente_id?: IntWithAggregatesFilter<"Emprestimo"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Emprestimo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Emprestimo"> | Date | string
  }

  export type EmprestimoSolidarioWhereInput = {
    AND?: EmprestimoSolidarioWhereInput | EmprestimoSolidarioWhereInput[]
    OR?: EmprestimoSolidarioWhereInput[]
    NOT?: EmprestimoSolidarioWhereInput | EmprestimoSolidarioWhereInput[]
    estado?: BoolFilter<"EmprestimoSolidario"> | boolean
    solidario_id?: IntFilter<"EmprestimoSolidario"> | number
    emprestimo_id?: IntFilter<"EmprestimoSolidario"> | number
    createdAt?: DateTimeFilter<"EmprestimoSolidario"> | Date | string
    updatedAt?: DateTimeFilter<"EmprestimoSolidario"> | Date | string
    solidario?: XOR<SolidarioScalarRelationFilter, SolidarioWhereInput>
    emprestimo?: XOR<EmprestimoScalarRelationFilter, EmprestimoWhereInput>
  }

  export type EmprestimoSolidarioOrderByWithRelationInput = {
    estado?: SortOrder
    solidario_id?: SortOrder
    emprestimo_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    solidario?: SolidarioOrderByWithRelationInput
    emprestimo?: EmprestimoOrderByWithRelationInput
  }

  export type EmprestimoSolidarioWhereUniqueInput = Prisma.AtLeast<{
    solidario_id_emprestimo_id?: EmprestimoSolidarioSolidario_idEmprestimo_idCompoundUniqueInput
    AND?: EmprestimoSolidarioWhereInput | EmprestimoSolidarioWhereInput[]
    OR?: EmprestimoSolidarioWhereInput[]
    NOT?: EmprestimoSolidarioWhereInput | EmprestimoSolidarioWhereInput[]
    estado?: BoolFilter<"EmprestimoSolidario"> | boolean
    solidario_id?: IntFilter<"EmprestimoSolidario"> | number
    emprestimo_id?: IntFilter<"EmprestimoSolidario"> | number
    createdAt?: DateTimeFilter<"EmprestimoSolidario"> | Date | string
    updatedAt?: DateTimeFilter<"EmprestimoSolidario"> | Date | string
    solidario?: XOR<SolidarioScalarRelationFilter, SolidarioWhereInput>
    emprestimo?: XOR<EmprestimoScalarRelationFilter, EmprestimoWhereInput>
  }, "solidario_id_emprestimo_id">

  export type EmprestimoSolidarioOrderByWithAggregationInput = {
    estado?: SortOrder
    solidario_id?: SortOrder
    emprestimo_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmprestimoSolidarioCountOrderByAggregateInput
    _avg?: EmprestimoSolidarioAvgOrderByAggregateInput
    _max?: EmprestimoSolidarioMaxOrderByAggregateInput
    _min?: EmprestimoSolidarioMinOrderByAggregateInput
    _sum?: EmprestimoSolidarioSumOrderByAggregateInput
  }

  export type EmprestimoSolidarioScalarWhereWithAggregatesInput = {
    AND?: EmprestimoSolidarioScalarWhereWithAggregatesInput | EmprestimoSolidarioScalarWhereWithAggregatesInput[]
    OR?: EmprestimoSolidarioScalarWhereWithAggregatesInput[]
    NOT?: EmprestimoSolidarioScalarWhereWithAggregatesInput | EmprestimoSolidarioScalarWhereWithAggregatesInput[]
    estado?: BoolWithAggregatesFilter<"EmprestimoSolidario"> | boolean
    solidario_id?: IntWithAggregatesFilter<"EmprestimoSolidario"> | number
    emprestimo_id?: IntWithAggregatesFilter<"EmprestimoSolidario"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EmprestimoSolidario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmprestimoSolidario"> | Date | string
  }

  export type CreditoSolidarioWhereInput = {
    AND?: CreditoSolidarioWhereInput | CreditoSolidarioWhereInput[]
    OR?: CreditoSolidarioWhereInput[]
    NOT?: CreditoSolidarioWhereInput | CreditoSolidarioWhereInput[]
    estado?: BoolFilter<"CreditoSolidario"> | boolean
    solidario_id?: IntFilter<"CreditoSolidario"> | number
    credito_id?: IntFilter<"CreditoSolidario"> | number
    createdAt?: DateTimeFilter<"CreditoSolidario"> | Date | string
    updatedAt?: DateTimeFilter<"CreditoSolidario"> | Date | string
    solidario?: XOR<SolidarioScalarRelationFilter, SolidarioWhereInput>
    credito?: XOR<CreditoScalarRelationFilter, CreditoWhereInput>
  }

  export type CreditoSolidarioOrderByWithRelationInput = {
    estado?: SortOrder
    solidario_id?: SortOrder
    credito_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    solidario?: SolidarioOrderByWithRelationInput
    credito?: CreditoOrderByWithRelationInput
  }

  export type CreditoSolidarioWhereUniqueInput = Prisma.AtLeast<{
    solidario_id_credito_id?: CreditoSolidarioSolidario_idCredito_idCompoundUniqueInput
    AND?: CreditoSolidarioWhereInput | CreditoSolidarioWhereInput[]
    OR?: CreditoSolidarioWhereInput[]
    NOT?: CreditoSolidarioWhereInput | CreditoSolidarioWhereInput[]
    estado?: BoolFilter<"CreditoSolidario"> | boolean
    solidario_id?: IntFilter<"CreditoSolidario"> | number
    credito_id?: IntFilter<"CreditoSolidario"> | number
    createdAt?: DateTimeFilter<"CreditoSolidario"> | Date | string
    updatedAt?: DateTimeFilter<"CreditoSolidario"> | Date | string
    solidario?: XOR<SolidarioScalarRelationFilter, SolidarioWhereInput>
    credito?: XOR<CreditoScalarRelationFilter, CreditoWhereInput>
  }, "solidario_id_credito_id">

  export type CreditoSolidarioOrderByWithAggregationInput = {
    estado?: SortOrder
    solidario_id?: SortOrder
    credito_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CreditoSolidarioCountOrderByAggregateInput
    _avg?: CreditoSolidarioAvgOrderByAggregateInput
    _max?: CreditoSolidarioMaxOrderByAggregateInput
    _min?: CreditoSolidarioMinOrderByAggregateInput
    _sum?: CreditoSolidarioSumOrderByAggregateInput
  }

  export type CreditoSolidarioScalarWhereWithAggregatesInput = {
    AND?: CreditoSolidarioScalarWhereWithAggregatesInput | CreditoSolidarioScalarWhereWithAggregatesInput[]
    OR?: CreditoSolidarioScalarWhereWithAggregatesInput[]
    NOT?: CreditoSolidarioScalarWhereWithAggregatesInput | CreditoSolidarioScalarWhereWithAggregatesInput[]
    estado?: BoolWithAggregatesFilter<"CreditoSolidario"> | boolean
    solidario_id?: IntWithAggregatesFilter<"CreditoSolidario"> | number
    credito_id?: IntWithAggregatesFilter<"CreditoSolidario"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CreditoSolidario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CreditoSolidario"> | Date | string
  }

  export type DiversificacaoWhereInput = {
    AND?: DiversificacaoWhereInput | DiversificacaoWhereInput[]
    OR?: DiversificacaoWhereInput[]
    NOT?: DiversificacaoWhereInput | DiversificacaoWhereInput[]
    estado?: BoolFilter<"Diversificacao"> | boolean
    investidor_id?: IntFilter<"Diversificacao"> | number
    emprestimo_id?: IntFilter<"Diversificacao"> | number
    taxa?: IntFilter<"Diversificacao"> | number
    protencao?: BoolFilter<"Diversificacao"> | boolean
    createdAt?: DateTimeFilter<"Diversificacao"> | Date | string
    updatedAt?: DateTimeFilter<"Diversificacao"> | Date | string
    investidor?: XOR<InvestidorScalarRelationFilter, InvestidorWhereInput>
    emprestimo?: XOR<EmprestimoScalarRelationFilter, EmprestimoWhereInput>
  }

  export type DiversificacaoOrderByWithRelationInput = {
    estado?: SortOrder
    investidor_id?: SortOrder
    emprestimo_id?: SortOrder
    taxa?: SortOrder
    protencao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    investidor?: InvestidorOrderByWithRelationInput
    emprestimo?: EmprestimoOrderByWithRelationInput
  }

  export type DiversificacaoWhereUniqueInput = Prisma.AtLeast<{
    investidor_id_emprestimo_id?: DiversificacaoInvestidor_idEmprestimo_idCompoundUniqueInput
    AND?: DiversificacaoWhereInput | DiversificacaoWhereInput[]
    OR?: DiversificacaoWhereInput[]
    NOT?: DiversificacaoWhereInput | DiversificacaoWhereInput[]
    estado?: BoolFilter<"Diversificacao"> | boolean
    investidor_id?: IntFilter<"Diversificacao"> | number
    emprestimo_id?: IntFilter<"Diversificacao"> | number
    taxa?: IntFilter<"Diversificacao"> | number
    protencao?: BoolFilter<"Diversificacao"> | boolean
    createdAt?: DateTimeFilter<"Diversificacao"> | Date | string
    updatedAt?: DateTimeFilter<"Diversificacao"> | Date | string
    investidor?: XOR<InvestidorScalarRelationFilter, InvestidorWhereInput>
    emprestimo?: XOR<EmprestimoScalarRelationFilter, EmprestimoWhereInput>
  }, "investidor_id_emprestimo_id">

  export type DiversificacaoOrderByWithAggregationInput = {
    estado?: SortOrder
    investidor_id?: SortOrder
    emprestimo_id?: SortOrder
    taxa?: SortOrder
    protencao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DiversificacaoCountOrderByAggregateInput
    _avg?: DiversificacaoAvgOrderByAggregateInput
    _max?: DiversificacaoMaxOrderByAggregateInput
    _min?: DiversificacaoMinOrderByAggregateInput
    _sum?: DiversificacaoSumOrderByAggregateInput
  }

  export type DiversificacaoScalarWhereWithAggregatesInput = {
    AND?: DiversificacaoScalarWhereWithAggregatesInput | DiversificacaoScalarWhereWithAggregatesInput[]
    OR?: DiversificacaoScalarWhereWithAggregatesInput[]
    NOT?: DiversificacaoScalarWhereWithAggregatesInput | DiversificacaoScalarWhereWithAggregatesInput[]
    estado?: BoolWithAggregatesFilter<"Diversificacao"> | boolean
    investidor_id?: IntWithAggregatesFilter<"Diversificacao"> | number
    emprestimo_id?: IntWithAggregatesFilter<"Diversificacao"> | number
    taxa?: IntWithAggregatesFilter<"Diversificacao"> | number
    protencao?: BoolWithAggregatesFilter<"Diversificacao"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Diversificacao"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Diversificacao"> | Date | string
  }

  export type SaqueWhereInput = {
    AND?: SaqueWhereInput | SaqueWhereInput[]
    OR?: SaqueWhereInput[]
    NOT?: SaqueWhereInput | SaqueWhereInput[]
    id?: IntFilter<"Saque"> | number
    valor?: FloatFilter<"Saque"> | number
    taxa?: IntFilter<"Saque"> | number
    estado?: BoolFilter<"Saque"> | boolean
    pendencia?: BoolFilter<"Saque"> | boolean
    user_id?: IntFilter<"Saque"> | number
    createdAt?: DateTimeFilter<"Saque"> | Date | string
    updatedAt?: DateTimeFilter<"Saque"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SaqueOrderByWithRelationInput = {
    id?: SortOrder
    valor?: SortOrder
    taxa?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SaqueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: SaqueWhereInput | SaqueWhereInput[]
    OR?: SaqueWhereInput[]
    NOT?: SaqueWhereInput | SaqueWhereInput[]
    valor?: FloatFilter<"Saque"> | number
    taxa?: IntFilter<"Saque"> | number
    estado?: BoolFilter<"Saque"> | boolean
    pendencia?: BoolFilter<"Saque"> | boolean
    createdAt?: DateTimeFilter<"Saque"> | Date | string
    updatedAt?: DateTimeFilter<"Saque"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "user_id">

  export type SaqueOrderByWithAggregationInput = {
    id?: SortOrder
    valor?: SortOrder
    taxa?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SaqueCountOrderByAggregateInput
    _avg?: SaqueAvgOrderByAggregateInput
    _max?: SaqueMaxOrderByAggregateInput
    _min?: SaqueMinOrderByAggregateInput
    _sum?: SaqueSumOrderByAggregateInput
  }

  export type SaqueScalarWhereWithAggregatesInput = {
    AND?: SaqueScalarWhereWithAggregatesInput | SaqueScalarWhereWithAggregatesInput[]
    OR?: SaqueScalarWhereWithAggregatesInput[]
    NOT?: SaqueScalarWhereWithAggregatesInput | SaqueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Saque"> | number
    valor?: FloatWithAggregatesFilter<"Saque"> | number
    taxa?: IntWithAggregatesFilter<"Saque"> | number
    estado?: BoolWithAggregatesFilter<"Saque"> | boolean
    pendencia?: BoolWithAggregatesFilter<"Saque"> | boolean
    user_id?: IntWithAggregatesFilter<"Saque"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Saque"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Saque"> | Date | string
  }

  export type DepositoWhereInput = {
    AND?: DepositoWhereInput | DepositoWhereInput[]
    OR?: DepositoWhereInput[]
    NOT?: DepositoWhereInput | DepositoWhereInput[]
    id?: IntFilter<"Deposito"> | number
    valor?: FloatFilter<"Deposito"> | number
    estado?: BoolFilter<"Deposito"> | boolean
    pendencia?: BoolFilter<"Deposito"> | boolean
    user_id?: IntFilter<"Deposito"> | number
    createdAt?: DateTimeFilter<"Deposito"> | Date | string
    updatedAt?: DateTimeFilter<"Deposito"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DepositoOrderByWithRelationInput = {
    id?: SortOrder
    valor?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DepositoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: DepositoWhereInput | DepositoWhereInput[]
    OR?: DepositoWhereInput[]
    NOT?: DepositoWhereInput | DepositoWhereInput[]
    valor?: FloatFilter<"Deposito"> | number
    estado?: BoolFilter<"Deposito"> | boolean
    pendencia?: BoolFilter<"Deposito"> | boolean
    createdAt?: DateTimeFilter<"Deposito"> | Date | string
    updatedAt?: DateTimeFilter<"Deposito"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "user_id">

  export type DepositoOrderByWithAggregationInput = {
    id?: SortOrder
    valor?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepositoCountOrderByAggregateInput
    _avg?: DepositoAvgOrderByAggregateInput
    _max?: DepositoMaxOrderByAggregateInput
    _min?: DepositoMinOrderByAggregateInput
    _sum?: DepositoSumOrderByAggregateInput
  }

  export type DepositoScalarWhereWithAggregatesInput = {
    AND?: DepositoScalarWhereWithAggregatesInput | DepositoScalarWhereWithAggregatesInput[]
    OR?: DepositoScalarWhereWithAggregatesInput[]
    NOT?: DepositoScalarWhereWithAggregatesInput | DepositoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Deposito"> | number
    valor?: FloatWithAggregatesFilter<"Deposito"> | number
    estado?: BoolWithAggregatesFilter<"Deposito"> | boolean
    pendencia?: BoolWithAggregatesFilter<"Deposito"> | boolean
    user_id?: IntWithAggregatesFilter<"Deposito"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Deposito"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deposito"> | Date | string
  }

  export type CarteiraWhereInput = {
    AND?: CarteiraWhereInput | CarteiraWhereInput[]
    OR?: CarteiraWhereInput[]
    NOT?: CarteiraWhereInput | CarteiraWhereInput[]
    id?: IntFilter<"Carteira"> | number
    saldo?: FloatFilter<"Carteira"> | number
    estado?: BoolFilter<"Carteira"> | boolean
    numero?: IntFilter<"Carteira"> | number
    codigo?: IntFilter<"Carteira"> | number
    user_id?: IntFilter<"Carteira"> | number
    createdAt?: DateTimeFilter<"Carteira"> | Date | string
    updatedAt?: DateTimeFilter<"Carteira"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CarteiraOrderByWithRelationInput = {
    id?: SortOrder
    saldo?: SortOrder
    estado?: SortOrder
    numero?: SortOrder
    codigo?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CarteiraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    numero?: number
    codigo?: number
    user_id?: number
    AND?: CarteiraWhereInput | CarteiraWhereInput[]
    OR?: CarteiraWhereInput[]
    NOT?: CarteiraWhereInput | CarteiraWhereInput[]
    saldo?: FloatFilter<"Carteira"> | number
    estado?: BoolFilter<"Carteira"> | boolean
    createdAt?: DateTimeFilter<"Carteira"> | Date | string
    updatedAt?: DateTimeFilter<"Carteira"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "numero" | "codigo" | "user_id">

  export type CarteiraOrderByWithAggregationInput = {
    id?: SortOrder
    saldo?: SortOrder
    estado?: SortOrder
    numero?: SortOrder
    codigo?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CarteiraCountOrderByAggregateInput
    _avg?: CarteiraAvgOrderByAggregateInput
    _max?: CarteiraMaxOrderByAggregateInput
    _min?: CarteiraMinOrderByAggregateInput
    _sum?: CarteiraSumOrderByAggregateInput
  }

  export type CarteiraScalarWhereWithAggregatesInput = {
    AND?: CarteiraScalarWhereWithAggregatesInput | CarteiraScalarWhereWithAggregatesInput[]
    OR?: CarteiraScalarWhereWithAggregatesInput[]
    NOT?: CarteiraScalarWhereWithAggregatesInput | CarteiraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Carteira"> | number
    saldo?: FloatWithAggregatesFilter<"Carteira"> | number
    estado?: BoolWithAggregatesFilter<"Carteira"> | boolean
    numero?: IntWithAggregatesFilter<"Carteira"> | number
    codigo?: IntWithAggregatesFilter<"Carteira"> | number
    user_id?: IntWithAggregatesFilter<"Carteira"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Carteira"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Carteira"> | Date | string
  }

  export type PagamentoWhereInput = {
    AND?: PagamentoWhereInput | PagamentoWhereInput[]
    OR?: PagamentoWhereInput[]
    NOT?: PagamentoWhereInput | PagamentoWhereInput[]
    id?: IntFilter<"Pagamento"> | number
    valor?: FloatFilter<"Pagamento"> | number
    detalhe?: StringFilter<"Pagamento"> | string
    prestacao?: IntFilter<"Pagamento"> | number
    estado?: BoolFilter<"Pagamento"> | boolean
    pendencia?: BoolFilter<"Pagamento"> | boolean
    devedor_id?: IntFilter<"Pagamento"> | number
    createdAt?: DateTimeFilter<"Pagamento"> | Date | string
    updatedAt?: DateTimeFilter<"Pagamento"> | Date | string
    devedor?: XOR<DevedorScalarRelationFilter, DevedorWhereInput>
  }

  export type PagamentoOrderByWithRelationInput = {
    id?: SortOrder
    valor?: SortOrder
    detalhe?: SortOrder
    prestacao?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    devedor_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    devedor?: DevedorOrderByWithRelationInput
    _relevance?: PagamentoOrderByRelevanceInput
  }

  export type PagamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PagamentoWhereInput | PagamentoWhereInput[]
    OR?: PagamentoWhereInput[]
    NOT?: PagamentoWhereInput | PagamentoWhereInput[]
    valor?: FloatFilter<"Pagamento"> | number
    detalhe?: StringFilter<"Pagamento"> | string
    prestacao?: IntFilter<"Pagamento"> | number
    estado?: BoolFilter<"Pagamento"> | boolean
    pendencia?: BoolFilter<"Pagamento"> | boolean
    devedor_id?: IntFilter<"Pagamento"> | number
    createdAt?: DateTimeFilter<"Pagamento"> | Date | string
    updatedAt?: DateTimeFilter<"Pagamento"> | Date | string
    devedor?: XOR<DevedorScalarRelationFilter, DevedorWhereInput>
  }, "id">

  export type PagamentoOrderByWithAggregationInput = {
    id?: SortOrder
    valor?: SortOrder
    detalhe?: SortOrder
    prestacao?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    devedor_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PagamentoCountOrderByAggregateInput
    _avg?: PagamentoAvgOrderByAggregateInput
    _max?: PagamentoMaxOrderByAggregateInput
    _min?: PagamentoMinOrderByAggregateInput
    _sum?: PagamentoSumOrderByAggregateInput
  }

  export type PagamentoScalarWhereWithAggregatesInput = {
    AND?: PagamentoScalarWhereWithAggregatesInput | PagamentoScalarWhereWithAggregatesInput[]
    OR?: PagamentoScalarWhereWithAggregatesInput[]
    NOT?: PagamentoScalarWhereWithAggregatesInput | PagamentoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pagamento"> | number
    valor?: FloatWithAggregatesFilter<"Pagamento"> | number
    detalhe?: StringWithAggregatesFilter<"Pagamento"> | string
    prestacao?: IntWithAggregatesFilter<"Pagamento"> | number
    estado?: BoolWithAggregatesFilter<"Pagamento"> | boolean
    pendencia?: BoolWithAggregatesFilter<"Pagamento"> | boolean
    devedor_id?: IntWithAggregatesFilter<"Pagamento"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Pagamento"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pagamento"> | Date | string
  }

  export type ReembolsoWhereInput = {
    AND?: ReembolsoWhereInput | ReembolsoWhereInput[]
    OR?: ReembolsoWhereInput[]
    NOT?: ReembolsoWhereInput | ReembolsoWhereInput[]
    id?: IntFilter<"Reembolso"> | number
    valor?: FloatFilter<"Reembolso"> | number
    prestacao?: IntFilter<"Reembolso"> | number
    estado?: BoolFilter<"Reembolso"> | boolean
    detalhe?: StringFilter<"Reembolso"> | string
    proponente_id?: IntFilter<"Reembolso"> | number
    createdAt?: DateTimeFilter<"Reembolso"> | Date | string
    updatedAt?: DateTimeFilter<"Reembolso"> | Date | string
    proponente?: XOR<ProponenteScalarRelationFilter, ProponenteWhereInput>
  }

  export type ReembolsoOrderByWithRelationInput = {
    id?: SortOrder
    valor?: SortOrder
    prestacao?: SortOrder
    estado?: SortOrder
    detalhe?: SortOrder
    proponente_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proponente?: ProponenteOrderByWithRelationInput
    _relevance?: ReembolsoOrderByRelevanceInput
  }

  export type ReembolsoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReembolsoWhereInput | ReembolsoWhereInput[]
    OR?: ReembolsoWhereInput[]
    NOT?: ReembolsoWhereInput | ReembolsoWhereInput[]
    valor?: FloatFilter<"Reembolso"> | number
    prestacao?: IntFilter<"Reembolso"> | number
    estado?: BoolFilter<"Reembolso"> | boolean
    detalhe?: StringFilter<"Reembolso"> | string
    proponente_id?: IntFilter<"Reembolso"> | number
    createdAt?: DateTimeFilter<"Reembolso"> | Date | string
    updatedAt?: DateTimeFilter<"Reembolso"> | Date | string
    proponente?: XOR<ProponenteScalarRelationFilter, ProponenteWhereInput>
  }, "id">

  export type ReembolsoOrderByWithAggregationInput = {
    id?: SortOrder
    valor?: SortOrder
    prestacao?: SortOrder
    estado?: SortOrder
    detalhe?: SortOrder
    proponente_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReembolsoCountOrderByAggregateInput
    _avg?: ReembolsoAvgOrderByAggregateInput
    _max?: ReembolsoMaxOrderByAggregateInput
    _min?: ReembolsoMinOrderByAggregateInput
    _sum?: ReembolsoSumOrderByAggregateInput
  }

  export type ReembolsoScalarWhereWithAggregatesInput = {
    AND?: ReembolsoScalarWhereWithAggregatesInput | ReembolsoScalarWhereWithAggregatesInput[]
    OR?: ReembolsoScalarWhereWithAggregatesInput[]
    NOT?: ReembolsoScalarWhereWithAggregatesInput | ReembolsoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Reembolso"> | number
    valor?: FloatWithAggregatesFilter<"Reembolso"> | number
    prestacao?: IntWithAggregatesFilter<"Reembolso"> | number
    estado?: BoolWithAggregatesFilter<"Reembolso"> | boolean
    detalhe?: StringWithAggregatesFilter<"Reembolso"> | string
    proponente_id?: IntWithAggregatesFilter<"Reembolso"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Reembolso"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reembolso"> | Date | string
  }

  export type UserCreateInput = {
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaCreateNestedOneWithoutUserInput
    documento?: DocumentoCreateNestedManyWithoutUserInput
    devedor?: DevedorCreateNestedOneWithoutUserInput
    investidor?: InvestidorCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoCreateNestedManyWithoutUserInput
    proponente?: ProponenteCreateNestedOneWithoutUserInput
    saque?: SaqueCreateNestedManyWithoutUserInput
    deposito?: DepositoCreateNestedManyWithoutUserInput
    carteira?: CarteiraCreateNestedOneWithoutUserInput
    papel?: PapelCreateNestedOneWithoutUserInput
    solidario?: SolidarioCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaUncheckedCreateNestedOneWithoutUserInput
    documento?: DocumentoUncheckedCreateNestedManyWithoutUserInput
    devedor?: DevedorUncheckedCreateNestedOneWithoutUserInput
    investidor?: InvestidorUncheckedCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoUncheckedCreateNestedManyWithoutUserInput
    proponente?: ProponenteUncheckedCreateNestedOneWithoutUserInput
    saque?: SaqueUncheckedCreateNestedManyWithoutUserInput
    deposito?: DepositoUncheckedCreateNestedManyWithoutUserInput
    carteira?: CarteiraUncheckedCreateNestedOneWithoutUserInput
    papel?: PapelUncheckedCreateNestedOneWithoutUserInput
    solidario?: SolidarioUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUpdateOneWithoutUserNestedInput
    documento?: DocumentoUpdateManyWithoutUserNestedInput
    devedor?: DevedorUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUpdateOneWithoutUserNestedInput
    saque?: SaqueUpdateManyWithoutUserNestedInput
    deposito?: DepositoUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUpdateOneWithoutUserNestedInput
    papel?: PapelUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUncheckedUpdateOneWithoutUserNestedInput
    documento?: DocumentoUncheckedUpdateManyWithoutUserNestedInput
    devedor?: DevedorUncheckedUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUncheckedUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUncheckedUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUncheckedUpdateOneWithoutUserNestedInput
    saque?: SaqueUncheckedUpdateManyWithoutUserNestedInput
    deposito?: DepositoUncheckedUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUncheckedUpdateOneWithoutUserNestedInput
    papel?: PapelUncheckedUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
  }

  export type UserUpdateManyMutationInput = {
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmpregoCreateInput = {
    data_inicio: Date | string
    sector: $Enums.Sector
    cargo: string
    area: $Enums.Area
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pessoa?: PessoaCreateNestedManyWithoutEmpregoInput
  }

  export type EmpregoUncheckedCreateInput = {
    id?: number
    data_inicio: Date | string
    sector: $Enums.Sector
    cargo: string
    area: $Enums.Area
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pessoa?: PessoaUncheckedCreateNestedManyWithoutEmpregoInput
  }

  export type EmpregoUpdateInput = {
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    cargo?: StringFieldUpdateOperationsInput | string
    area?: EnumAreaFieldUpdateOperationsInput | $Enums.Area
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pessoa?: PessoaUpdateManyWithoutEmpregoNestedInput
  }

  export type EmpregoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    cargo?: StringFieldUpdateOperationsInput | string
    area?: EnumAreaFieldUpdateOperationsInput | $Enums.Area
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pessoa?: PessoaUncheckedUpdateManyWithoutEmpregoNestedInput
  }

  export type EmpregoCreateManyInput = {
    id?: number
    data_inicio: Date | string
    sector: $Enums.Sector
    cargo: string
    area: $Enums.Area
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmpregoUpdateManyMutationInput = {
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    cargo?: StringFieldUpdateOperationsInput | string
    area?: EnumAreaFieldUpdateOperationsInput | $Enums.Area
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpregoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    cargo?: StringFieldUpdateOperationsInput | string
    area?: EnumAreaFieldUpdateOperationsInput | $Enums.Area
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResidenciaCreateInput = {
    tipo: $Enums.Propriedade
    data_inicio: Date | string
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pessoa?: PessoaCreateNestedManyWithoutResidenciaInput
  }

  export type ResidenciaUncheckedCreateInput = {
    id?: number
    tipo: $Enums.Propriedade
    data_inicio: Date | string
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pessoa?: PessoaUncheckedCreateNestedManyWithoutResidenciaInput
  }

  export type ResidenciaUpdateInput = {
    tipo?: EnumPropriedadeFieldUpdateOperationsInput | $Enums.Propriedade
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pessoa?: PessoaUpdateManyWithoutResidenciaNestedInput
  }

  export type ResidenciaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumPropriedadeFieldUpdateOperationsInput | $Enums.Propriedade
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pessoa?: PessoaUncheckedUpdateManyWithoutResidenciaNestedInput
  }

  export type ResidenciaCreateManyInput = {
    id?: number
    tipo: $Enums.Propriedade
    data_inicio: Date | string
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResidenciaUpdateManyMutationInput = {
    tipo?: EnumPropriedadeFieldUpdateOperationsInput | $Enums.Propriedade
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResidenciaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumPropriedadeFieldUpdateOperationsInput | $Enums.Propriedade
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PapelCreateInput = {
    perfil: $Enums.Perfil
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPapelInput
  }

  export type PapelUncheckedCreateInput = {
    id?: number
    perfil: $Enums.Perfil
    user_id: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PapelUpdateInput = {
    perfil?: EnumPerfilFieldUpdateOperationsInput | $Enums.Perfil
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPapelNestedInput
  }

  export type PapelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    perfil?: EnumPerfilFieldUpdateOperationsInput | $Enums.Perfil
    user_id?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PapelCreateManyInput = {
    id?: number
    perfil: $Enums.Perfil
    user_id: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PapelUpdateManyMutationInput = {
    perfil?: EnumPerfilFieldUpdateOperationsInput | $Enums.Perfil
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PapelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    perfil?: EnumPerfilFieldUpdateOperationsInput | $Enums.Perfil
    user_id?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PessoaCreateInput = {
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado?: boolean
    nivel_instrucao: string
    data_nascimento: Date | string
    user: UserCreateNestedOneWithoutPessoaInput
    emprego: EmpregoCreateNestedOneWithoutPessoaInput
    residencia: ResidenciaCreateNestedOneWithoutPessoaInput
    conjugue?: ConjugueCreateNestedOneWithoutPessoaInput
    solidario?: SolidarioCreateNestedOneWithoutPessoaInput
    conta?: ContaCreateNestedOneWithoutPessoaInput
  }

  export type PessoaUncheckedCreateInput = {
    id?: number
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado?: boolean
    nivel_instrucao: string
    data_nascimento: Date | string
    user_id: number
    emprego_id: number
    residencia_id: number
    conjugue?: ConjugueUncheckedCreateNestedOneWithoutPessoaInput
    solidario?: SolidarioUncheckedCreateNestedOneWithoutPessoaInput
    conta?: ContaUncheckedCreateNestedOneWithoutPessoaInput
  }

  export type PessoaUpdateInput = {
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPessoaNestedInput
    emprego?: EmpregoUpdateOneRequiredWithoutPessoaNestedInput
    residencia?: ResidenciaUpdateOneRequiredWithoutPessoaNestedInput
    conjugue?: ConjugueUpdateOneWithoutPessoaNestedInput
    solidario?: SolidarioUpdateOneWithoutPessoaNestedInput
    conta?: ContaUpdateOneWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    emprego_id?: IntFieldUpdateOperationsInput | number
    residencia_id?: IntFieldUpdateOperationsInput | number
    conjugue?: ConjugueUncheckedUpdateOneWithoutPessoaNestedInput
    solidario?: SolidarioUncheckedUpdateOneWithoutPessoaNestedInput
    conta?: ContaUncheckedUpdateOneWithoutPessoaNestedInput
  }

  export type PessoaCreateManyInput = {
    id?: number
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado?: boolean
    nivel_instrucao: string
    data_nascimento: Date | string
    user_id: number
    emprego_id: number
    residencia_id: number
  }

  export type PessoaUpdateManyMutationInput = {
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PessoaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    emprego_id?: IntFieldUpdateOperationsInput | number
    residencia_id?: IntFieldUpdateOperationsInput | number
  }

  export type ContaCreateInput = {
    nome: string
    salario: number
    iban: string
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pessoa: PessoaCreateNestedOneWithoutContaInput
  }

  export type ContaUncheckedCreateInput = {
    id?: number
    nome: string
    salario: number
    iban: string
    estado?: boolean
    pessoa_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    salario?: IntFieldUpdateOperationsInput | number
    iban?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pessoa?: PessoaUpdateOneRequiredWithoutContaNestedInput
  }

  export type ContaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    salario?: IntFieldUpdateOperationsInput | number
    iban?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContaCreateManyInput = {
    id?: number
    nome: string
    salario: number
    iban: string
    estado?: boolean
    pessoa_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    salario?: IntFieldUpdateOperationsInput | number
    iban?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    salario?: IntFieldUpdateOperationsInput | number
    iban?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConjugueCreateInput = {
    nome_completo: string
    dependentes: number
    nivel_instrucao: string
    estado?: boolean
    data_nascimento: Date | string
    pessoa: PessoaCreateNestedOneWithoutConjugueInput
  }

  export type ConjugueUncheckedCreateInput = {
    id?: number
    nome_completo: string
    dependentes: number
    nivel_instrucao: string
    estado?: boolean
    data_nascimento: Date | string
    pessoa_id: number
  }

  export type ConjugueUpdateInput = {
    nome_completo?: StringFieldUpdateOperationsInput | string
    dependentes?: IntFieldUpdateOperationsInput | number
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    pessoa?: PessoaUpdateOneRequiredWithoutConjugueNestedInput
  }

  export type ConjugueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome_completo?: StringFieldUpdateOperationsInput | string
    dependentes?: IntFieldUpdateOperationsInput | number
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    pessoa_id?: IntFieldUpdateOperationsInput | number
  }

  export type ConjugueCreateManyInput = {
    id?: number
    nome_completo: string
    dependentes: number
    nivel_instrucao: string
    estado?: boolean
    data_nascimento: Date | string
    pessoa_id: number
  }

  export type ConjugueUpdateManyMutationInput = {
    nome_completo?: StringFieldUpdateOperationsInput | string
    dependentes?: IntFieldUpdateOperationsInput | number
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConjugueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome_completo?: StringFieldUpdateOperationsInput | string
    dependentes?: IntFieldUpdateOperationsInput | number
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    pessoa_id?: IntFieldUpdateOperationsInput | number
  }

  export type DocumentoCreateInput = {
    tipo: $Enums.Comprovativo
    titulo: string
    extensao: string
    tamanho: string
    nome_original: string
    nome_salvado: string
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentoInput
  }

  export type DocumentoUncheckedCreateInput = {
    id?: number
    tipo: $Enums.Comprovativo
    titulo: string
    extensao: string
    tamanho: string
    nome_original: string
    nome_salvado: string
    estado?: boolean
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentoUpdateInput = {
    tipo?: EnumComprovativoFieldUpdateOperationsInput | $Enums.Comprovativo
    titulo?: StringFieldUpdateOperationsInput | string
    extensao?: StringFieldUpdateOperationsInput | string
    tamanho?: StringFieldUpdateOperationsInput | string
    nome_original?: StringFieldUpdateOperationsInput | string
    nome_salvado?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentoNestedInput
  }

  export type DocumentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumComprovativoFieldUpdateOperationsInput | $Enums.Comprovativo
    titulo?: StringFieldUpdateOperationsInput | string
    extensao?: StringFieldUpdateOperationsInput | string
    tamanho?: StringFieldUpdateOperationsInput | string
    nome_original?: StringFieldUpdateOperationsInput | string
    nome_salvado?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentoCreateManyInput = {
    id?: number
    tipo: $Enums.Comprovativo
    titulo: string
    extensao: string
    tamanho: string
    nome_original: string
    nome_salvado: string
    estado?: boolean
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentoUpdateManyMutationInput = {
    tipo?: EnumComprovativoFieldUpdateOperationsInput | $Enums.Comprovativo
    titulo?: StringFieldUpdateOperationsInput | string
    extensao?: StringFieldUpdateOperationsInput | string
    tamanho?: StringFieldUpdateOperationsInput | string
    nome_original?: StringFieldUpdateOperationsInput | string
    nome_salvado?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumComprovativoFieldUpdateOperationsInput | $Enums.Comprovativo
    titulo?: StringFieldUpdateOperationsInput | string
    extensao?: StringFieldUpdateOperationsInput | string
    tamanho?: StringFieldUpdateOperationsInput | string
    nome_original?: StringFieldUpdateOperationsInput | string
    nome_salvado?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DevedorCreateInput = {
    solicitacao?: number
    adimplencia?: number
    inadimplencia?: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDevedorInput
    credito?: CreditoCreateNestedManyWithoutDevedorInput
    movel?: MovelCreateNestedManyWithoutDevedorInput
    pagamento?: PagamentoCreateNestedManyWithoutDevedorInput
  }

  export type DevedorUncheckedCreateInput = {
    id?: number
    user_id: number
    solicitacao?: number
    adimplencia?: number
    inadimplencia?: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    credito?: CreditoUncheckedCreateNestedManyWithoutDevedorInput
    movel?: MovelUncheckedCreateNestedManyWithoutDevedorInput
    pagamento?: PagamentoUncheckedCreateNestedManyWithoutDevedorInput
  }

  export type DevedorUpdateInput = {
    solicitacao?: IntFieldUpdateOperationsInput | number
    adimplencia?: IntFieldUpdateOperationsInput | number
    inadimplencia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevedorNestedInput
    credito?: CreditoUpdateManyWithoutDevedorNestedInput
    movel?: MovelUpdateManyWithoutDevedorNestedInput
    pagamento?: PagamentoUpdateManyWithoutDevedorNestedInput
  }

  export type DevedorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    solicitacao?: IntFieldUpdateOperationsInput | number
    adimplencia?: IntFieldUpdateOperationsInput | number
    inadimplencia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credito?: CreditoUncheckedUpdateManyWithoutDevedorNestedInput
    movel?: MovelUncheckedUpdateManyWithoutDevedorNestedInput
    pagamento?: PagamentoUncheckedUpdateManyWithoutDevedorNestedInput
  }

  export type DevedorCreateManyInput = {
    id?: number
    user_id: number
    solicitacao?: number
    adimplencia?: number
    inadimplencia?: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DevedorUpdateManyMutationInput = {
    solicitacao?: IntFieldUpdateOperationsInput | number
    adimplencia?: IntFieldUpdateOperationsInput | number
    inadimplencia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DevedorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    solicitacao?: IntFieldUpdateOperationsInput | number
    adimplencia?: IntFieldUpdateOperationsInput | number
    inadimplencia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestidorCreateInput = {
    maior_risco: boolean
    maior_seguranca: boolean
    saque_antecipado: boolean
    fundo_protegido: boolean
    estado?: boolean
    partilhar_emprestimo: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    diversificacao?: DiversificacaoCreateNestedManyWithoutInvestidorInput
    user: UserCreateNestedOneWithoutInvestidorInput
  }

  export type InvestidorUncheckedCreateInput = {
    id?: number
    maior_risco: boolean
    maior_seguranca: boolean
    saque_antecipado: boolean
    fundo_protegido: boolean
    estado?: boolean
    partilhar_emprestimo: boolean
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    diversificacao?: DiversificacaoUncheckedCreateNestedManyWithoutInvestidorInput
  }

  export type InvestidorUpdateInput = {
    maior_risco?: BoolFieldUpdateOperationsInput | boolean
    maior_seguranca?: BoolFieldUpdateOperationsInput | boolean
    saque_antecipado?: BoolFieldUpdateOperationsInput | boolean
    fundo_protegido?: BoolFieldUpdateOperationsInput | boolean
    estado?: BoolFieldUpdateOperationsInput | boolean
    partilhar_emprestimo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    diversificacao?: DiversificacaoUpdateManyWithoutInvestidorNestedInput
    user?: UserUpdateOneRequiredWithoutInvestidorNestedInput
  }

  export type InvestidorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    maior_risco?: BoolFieldUpdateOperationsInput | boolean
    maior_seguranca?: BoolFieldUpdateOperationsInput | boolean
    saque_antecipado?: BoolFieldUpdateOperationsInput | boolean
    fundo_protegido?: BoolFieldUpdateOperationsInput | boolean
    estado?: BoolFieldUpdateOperationsInput | boolean
    partilhar_emprestimo?: BoolFieldUpdateOperationsInput | boolean
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    diversificacao?: DiversificacaoUncheckedUpdateManyWithoutInvestidorNestedInput
  }

  export type InvestidorCreateManyInput = {
    id?: number
    maior_risco: boolean
    maior_seguranca: boolean
    saque_antecipado: boolean
    fundo_protegido: boolean
    estado?: boolean
    partilhar_emprestimo: boolean
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestidorUpdateManyMutationInput = {
    maior_risco?: BoolFieldUpdateOperationsInput | boolean
    maior_seguranca?: BoolFieldUpdateOperationsInput | boolean
    saque_antecipado?: BoolFieldUpdateOperationsInput | boolean
    fundo_protegido?: BoolFieldUpdateOperationsInput | boolean
    estado?: BoolFieldUpdateOperationsInput | boolean
    partilhar_emprestimo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestidorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    maior_risco?: BoolFieldUpdateOperationsInput | boolean
    maior_seguranca?: BoolFieldUpdateOperationsInput | boolean
    saque_antecipado?: BoolFieldUpdateOperationsInput | boolean
    fundo_protegido?: BoolFieldUpdateOperationsInput | boolean
    estado?: BoolFieldUpdateOperationsInput | boolean
    partilhar_emprestimo?: BoolFieldUpdateOperationsInput | boolean
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReclamacaoCreateInput = {
    estado?: boolean
    assunto: string
    conteudo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReclamacaoInput
  }

  export type ReclamacaoUncheckedCreateInput = {
    id?: number
    user_id: number
    estado?: boolean
    assunto: string
    conteudo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReclamacaoUpdateInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    assunto?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReclamacaoNestedInput
  }

  export type ReclamacaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    assunto?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReclamacaoCreateManyInput = {
    id?: number
    user_id: number
    estado?: boolean
    assunto: string
    conteudo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReclamacaoUpdateManyMutationInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    assunto?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReclamacaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    assunto?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProponenteCreateInput = {
    solicitacao: number
    reembolsar: number
    satisfeitos: number
    insatisfeitos: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    emprestimo?: EmprestimoCreateNestedManyWithoutProponenteInput
    reembolso?: ReembolsoCreateNestedManyWithoutProponenteInput
    user: UserCreateNestedOneWithoutProponenteInput
  }

  export type ProponenteUncheckedCreateInput = {
    id?: number
    solicitacao: number
    reembolsar: number
    satisfeitos: number
    insatisfeitos: number
    estado?: boolean
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emprestimo?: EmprestimoUncheckedCreateNestedManyWithoutProponenteInput
    reembolso?: ReembolsoUncheckedCreateNestedManyWithoutProponenteInput
  }

  export type ProponenteUpdateInput = {
    solicitacao?: IntFieldUpdateOperationsInput | number
    reembolsar?: IntFieldUpdateOperationsInput | number
    satisfeitos?: IntFieldUpdateOperationsInput | number
    insatisfeitos?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprestimo?: EmprestimoUpdateManyWithoutProponenteNestedInput
    reembolso?: ReembolsoUpdateManyWithoutProponenteNestedInput
    user?: UserUpdateOneRequiredWithoutProponenteNestedInput
  }

  export type ProponenteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    solicitacao?: IntFieldUpdateOperationsInput | number
    reembolsar?: IntFieldUpdateOperationsInput | number
    satisfeitos?: IntFieldUpdateOperationsInput | number
    insatisfeitos?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprestimo?: EmprestimoUncheckedUpdateManyWithoutProponenteNestedInput
    reembolso?: ReembolsoUncheckedUpdateManyWithoutProponenteNestedInput
  }

  export type ProponenteCreateManyInput = {
    id?: number
    solicitacao: number
    reembolsar: number
    satisfeitos: number
    insatisfeitos: number
    estado?: boolean
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProponenteUpdateManyMutationInput = {
    solicitacao?: IntFieldUpdateOperationsInput | number
    reembolsar?: IntFieldUpdateOperationsInput | number
    satisfeitos?: IntFieldUpdateOperationsInput | number
    insatisfeitos?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProponenteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    solicitacao?: IntFieldUpdateOperationsInput | number
    reembolsar?: IntFieldUpdateOperationsInput | number
    satisfeitos?: IntFieldUpdateOperationsInput | number
    insatisfeitos?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SolidarioCreateInput = {
    tipo: $Enums.Aval
    parentesco: $Enums.Parentesco
    taxa: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pessoa: PessoaCreateNestedOneWithoutSolidarioInput
    emprestimo?: EmprestimoSolidarioCreateNestedManyWithoutSolidarioInput
    user: UserCreateNestedOneWithoutSolidarioInput
    credito?: CreditoSolidarioCreateNestedManyWithoutSolidarioInput
  }

  export type SolidarioUncheckedCreateInput = {
    id?: number
    tipo: $Enums.Aval
    parentesco: $Enums.Parentesco
    taxa: number
    estado?: boolean
    pessoa_id: number
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emprestimo?: EmprestimoSolidarioUncheckedCreateNestedManyWithoutSolidarioInput
    credito?: CreditoSolidarioUncheckedCreateNestedManyWithoutSolidarioInput
  }

  export type SolidarioUpdateInput = {
    tipo?: EnumAvalFieldUpdateOperationsInput | $Enums.Aval
    parentesco?: EnumParentescoFieldUpdateOperationsInput | $Enums.Parentesco
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pessoa?: PessoaUpdateOneRequiredWithoutSolidarioNestedInput
    emprestimo?: EmprestimoSolidarioUpdateManyWithoutSolidarioNestedInput
    user?: UserUpdateOneRequiredWithoutSolidarioNestedInput
    credito?: CreditoSolidarioUpdateManyWithoutSolidarioNestedInput
  }

  export type SolidarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumAvalFieldUpdateOperationsInput | $Enums.Aval
    parentesco?: EnumParentescoFieldUpdateOperationsInput | $Enums.Parentesco
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprestimo?: EmprestimoSolidarioUncheckedUpdateManyWithoutSolidarioNestedInput
    credito?: CreditoSolidarioUncheckedUpdateManyWithoutSolidarioNestedInput
  }

  export type SolidarioCreateManyInput = {
    id?: number
    tipo: $Enums.Aval
    parentesco: $Enums.Parentesco
    taxa: number
    estado?: boolean
    pessoa_id: number
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SolidarioUpdateManyMutationInput = {
    tipo?: EnumAvalFieldUpdateOperationsInput | $Enums.Aval
    parentesco?: EnumParentescoFieldUpdateOperationsInput | $Enums.Parentesco
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SolidarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumAvalFieldUpdateOperationsInput | $Enums.Aval
    parentesco?: EnumParentescoFieldUpdateOperationsInput | $Enums.Parentesco
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovelCreateInput = {
    modelo: $Enums.Modelo
    matricula: string
    detalhes: string
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    devedor: DevedorCreateNestedOneWithoutMovelInput
  }

  export type MovelUncheckedCreateInput = {
    id?: number
    modelo: $Enums.Modelo
    matricula: string
    detalhes: string
    devedor_id: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovelUpdateInput = {
    modelo?: EnumModeloFieldUpdateOperationsInput | $Enums.Modelo
    matricula?: StringFieldUpdateOperationsInput | string
    detalhes?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devedor?: DevedorUpdateOneRequiredWithoutMovelNestedInput
  }

  export type MovelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelo?: EnumModeloFieldUpdateOperationsInput | $Enums.Modelo
    matricula?: StringFieldUpdateOperationsInput | string
    detalhes?: StringFieldUpdateOperationsInput | string
    devedor_id?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovelCreateManyInput = {
    id?: number
    modelo: $Enums.Modelo
    matricula: string
    detalhes: string
    devedor_id: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovelUpdateManyMutationInput = {
    modelo?: EnumModeloFieldUpdateOperationsInput | $Enums.Modelo
    matricula?: StringFieldUpdateOperationsInput | string
    detalhes?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelo?: EnumModeloFieldUpdateOperationsInput | $Enums.Modelo
    matricula?: StringFieldUpdateOperationsInput | string
    detalhes?: StringFieldUpdateOperationsInput | string
    devedor_id?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditoCreateInput = {
    tipo: $Enums.Produto
    valor: number
    prestacao: number
    juro: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    createdAt?: Date | string
    updatedAt?: Date | string
    solidario?: CreditoSolidarioCreateNestedManyWithoutCreditoInput
    devedor: DevedorCreateNestedOneWithoutCreditoInput
  }

  export type CreditoUncheckedCreateInput = {
    id?: number
    tipo: $Enums.Produto
    valor: number
    prestacao: number
    juro: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    devedor_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    solidario?: CreditoSolidarioUncheckedCreateNestedManyWithoutCreditoInput
  }

  export type CreditoUpdateInput = {
    tipo?: EnumProdutoFieldUpdateOperationsInput | $Enums.Produto
    valor?: FloatFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    juro?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solidario?: CreditoSolidarioUpdateManyWithoutCreditoNestedInput
    devedor?: DevedorUpdateOneRequiredWithoutCreditoNestedInput
  }

  export type CreditoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumProdutoFieldUpdateOperationsInput | $Enums.Produto
    valor?: FloatFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    juro?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    devedor_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solidario?: CreditoSolidarioUncheckedUpdateManyWithoutCreditoNestedInput
  }

  export type CreditoCreateManyInput = {
    id?: number
    tipo: $Enums.Produto
    valor: number
    prestacao: number
    juro: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    devedor_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditoUpdateManyMutationInput = {
    tipo?: EnumProdutoFieldUpdateOperationsInput | $Enums.Produto
    valor?: FloatFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    juro?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumProdutoFieldUpdateOperationsInput | $Enums.Produto
    valor?: FloatFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    juro?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    devedor_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmprestimoCreateInput = {
    valor: number
    juro_proponente: number
    taxa_investidor: number
    prestacao: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    createdAt?: Date | string
    updatedAt?: Date | string
    diversificacao?: DiversificacaoCreateNestedManyWithoutEmprestimoInput
    solidario?: EmprestimoSolidarioCreateNestedManyWithoutEmprestimoInput
    proponente: ProponenteCreateNestedOneWithoutEmprestimoInput
  }

  export type EmprestimoUncheckedCreateInput = {
    id?: number
    valor: number
    juro_proponente: number
    taxa_investidor: number
    prestacao: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    proponente_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    diversificacao?: DiversificacaoUncheckedCreateNestedManyWithoutEmprestimoInput
    solidario?: EmprestimoSolidarioUncheckedCreateNestedManyWithoutEmprestimoInput
  }

  export type EmprestimoUpdateInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    juro_proponente?: IntFieldUpdateOperationsInput | number
    taxa_investidor?: IntFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    diversificacao?: DiversificacaoUpdateManyWithoutEmprestimoNestedInput
    solidario?: EmprestimoSolidarioUpdateManyWithoutEmprestimoNestedInput
    proponente?: ProponenteUpdateOneRequiredWithoutEmprestimoNestedInput
  }

  export type EmprestimoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    juro_proponente?: IntFieldUpdateOperationsInput | number
    taxa_investidor?: IntFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    proponente_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    diversificacao?: DiversificacaoUncheckedUpdateManyWithoutEmprestimoNestedInput
    solidario?: EmprestimoSolidarioUncheckedUpdateManyWithoutEmprestimoNestedInput
  }

  export type EmprestimoCreateManyInput = {
    id?: number
    valor: number
    juro_proponente: number
    taxa_investidor: number
    prestacao: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    proponente_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmprestimoUpdateManyMutationInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    juro_proponente?: IntFieldUpdateOperationsInput | number
    taxa_investidor?: IntFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmprestimoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    juro_proponente?: IntFieldUpdateOperationsInput | number
    taxa_investidor?: IntFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    proponente_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmprestimoSolidarioCreateInput = {
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    solidario: SolidarioCreateNestedOneWithoutEmprestimoInput
    emprestimo: EmprestimoCreateNestedOneWithoutSolidarioInput
  }

  export type EmprestimoSolidarioUncheckedCreateInput = {
    estado?: boolean
    solidario_id: number
    emprestimo_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmprestimoSolidarioUpdateInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solidario?: SolidarioUpdateOneRequiredWithoutEmprestimoNestedInput
    emprestimo?: EmprestimoUpdateOneRequiredWithoutSolidarioNestedInput
  }

  export type EmprestimoSolidarioUncheckedUpdateInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    solidario_id?: IntFieldUpdateOperationsInput | number
    emprestimo_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmprestimoSolidarioCreateManyInput = {
    estado?: boolean
    solidario_id: number
    emprestimo_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmprestimoSolidarioUpdateManyMutationInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmprestimoSolidarioUncheckedUpdateManyInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    solidario_id?: IntFieldUpdateOperationsInput | number
    emprestimo_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditoSolidarioCreateInput = {
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    solidario: SolidarioCreateNestedOneWithoutCreditoInput
    credito: CreditoCreateNestedOneWithoutSolidarioInput
  }

  export type CreditoSolidarioUncheckedCreateInput = {
    estado?: boolean
    solidario_id: number
    credito_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditoSolidarioUpdateInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solidario?: SolidarioUpdateOneRequiredWithoutCreditoNestedInput
    credito?: CreditoUpdateOneRequiredWithoutSolidarioNestedInput
  }

  export type CreditoSolidarioUncheckedUpdateInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    solidario_id?: IntFieldUpdateOperationsInput | number
    credito_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditoSolidarioCreateManyInput = {
    estado?: boolean
    solidario_id: number
    credito_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditoSolidarioUpdateManyMutationInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditoSolidarioUncheckedUpdateManyInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    solidario_id?: IntFieldUpdateOperationsInput | number
    credito_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiversificacaoCreateInput = {
    estado?: boolean
    taxa: number
    protencao: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    investidor: InvestidorCreateNestedOneWithoutDiversificacaoInput
    emprestimo: EmprestimoCreateNestedOneWithoutDiversificacaoInput
  }

  export type DiversificacaoUncheckedCreateInput = {
    estado?: boolean
    investidor_id: number
    emprestimo_id: number
    taxa: number
    protencao: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiversificacaoUpdateInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    taxa?: IntFieldUpdateOperationsInput | number
    protencao?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investidor?: InvestidorUpdateOneRequiredWithoutDiversificacaoNestedInput
    emprestimo?: EmprestimoUpdateOneRequiredWithoutDiversificacaoNestedInput
  }

  export type DiversificacaoUncheckedUpdateInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    investidor_id?: IntFieldUpdateOperationsInput | number
    emprestimo_id?: IntFieldUpdateOperationsInput | number
    taxa?: IntFieldUpdateOperationsInput | number
    protencao?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiversificacaoCreateManyInput = {
    estado?: boolean
    investidor_id: number
    emprestimo_id: number
    taxa: number
    protencao: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiversificacaoUpdateManyMutationInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    taxa?: IntFieldUpdateOperationsInput | number
    protencao?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiversificacaoUncheckedUpdateManyInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    investidor_id?: IntFieldUpdateOperationsInput | number
    emprestimo_id?: IntFieldUpdateOperationsInput | number
    taxa?: IntFieldUpdateOperationsInput | number
    protencao?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaqueCreateInput = {
    valor: number
    taxa: number
    estado?: boolean
    pendencia: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSaqueInput
  }

  export type SaqueUncheckedCreateInput = {
    id?: number
    valor: number
    taxa: number
    estado?: boolean
    pendencia: boolean
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaqueUpdateInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSaqueNestedInput
  }

  export type SaqueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaqueCreateManyInput = {
    id?: number
    valor: number
    taxa: number
    estado?: boolean
    pendencia: boolean
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaqueUpdateManyMutationInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaqueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositoCreateInput = {
    valor: number
    estado?: boolean
    pendencia: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDepositoInput
  }

  export type DepositoUncheckedCreateInput = {
    id?: number
    valor: number
    estado?: boolean
    pendencia: boolean
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositoUpdateInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDepositoNestedInput
  }

  export type DepositoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositoCreateManyInput = {
    id?: number
    valor: number
    estado?: boolean
    pendencia: boolean
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositoUpdateManyMutationInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarteiraCreateInput = {
    saldo: number
    estado?: boolean
    numero: number
    codigo: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCarteiraInput
  }

  export type CarteiraUncheckedCreateInput = {
    id?: number
    saldo: number
    estado?: boolean
    numero: number
    codigo: number
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CarteiraUpdateInput = {
    saldo?: FloatFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    numero?: IntFieldUpdateOperationsInput | number
    codigo?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCarteiraNestedInput
  }

  export type CarteiraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    saldo?: FloatFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    numero?: IntFieldUpdateOperationsInput | number
    codigo?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarteiraCreateManyInput = {
    id?: number
    saldo: number
    estado?: boolean
    numero: number
    codigo: number
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CarteiraUpdateManyMutationInput = {
    saldo?: FloatFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    numero?: IntFieldUpdateOperationsInput | number
    codigo?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarteiraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    saldo?: FloatFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    numero?: IntFieldUpdateOperationsInput | number
    codigo?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoCreateInput = {
    valor: number
    detalhe: string
    prestacao: number
    estado?: boolean
    pendencia: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    devedor: DevedorCreateNestedOneWithoutPagamentoInput
  }

  export type PagamentoUncheckedCreateInput = {
    id?: number
    valor: number
    detalhe: string
    prestacao: number
    estado?: boolean
    pendencia: boolean
    devedor_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagamentoUpdateInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    detalhe?: StringFieldUpdateOperationsInput | string
    prestacao?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devedor?: DevedorUpdateOneRequiredWithoutPagamentoNestedInput
  }

  export type PagamentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    detalhe?: StringFieldUpdateOperationsInput | string
    prestacao?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    devedor_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoCreateManyInput = {
    id?: number
    valor: number
    detalhe: string
    prestacao: number
    estado?: boolean
    pendencia: boolean
    devedor_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagamentoUpdateManyMutationInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    detalhe?: StringFieldUpdateOperationsInput | string
    prestacao?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    detalhe?: StringFieldUpdateOperationsInput | string
    prestacao?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    devedor_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReembolsoCreateInput = {
    valor: number
    prestacao: number
    estado?: boolean
    detalhe: string
    createdAt?: Date | string
    updatedAt?: Date | string
    proponente: ProponenteCreateNestedOneWithoutReembolsoInput
  }

  export type ReembolsoUncheckedCreateInput = {
    id?: number
    valor: number
    prestacao: number
    estado?: boolean
    detalhe: string
    proponente_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReembolsoUpdateInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalhe?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proponente?: ProponenteUpdateOneRequiredWithoutReembolsoNestedInput
  }

  export type ReembolsoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalhe?: StringFieldUpdateOperationsInput | string
    proponente_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReembolsoCreateManyInput = {
    id?: number
    valor: number
    prestacao: number
    estado?: boolean
    detalhe: string
    proponente_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReembolsoUpdateManyMutationInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalhe?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReembolsoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalhe?: StringFieldUpdateOperationsInput | string
    proponente_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumGeneroFilter<$PrismaModel = never> = {
    equals?: $Enums.Genero | EnumGeneroFieldRefInput<$PrismaModel>
    in?: $Enums.Genero[]
    notIn?: $Enums.Genero[]
    not?: NestedEnumGeneroFilter<$PrismaModel> | $Enums.Genero
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PessoaNullableScalarRelationFilter = {
    is?: PessoaWhereInput | null
    isNot?: PessoaWhereInput | null
  }

  export type DocumentoListRelationFilter = {
    every?: DocumentoWhereInput
    some?: DocumentoWhereInput
    none?: DocumentoWhereInput
  }

  export type DevedorNullableScalarRelationFilter = {
    is?: DevedorWhereInput | null
    isNot?: DevedorWhereInput | null
  }

  export type InvestidorNullableScalarRelationFilter = {
    is?: InvestidorWhereInput | null
    isNot?: InvestidorWhereInput | null
  }

  export type ReclamacaoListRelationFilter = {
    every?: ReclamacaoWhereInput
    some?: ReclamacaoWhereInput
    none?: ReclamacaoWhereInput
  }

  export type ProponenteNullableScalarRelationFilter = {
    is?: ProponenteWhereInput | null
    isNot?: ProponenteWhereInput | null
  }

  export type SaqueListRelationFilter = {
    every?: SaqueWhereInput
    some?: SaqueWhereInput
    none?: SaqueWhereInput
  }

  export type DepositoListRelationFilter = {
    every?: DepositoWhereInput
    some?: DepositoWhereInput
    none?: DepositoWhereInput
  }

  export type CarteiraNullableScalarRelationFilter = {
    is?: CarteiraWhereInput | null
    isNot?: CarteiraWhereInput | null
  }

  export type PapelNullableScalarRelationFilter = {
    is?: PapelWhereInput | null
    isNot?: PapelWhereInput | null
  }

  export type SolidarioListRelationFilter = {
    every?: SolidarioWhereInput
    some?: SolidarioWhereInput
    none?: SolidarioWhereInput
  }

  export type DocumentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReclamacaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaqueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepositoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SolidarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    primeiro_nome?: SortOrder
    segundo_nome?: SortOrder
    password?: SortOrder
    genero?: SortOrder
    bilhete?: SortOrder
    telemovel?: SortOrder
    email?: SortOrder
    estado?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    primeiro_nome?: SortOrder
    segundo_nome?: SortOrder
    password?: SortOrder
    genero?: SortOrder
    bilhete?: SortOrder
    telemovel?: SortOrder
    email?: SortOrder
    estado?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    primeiro_nome?: SortOrder
    segundo_nome?: SortOrder
    password?: SortOrder
    genero?: SortOrder
    bilhete?: SortOrder
    telemovel?: SortOrder
    email?: SortOrder
    estado?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumGeneroWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Genero | EnumGeneroFieldRefInput<$PrismaModel>
    in?: $Enums.Genero[]
    notIn?: $Enums.Genero[]
    not?: NestedEnumGeneroWithAggregatesFilter<$PrismaModel> | $Enums.Genero
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGeneroFilter<$PrismaModel>
    _max?: NestedEnumGeneroFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumSectorFilter<$PrismaModel = never> = {
    equals?: $Enums.Sector | EnumSectorFieldRefInput<$PrismaModel>
    in?: $Enums.Sector[]
    notIn?: $Enums.Sector[]
    not?: NestedEnumSectorFilter<$PrismaModel> | $Enums.Sector
  }

  export type EnumAreaFilter<$PrismaModel = never> = {
    equals?: $Enums.Area | EnumAreaFieldRefInput<$PrismaModel>
    in?: $Enums.Area[]
    notIn?: $Enums.Area[]
    not?: NestedEnumAreaFilter<$PrismaModel> | $Enums.Area
  }

  export type PessoaListRelationFilter = {
    every?: PessoaWhereInput
    some?: PessoaWhereInput
    none?: PessoaWhereInput
  }

  export type PessoaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmpregoOrderByRelevanceInput = {
    fields: EmpregoOrderByRelevanceFieldEnum | EmpregoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmpregoCountOrderByAggregateInput = {
    id?: SortOrder
    data_inicio?: SortOrder
    sector?: SortOrder
    cargo?: SortOrder
    area?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmpregoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmpregoMaxOrderByAggregateInput = {
    id?: SortOrder
    data_inicio?: SortOrder
    sector?: SortOrder
    cargo?: SortOrder
    area?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmpregoMinOrderByAggregateInput = {
    id?: SortOrder
    data_inicio?: SortOrder
    sector?: SortOrder
    cargo?: SortOrder
    area?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmpregoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumSectorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sector | EnumSectorFieldRefInput<$PrismaModel>
    in?: $Enums.Sector[]
    notIn?: $Enums.Sector[]
    not?: NestedEnumSectorWithAggregatesFilter<$PrismaModel> | $Enums.Sector
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSectorFilter<$PrismaModel>
    _max?: NestedEnumSectorFilter<$PrismaModel>
  }

  export type EnumAreaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Area | EnumAreaFieldRefInput<$PrismaModel>
    in?: $Enums.Area[]
    notIn?: $Enums.Area[]
    not?: NestedEnumAreaWithAggregatesFilter<$PrismaModel> | $Enums.Area
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAreaFilter<$PrismaModel>
    _max?: NestedEnumAreaFilter<$PrismaModel>
  }

  export type EnumPropriedadeFilter<$PrismaModel = never> = {
    equals?: $Enums.Propriedade | EnumPropriedadeFieldRefInput<$PrismaModel>
    in?: $Enums.Propriedade[]
    notIn?: $Enums.Propriedade[]
    not?: NestedEnumPropriedadeFilter<$PrismaModel> | $Enums.Propriedade
  }

  export type ResidenciaCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    data_inicio?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResidenciaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ResidenciaMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    data_inicio?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResidenciaMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    data_inicio?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResidenciaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumPropriedadeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Propriedade | EnumPropriedadeFieldRefInput<$PrismaModel>
    in?: $Enums.Propriedade[]
    notIn?: $Enums.Propriedade[]
    not?: NestedEnumPropriedadeWithAggregatesFilter<$PrismaModel> | $Enums.Propriedade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropriedadeFilter<$PrismaModel>
    _max?: NestedEnumPropriedadeFilter<$PrismaModel>
  }

  export type EnumPerfilFilter<$PrismaModel = never> = {
    equals?: $Enums.Perfil | EnumPerfilFieldRefInput<$PrismaModel>
    in?: $Enums.Perfil[]
    notIn?: $Enums.Perfil[]
    not?: NestedEnumPerfilFilter<$PrismaModel> | $Enums.Perfil
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PapelCountOrderByAggregateInput = {
    id?: SortOrder
    perfil?: SortOrder
    user_id?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PapelAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type PapelMaxOrderByAggregateInput = {
    id?: SortOrder
    perfil?: SortOrder
    user_id?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PapelMinOrderByAggregateInput = {
    id?: SortOrder
    perfil?: SortOrder
    user_id?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PapelSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumPerfilWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Perfil | EnumPerfilFieldRefInput<$PrismaModel>
    in?: $Enums.Perfil[]
    notIn?: $Enums.Perfil[]
    not?: NestedEnumPerfilWithAggregatesFilter<$PrismaModel> | $Enums.Perfil
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPerfilFilter<$PrismaModel>
    _max?: NestedEnumPerfilFilter<$PrismaModel>
  }

  export type EnumEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[]
    notIn?: $Enums.Estado[]
    not?: NestedEnumEstadoFilter<$PrismaModel> | $Enums.Estado
  }

  export type EmpregoScalarRelationFilter = {
    is?: EmpregoWhereInput
    isNot?: EmpregoWhereInput
  }

  export type ResidenciaScalarRelationFilter = {
    is?: ResidenciaWhereInput
    isNot?: ResidenciaWhereInput
  }

  export type ConjugueNullableScalarRelationFilter = {
    is?: ConjugueWhereInput | null
    isNot?: ConjugueWhereInput | null
  }

  export type SolidarioNullableScalarRelationFilter = {
    is?: SolidarioWhereInput | null
    isNot?: SolidarioWhereInput | null
  }

  export type ContaNullableScalarRelationFilter = {
    is?: ContaWhereInput | null
    isNot?: ContaWhereInput | null
  }

  export type PessoaOrderByRelevanceInput = {
    fields: PessoaOrderByRelevanceFieldEnum | PessoaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PessoaCountOrderByAggregateInput = {
    id?: SortOrder
    estado_civil?: SortOrder
    provincia?: SortOrder
    municipio?: SortOrder
    profissao?: SortOrder
    estado?: SortOrder
    nivel_instrucao?: SortOrder
    data_nascimento?: SortOrder
    user_id?: SortOrder
    emprego_id?: SortOrder
    residencia_id?: SortOrder
  }

  export type PessoaAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    emprego_id?: SortOrder
    residencia_id?: SortOrder
  }

  export type PessoaMaxOrderByAggregateInput = {
    id?: SortOrder
    estado_civil?: SortOrder
    provincia?: SortOrder
    municipio?: SortOrder
    profissao?: SortOrder
    estado?: SortOrder
    nivel_instrucao?: SortOrder
    data_nascimento?: SortOrder
    user_id?: SortOrder
    emprego_id?: SortOrder
    residencia_id?: SortOrder
  }

  export type PessoaMinOrderByAggregateInput = {
    id?: SortOrder
    estado_civil?: SortOrder
    provincia?: SortOrder
    municipio?: SortOrder
    profissao?: SortOrder
    estado?: SortOrder
    nivel_instrucao?: SortOrder
    data_nascimento?: SortOrder
    user_id?: SortOrder
    emprego_id?: SortOrder
    residencia_id?: SortOrder
  }

  export type PessoaSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    emprego_id?: SortOrder
    residencia_id?: SortOrder
  }

  export type EnumEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[]
    notIn?: $Enums.Estado[]
    not?: NestedEnumEstadoWithAggregatesFilter<$PrismaModel> | $Enums.Estado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoFilter<$PrismaModel>
    _max?: NestedEnumEstadoFilter<$PrismaModel>
  }

  export type PessoaScalarRelationFilter = {
    is?: PessoaWhereInput
    isNot?: PessoaWhereInput
  }

  export type ContaOrderByRelevanceInput = {
    fields: ContaOrderByRelevanceFieldEnum | ContaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    salario?: SortOrder
    iban?: SortOrder
    estado?: SortOrder
    pessoa_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContaAvgOrderByAggregateInput = {
    id?: SortOrder
    salario?: SortOrder
    pessoa_id?: SortOrder
  }

  export type ContaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    salario?: SortOrder
    iban?: SortOrder
    estado?: SortOrder
    pessoa_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    salario?: SortOrder
    iban?: SortOrder
    estado?: SortOrder
    pessoa_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContaSumOrderByAggregateInput = {
    id?: SortOrder
    salario?: SortOrder
    pessoa_id?: SortOrder
  }

  export type ConjugueOrderByRelevanceInput = {
    fields: ConjugueOrderByRelevanceFieldEnum | ConjugueOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ConjugueCountOrderByAggregateInput = {
    id?: SortOrder
    nome_completo?: SortOrder
    dependentes?: SortOrder
    nivel_instrucao?: SortOrder
    estado?: SortOrder
    data_nascimento?: SortOrder
    pessoa_id?: SortOrder
  }

  export type ConjugueAvgOrderByAggregateInput = {
    id?: SortOrder
    dependentes?: SortOrder
    pessoa_id?: SortOrder
  }

  export type ConjugueMaxOrderByAggregateInput = {
    id?: SortOrder
    nome_completo?: SortOrder
    dependentes?: SortOrder
    nivel_instrucao?: SortOrder
    estado?: SortOrder
    data_nascimento?: SortOrder
    pessoa_id?: SortOrder
  }

  export type ConjugueMinOrderByAggregateInput = {
    id?: SortOrder
    nome_completo?: SortOrder
    dependentes?: SortOrder
    nivel_instrucao?: SortOrder
    estado?: SortOrder
    data_nascimento?: SortOrder
    pessoa_id?: SortOrder
  }

  export type ConjugueSumOrderByAggregateInput = {
    id?: SortOrder
    dependentes?: SortOrder
    pessoa_id?: SortOrder
  }

  export type EnumComprovativoFilter<$PrismaModel = never> = {
    equals?: $Enums.Comprovativo | EnumComprovativoFieldRefInput<$PrismaModel>
    in?: $Enums.Comprovativo[]
    notIn?: $Enums.Comprovativo[]
    not?: NestedEnumComprovativoFilter<$PrismaModel> | $Enums.Comprovativo
  }

  export type DocumentoOrderByRelevanceInput = {
    fields: DocumentoOrderByRelevanceFieldEnum | DocumentoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DocumentoCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    extensao?: SortOrder
    tamanho?: SortOrder
    nome_original?: SortOrder
    nome_salvado?: SortOrder
    estado?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentoAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type DocumentoMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    extensao?: SortOrder
    tamanho?: SortOrder
    nome_original?: SortOrder
    nome_salvado?: SortOrder
    estado?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentoMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    extensao?: SortOrder
    tamanho?: SortOrder
    nome_original?: SortOrder
    nome_salvado?: SortOrder
    estado?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentoSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumComprovativoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Comprovativo | EnumComprovativoFieldRefInput<$PrismaModel>
    in?: $Enums.Comprovativo[]
    notIn?: $Enums.Comprovativo[]
    not?: NestedEnumComprovativoWithAggregatesFilter<$PrismaModel> | $Enums.Comprovativo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComprovativoFilter<$PrismaModel>
    _max?: NestedEnumComprovativoFilter<$PrismaModel>
  }

  export type CreditoListRelationFilter = {
    every?: CreditoWhereInput
    some?: CreditoWhereInput
    none?: CreditoWhereInput
  }

  export type MovelListRelationFilter = {
    every?: MovelWhereInput
    some?: MovelWhereInput
    none?: MovelWhereInput
  }

  export type PagamentoListRelationFilter = {
    every?: PagamentoWhereInput
    some?: PagamentoWhereInput
    none?: PagamentoWhereInput
  }

  export type CreditoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PagamentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DevedorCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    solicitacao?: SortOrder
    adimplencia?: SortOrder
    inadimplencia?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DevedorAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    solicitacao?: SortOrder
    adimplencia?: SortOrder
    inadimplencia?: SortOrder
  }

  export type DevedorMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    solicitacao?: SortOrder
    adimplencia?: SortOrder
    inadimplencia?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DevedorMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    solicitacao?: SortOrder
    adimplencia?: SortOrder
    inadimplencia?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DevedorSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    solicitacao?: SortOrder
    adimplencia?: SortOrder
    inadimplencia?: SortOrder
  }

  export type DiversificacaoListRelationFilter = {
    every?: DiversificacaoWhereInput
    some?: DiversificacaoWhereInput
    none?: DiversificacaoWhereInput
  }

  export type DiversificacaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvestidorCountOrderByAggregateInput = {
    id?: SortOrder
    maior_risco?: SortOrder
    maior_seguranca?: SortOrder
    saque_antecipado?: SortOrder
    fundo_protegido?: SortOrder
    estado?: SortOrder
    partilhar_emprestimo?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestidorAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type InvestidorMaxOrderByAggregateInput = {
    id?: SortOrder
    maior_risco?: SortOrder
    maior_seguranca?: SortOrder
    saque_antecipado?: SortOrder
    fundo_protegido?: SortOrder
    estado?: SortOrder
    partilhar_emprestimo?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestidorMinOrderByAggregateInput = {
    id?: SortOrder
    maior_risco?: SortOrder
    maior_seguranca?: SortOrder
    saque_antecipado?: SortOrder
    fundo_protegido?: SortOrder
    estado?: SortOrder
    partilhar_emprestimo?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestidorSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type ReclamacaoOrderByRelevanceInput = {
    fields: ReclamacaoOrderByRelevanceFieldEnum | ReclamacaoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReclamacaoCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    estado?: SortOrder
    assunto?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReclamacaoAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type ReclamacaoMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    estado?: SortOrder
    assunto?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReclamacaoMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    estado?: SortOrder
    assunto?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReclamacaoSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type EmprestimoListRelationFilter = {
    every?: EmprestimoWhereInput
    some?: EmprestimoWhereInput
    none?: EmprestimoWhereInput
  }

  export type ReembolsoListRelationFilter = {
    every?: ReembolsoWhereInput
    some?: ReembolsoWhereInput
    none?: ReembolsoWhereInput
  }

  export type EmprestimoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReembolsoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProponenteCountOrderByAggregateInput = {
    id?: SortOrder
    solicitacao?: SortOrder
    reembolsar?: SortOrder
    satisfeitos?: SortOrder
    insatisfeitos?: SortOrder
    estado?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProponenteAvgOrderByAggregateInput = {
    id?: SortOrder
    solicitacao?: SortOrder
    reembolsar?: SortOrder
    satisfeitos?: SortOrder
    insatisfeitos?: SortOrder
    user_id?: SortOrder
  }

  export type ProponenteMaxOrderByAggregateInput = {
    id?: SortOrder
    solicitacao?: SortOrder
    reembolsar?: SortOrder
    satisfeitos?: SortOrder
    insatisfeitos?: SortOrder
    estado?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProponenteMinOrderByAggregateInput = {
    id?: SortOrder
    solicitacao?: SortOrder
    reembolsar?: SortOrder
    satisfeitos?: SortOrder
    insatisfeitos?: SortOrder
    estado?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProponenteSumOrderByAggregateInput = {
    id?: SortOrder
    solicitacao?: SortOrder
    reembolsar?: SortOrder
    satisfeitos?: SortOrder
    insatisfeitos?: SortOrder
    user_id?: SortOrder
  }

  export type EnumAvalFilter<$PrismaModel = never> = {
    equals?: $Enums.Aval | EnumAvalFieldRefInput<$PrismaModel>
    in?: $Enums.Aval[]
    notIn?: $Enums.Aval[]
    not?: NestedEnumAvalFilter<$PrismaModel> | $Enums.Aval
  }

  export type EnumParentescoFilter<$PrismaModel = never> = {
    equals?: $Enums.Parentesco | EnumParentescoFieldRefInput<$PrismaModel>
    in?: $Enums.Parentesco[]
    notIn?: $Enums.Parentesco[]
    not?: NestedEnumParentescoFilter<$PrismaModel> | $Enums.Parentesco
  }

  export type EmprestimoSolidarioListRelationFilter = {
    every?: EmprestimoSolidarioWhereInput
    some?: EmprestimoSolidarioWhereInput
    none?: EmprestimoSolidarioWhereInput
  }

  export type CreditoSolidarioListRelationFilter = {
    every?: CreditoSolidarioWhereInput
    some?: CreditoSolidarioWhereInput
    none?: CreditoSolidarioWhereInput
  }

  export type EmprestimoSolidarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditoSolidarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SolidarioCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    parentesco?: SortOrder
    taxa?: SortOrder
    estado?: SortOrder
    pessoa_id?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SolidarioAvgOrderByAggregateInput = {
    id?: SortOrder
    taxa?: SortOrder
    pessoa_id?: SortOrder
    user_id?: SortOrder
  }

  export type SolidarioMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    parentesco?: SortOrder
    taxa?: SortOrder
    estado?: SortOrder
    pessoa_id?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SolidarioMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    parentesco?: SortOrder
    taxa?: SortOrder
    estado?: SortOrder
    pessoa_id?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SolidarioSumOrderByAggregateInput = {
    id?: SortOrder
    taxa?: SortOrder
    pessoa_id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumAvalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Aval | EnumAvalFieldRefInput<$PrismaModel>
    in?: $Enums.Aval[]
    notIn?: $Enums.Aval[]
    not?: NestedEnumAvalWithAggregatesFilter<$PrismaModel> | $Enums.Aval
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAvalFilter<$PrismaModel>
    _max?: NestedEnumAvalFilter<$PrismaModel>
  }

  export type EnumParentescoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Parentesco | EnumParentescoFieldRefInput<$PrismaModel>
    in?: $Enums.Parentesco[]
    notIn?: $Enums.Parentesco[]
    not?: NestedEnumParentescoWithAggregatesFilter<$PrismaModel> | $Enums.Parentesco
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParentescoFilter<$PrismaModel>
    _max?: NestedEnumParentescoFilter<$PrismaModel>
  }

  export type EnumModeloFilter<$PrismaModel = never> = {
    equals?: $Enums.Modelo | EnumModeloFieldRefInput<$PrismaModel>
    in?: $Enums.Modelo[]
    notIn?: $Enums.Modelo[]
    not?: NestedEnumModeloFilter<$PrismaModel> | $Enums.Modelo
  }

  export type DevedorScalarRelationFilter = {
    is?: DevedorWhereInput
    isNot?: DevedorWhereInput
  }

  export type MovelOrderByRelevanceInput = {
    fields: MovelOrderByRelevanceFieldEnum | MovelOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MovelCountOrderByAggregateInput = {
    id?: SortOrder
    modelo?: SortOrder
    matricula?: SortOrder
    detalhes?: SortOrder
    devedor_id?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovelAvgOrderByAggregateInput = {
    id?: SortOrder
    devedor_id?: SortOrder
  }

  export type MovelMaxOrderByAggregateInput = {
    id?: SortOrder
    modelo?: SortOrder
    matricula?: SortOrder
    detalhes?: SortOrder
    devedor_id?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovelMinOrderByAggregateInput = {
    id?: SortOrder
    modelo?: SortOrder
    matricula?: SortOrder
    detalhes?: SortOrder
    devedor_id?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovelSumOrderByAggregateInput = {
    id?: SortOrder
    devedor_id?: SortOrder
  }

  export type EnumModeloWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Modelo | EnumModeloFieldRefInput<$PrismaModel>
    in?: $Enums.Modelo[]
    notIn?: $Enums.Modelo[]
    not?: NestedEnumModeloWithAggregatesFilter<$PrismaModel> | $Enums.Modelo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModeloFilter<$PrismaModel>
    _max?: NestedEnumModeloFilter<$PrismaModel>
  }

  export type EnumProdutoFilter<$PrismaModel = never> = {
    equals?: $Enums.Produto | EnumProdutoFieldRefInput<$PrismaModel>
    in?: $Enums.Produto[]
    notIn?: $Enums.Produto[]
    not?: NestedEnumProdutoFilter<$PrismaModel> | $Enums.Produto
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumProgressoFilter<$PrismaModel = never> = {
    equals?: $Enums.Progresso | EnumProgressoFieldRefInput<$PrismaModel>
    in?: $Enums.Progresso[]
    notIn?: $Enums.Progresso[]
    not?: NestedEnumProgressoFilter<$PrismaModel> | $Enums.Progresso
  }

  export type CreditoCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    prestacao?: SortOrder
    juro?: SortOrder
    termino?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    progresso?: SortOrder
    devedor_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreditoAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    prestacao?: SortOrder
    juro?: SortOrder
    devedor_id?: SortOrder
  }

  export type CreditoMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    prestacao?: SortOrder
    juro?: SortOrder
    termino?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    progresso?: SortOrder
    devedor_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreditoMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    prestacao?: SortOrder
    juro?: SortOrder
    termino?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    progresso?: SortOrder
    devedor_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreditoSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    prestacao?: SortOrder
    juro?: SortOrder
    devedor_id?: SortOrder
  }

  export type EnumProdutoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Produto | EnumProdutoFieldRefInput<$PrismaModel>
    in?: $Enums.Produto[]
    notIn?: $Enums.Produto[]
    not?: NestedEnumProdutoWithAggregatesFilter<$PrismaModel> | $Enums.Produto
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProdutoFilter<$PrismaModel>
    _max?: NestedEnumProdutoFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumProgressoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Progresso | EnumProgressoFieldRefInput<$PrismaModel>
    in?: $Enums.Progresso[]
    notIn?: $Enums.Progresso[]
    not?: NestedEnumProgressoWithAggregatesFilter<$PrismaModel> | $Enums.Progresso
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProgressoFilter<$PrismaModel>
    _max?: NestedEnumProgressoFilter<$PrismaModel>
  }

  export type ProponenteScalarRelationFilter = {
    is?: ProponenteWhereInput
    isNot?: ProponenteWhereInput
  }

  export type EmprestimoCountOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    juro_proponente?: SortOrder
    taxa_investidor?: SortOrder
    prestacao?: SortOrder
    termino?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    progresso?: SortOrder
    proponente_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmprestimoAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    juro_proponente?: SortOrder
    taxa_investidor?: SortOrder
    prestacao?: SortOrder
    proponente_id?: SortOrder
  }

  export type EmprestimoMaxOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    juro_proponente?: SortOrder
    taxa_investidor?: SortOrder
    prestacao?: SortOrder
    termino?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    progresso?: SortOrder
    proponente_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmprestimoMinOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    juro_proponente?: SortOrder
    taxa_investidor?: SortOrder
    prestacao?: SortOrder
    termino?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    progresso?: SortOrder
    proponente_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmprestimoSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    juro_proponente?: SortOrder
    taxa_investidor?: SortOrder
    prestacao?: SortOrder
    proponente_id?: SortOrder
  }

  export type SolidarioScalarRelationFilter = {
    is?: SolidarioWhereInput
    isNot?: SolidarioWhereInput
  }

  export type EmprestimoScalarRelationFilter = {
    is?: EmprestimoWhereInput
    isNot?: EmprestimoWhereInput
  }

  export type EmprestimoSolidarioSolidario_idEmprestimo_idCompoundUniqueInput = {
    solidario_id: number
    emprestimo_id: number
  }

  export type EmprestimoSolidarioCountOrderByAggregateInput = {
    estado?: SortOrder
    solidario_id?: SortOrder
    emprestimo_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmprestimoSolidarioAvgOrderByAggregateInput = {
    solidario_id?: SortOrder
    emprestimo_id?: SortOrder
  }

  export type EmprestimoSolidarioMaxOrderByAggregateInput = {
    estado?: SortOrder
    solidario_id?: SortOrder
    emprestimo_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmprestimoSolidarioMinOrderByAggregateInput = {
    estado?: SortOrder
    solidario_id?: SortOrder
    emprestimo_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmprestimoSolidarioSumOrderByAggregateInput = {
    solidario_id?: SortOrder
    emprestimo_id?: SortOrder
  }

  export type CreditoScalarRelationFilter = {
    is?: CreditoWhereInput
    isNot?: CreditoWhereInput
  }

  export type CreditoSolidarioSolidario_idCredito_idCompoundUniqueInput = {
    solidario_id: number
    credito_id: number
  }

  export type CreditoSolidarioCountOrderByAggregateInput = {
    estado?: SortOrder
    solidario_id?: SortOrder
    credito_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreditoSolidarioAvgOrderByAggregateInput = {
    solidario_id?: SortOrder
    credito_id?: SortOrder
  }

  export type CreditoSolidarioMaxOrderByAggregateInput = {
    estado?: SortOrder
    solidario_id?: SortOrder
    credito_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreditoSolidarioMinOrderByAggregateInput = {
    estado?: SortOrder
    solidario_id?: SortOrder
    credito_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreditoSolidarioSumOrderByAggregateInput = {
    solidario_id?: SortOrder
    credito_id?: SortOrder
  }

  export type InvestidorScalarRelationFilter = {
    is?: InvestidorWhereInput
    isNot?: InvestidorWhereInput
  }

  export type DiversificacaoInvestidor_idEmprestimo_idCompoundUniqueInput = {
    investidor_id: number
    emprestimo_id: number
  }

  export type DiversificacaoCountOrderByAggregateInput = {
    estado?: SortOrder
    investidor_id?: SortOrder
    emprestimo_id?: SortOrder
    taxa?: SortOrder
    protencao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiversificacaoAvgOrderByAggregateInput = {
    investidor_id?: SortOrder
    emprestimo_id?: SortOrder
    taxa?: SortOrder
  }

  export type DiversificacaoMaxOrderByAggregateInput = {
    estado?: SortOrder
    investidor_id?: SortOrder
    emprestimo_id?: SortOrder
    taxa?: SortOrder
    protencao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiversificacaoMinOrderByAggregateInput = {
    estado?: SortOrder
    investidor_id?: SortOrder
    emprestimo_id?: SortOrder
    taxa?: SortOrder
    protencao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiversificacaoSumOrderByAggregateInput = {
    investidor_id?: SortOrder
    emprestimo_id?: SortOrder
    taxa?: SortOrder
  }

  export type SaqueCountOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    taxa?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaqueAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    taxa?: SortOrder
    user_id?: SortOrder
  }

  export type SaqueMaxOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    taxa?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaqueMinOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    taxa?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaqueSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    taxa?: SortOrder
    user_id?: SortOrder
  }

  export type DepositoCountOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepositoAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    user_id?: SortOrder
  }

  export type DepositoMaxOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepositoMinOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepositoSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    user_id?: SortOrder
  }

  export type CarteiraCountOrderByAggregateInput = {
    id?: SortOrder
    saldo?: SortOrder
    estado?: SortOrder
    numero?: SortOrder
    codigo?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CarteiraAvgOrderByAggregateInput = {
    id?: SortOrder
    saldo?: SortOrder
    numero?: SortOrder
    codigo?: SortOrder
    user_id?: SortOrder
  }

  export type CarteiraMaxOrderByAggregateInput = {
    id?: SortOrder
    saldo?: SortOrder
    estado?: SortOrder
    numero?: SortOrder
    codigo?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CarteiraMinOrderByAggregateInput = {
    id?: SortOrder
    saldo?: SortOrder
    estado?: SortOrder
    numero?: SortOrder
    codigo?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CarteiraSumOrderByAggregateInput = {
    id?: SortOrder
    saldo?: SortOrder
    numero?: SortOrder
    codigo?: SortOrder
    user_id?: SortOrder
  }

  export type PagamentoOrderByRelevanceInput = {
    fields: PagamentoOrderByRelevanceFieldEnum | PagamentoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PagamentoCountOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    detalhe?: SortOrder
    prestacao?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    devedor_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PagamentoAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    prestacao?: SortOrder
    devedor_id?: SortOrder
  }

  export type PagamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    detalhe?: SortOrder
    prestacao?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    devedor_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PagamentoMinOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    detalhe?: SortOrder
    prestacao?: SortOrder
    estado?: SortOrder
    pendencia?: SortOrder
    devedor_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PagamentoSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    prestacao?: SortOrder
    devedor_id?: SortOrder
  }

  export type ReembolsoOrderByRelevanceInput = {
    fields: ReembolsoOrderByRelevanceFieldEnum | ReembolsoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReembolsoCountOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    prestacao?: SortOrder
    estado?: SortOrder
    detalhe?: SortOrder
    proponente_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReembolsoAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    prestacao?: SortOrder
    proponente_id?: SortOrder
  }

  export type ReembolsoMaxOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    prestacao?: SortOrder
    estado?: SortOrder
    detalhe?: SortOrder
    proponente_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReembolsoMinOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    prestacao?: SortOrder
    estado?: SortOrder
    detalhe?: SortOrder
    proponente_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReembolsoSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    prestacao?: SortOrder
    proponente_id?: SortOrder
  }

  export type PessoaCreateNestedOneWithoutUserInput = {
    create?: XOR<PessoaCreateWithoutUserInput, PessoaUncheckedCreateWithoutUserInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutUserInput
    connect?: PessoaWhereUniqueInput
  }

  export type DocumentoCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentoCreateWithoutUserInput, DocumentoUncheckedCreateWithoutUserInput> | DocumentoCreateWithoutUserInput[] | DocumentoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutUserInput | DocumentoCreateOrConnectWithoutUserInput[]
    createMany?: DocumentoCreateManyUserInputEnvelope
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
  }

  export type DevedorCreateNestedOneWithoutUserInput = {
    create?: XOR<DevedorCreateWithoutUserInput, DevedorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DevedorCreateOrConnectWithoutUserInput
    connect?: DevedorWhereUniqueInput
  }

  export type InvestidorCreateNestedOneWithoutUserInput = {
    create?: XOR<InvestidorCreateWithoutUserInput, InvestidorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestidorCreateOrConnectWithoutUserInput
    connect?: InvestidorWhereUniqueInput
  }

  export type ReclamacaoCreateNestedManyWithoutUserInput = {
    create?: XOR<ReclamacaoCreateWithoutUserInput, ReclamacaoUncheckedCreateWithoutUserInput> | ReclamacaoCreateWithoutUserInput[] | ReclamacaoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReclamacaoCreateOrConnectWithoutUserInput | ReclamacaoCreateOrConnectWithoutUserInput[]
    createMany?: ReclamacaoCreateManyUserInputEnvelope
    connect?: ReclamacaoWhereUniqueInput | ReclamacaoWhereUniqueInput[]
  }

  export type ProponenteCreateNestedOneWithoutUserInput = {
    create?: XOR<ProponenteCreateWithoutUserInput, ProponenteUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProponenteCreateOrConnectWithoutUserInput
    connect?: ProponenteWhereUniqueInput
  }

  export type SaqueCreateNestedManyWithoutUserInput = {
    create?: XOR<SaqueCreateWithoutUserInput, SaqueUncheckedCreateWithoutUserInput> | SaqueCreateWithoutUserInput[] | SaqueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SaqueCreateOrConnectWithoutUserInput | SaqueCreateOrConnectWithoutUserInput[]
    createMany?: SaqueCreateManyUserInputEnvelope
    connect?: SaqueWhereUniqueInput | SaqueWhereUniqueInput[]
  }

  export type DepositoCreateNestedManyWithoutUserInput = {
    create?: XOR<DepositoCreateWithoutUserInput, DepositoUncheckedCreateWithoutUserInput> | DepositoCreateWithoutUserInput[] | DepositoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepositoCreateOrConnectWithoutUserInput | DepositoCreateOrConnectWithoutUserInput[]
    createMany?: DepositoCreateManyUserInputEnvelope
    connect?: DepositoWhereUniqueInput | DepositoWhereUniqueInput[]
  }

  export type CarteiraCreateNestedOneWithoutUserInput = {
    create?: XOR<CarteiraCreateWithoutUserInput, CarteiraUncheckedCreateWithoutUserInput>
    connectOrCreate?: CarteiraCreateOrConnectWithoutUserInput
    connect?: CarteiraWhereUniqueInput
  }

  export type PapelCreateNestedOneWithoutUserInput = {
    create?: XOR<PapelCreateWithoutUserInput, PapelUncheckedCreateWithoutUserInput>
    connectOrCreate?: PapelCreateOrConnectWithoutUserInput
    connect?: PapelWhereUniqueInput
  }

  export type SolidarioCreateNestedManyWithoutUserInput = {
    create?: XOR<SolidarioCreateWithoutUserInput, SolidarioUncheckedCreateWithoutUserInput> | SolidarioCreateWithoutUserInput[] | SolidarioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SolidarioCreateOrConnectWithoutUserInput | SolidarioCreateOrConnectWithoutUserInput[]
    createMany?: SolidarioCreateManyUserInputEnvelope
    connect?: SolidarioWhereUniqueInput | SolidarioWhereUniqueInput[]
  }

  export type PessoaUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PessoaCreateWithoutUserInput, PessoaUncheckedCreateWithoutUserInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutUserInput
    connect?: PessoaWhereUniqueInput
  }

  export type DocumentoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentoCreateWithoutUserInput, DocumentoUncheckedCreateWithoutUserInput> | DocumentoCreateWithoutUserInput[] | DocumentoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutUserInput | DocumentoCreateOrConnectWithoutUserInput[]
    createMany?: DocumentoCreateManyUserInputEnvelope
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
  }

  export type DevedorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DevedorCreateWithoutUserInput, DevedorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DevedorCreateOrConnectWithoutUserInput
    connect?: DevedorWhereUniqueInput
  }

  export type InvestidorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<InvestidorCreateWithoutUserInput, InvestidorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestidorCreateOrConnectWithoutUserInput
    connect?: InvestidorWhereUniqueInput
  }

  export type ReclamacaoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReclamacaoCreateWithoutUserInput, ReclamacaoUncheckedCreateWithoutUserInput> | ReclamacaoCreateWithoutUserInput[] | ReclamacaoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReclamacaoCreateOrConnectWithoutUserInput | ReclamacaoCreateOrConnectWithoutUserInput[]
    createMany?: ReclamacaoCreateManyUserInputEnvelope
    connect?: ReclamacaoWhereUniqueInput | ReclamacaoWhereUniqueInput[]
  }

  export type ProponenteUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProponenteCreateWithoutUserInput, ProponenteUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProponenteCreateOrConnectWithoutUserInput
    connect?: ProponenteWhereUniqueInput
  }

  export type SaqueUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SaqueCreateWithoutUserInput, SaqueUncheckedCreateWithoutUserInput> | SaqueCreateWithoutUserInput[] | SaqueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SaqueCreateOrConnectWithoutUserInput | SaqueCreateOrConnectWithoutUserInput[]
    createMany?: SaqueCreateManyUserInputEnvelope
    connect?: SaqueWhereUniqueInput | SaqueWhereUniqueInput[]
  }

  export type DepositoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DepositoCreateWithoutUserInput, DepositoUncheckedCreateWithoutUserInput> | DepositoCreateWithoutUserInput[] | DepositoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepositoCreateOrConnectWithoutUserInput | DepositoCreateOrConnectWithoutUserInput[]
    createMany?: DepositoCreateManyUserInputEnvelope
    connect?: DepositoWhereUniqueInput | DepositoWhereUniqueInput[]
  }

  export type CarteiraUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CarteiraCreateWithoutUserInput, CarteiraUncheckedCreateWithoutUserInput>
    connectOrCreate?: CarteiraCreateOrConnectWithoutUserInput
    connect?: CarteiraWhereUniqueInput
  }

  export type PapelUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PapelCreateWithoutUserInput, PapelUncheckedCreateWithoutUserInput>
    connectOrCreate?: PapelCreateOrConnectWithoutUserInput
    connect?: PapelWhereUniqueInput
  }

  export type SolidarioUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SolidarioCreateWithoutUserInput, SolidarioUncheckedCreateWithoutUserInput> | SolidarioCreateWithoutUserInput[] | SolidarioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SolidarioCreateOrConnectWithoutUserInput | SolidarioCreateOrConnectWithoutUserInput[]
    createMany?: SolidarioCreateManyUserInputEnvelope
    connect?: SolidarioWhereUniqueInput | SolidarioWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumGeneroFieldUpdateOperationsInput = {
    set?: $Enums.Genero
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PessoaUpdateOneWithoutUserNestedInput = {
    create?: XOR<PessoaCreateWithoutUserInput, PessoaUncheckedCreateWithoutUserInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutUserInput
    upsert?: PessoaUpsertWithoutUserInput
    disconnect?: PessoaWhereInput | boolean
    delete?: PessoaWhereInput | boolean
    connect?: PessoaWhereUniqueInput
    update?: XOR<XOR<PessoaUpdateToOneWithWhereWithoutUserInput, PessoaUpdateWithoutUserInput>, PessoaUncheckedUpdateWithoutUserInput>
  }

  export type DocumentoUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentoCreateWithoutUserInput, DocumentoUncheckedCreateWithoutUserInput> | DocumentoCreateWithoutUserInput[] | DocumentoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutUserInput | DocumentoCreateOrConnectWithoutUserInput[]
    upsert?: DocumentoUpsertWithWhereUniqueWithoutUserInput | DocumentoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentoCreateManyUserInputEnvelope
    set?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    disconnect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    delete?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    update?: DocumentoUpdateWithWhereUniqueWithoutUserInput | DocumentoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentoUpdateManyWithWhereWithoutUserInput | DocumentoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
  }

  export type DevedorUpdateOneWithoutUserNestedInput = {
    create?: XOR<DevedorCreateWithoutUserInput, DevedorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DevedorCreateOrConnectWithoutUserInput
    upsert?: DevedorUpsertWithoutUserInput
    disconnect?: DevedorWhereInput | boolean
    delete?: DevedorWhereInput | boolean
    connect?: DevedorWhereUniqueInput
    update?: XOR<XOR<DevedorUpdateToOneWithWhereWithoutUserInput, DevedorUpdateWithoutUserInput>, DevedorUncheckedUpdateWithoutUserInput>
  }

  export type InvestidorUpdateOneWithoutUserNestedInput = {
    create?: XOR<InvestidorCreateWithoutUserInput, InvestidorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestidorCreateOrConnectWithoutUserInput
    upsert?: InvestidorUpsertWithoutUserInput
    disconnect?: InvestidorWhereInput | boolean
    delete?: InvestidorWhereInput | boolean
    connect?: InvestidorWhereUniqueInput
    update?: XOR<XOR<InvestidorUpdateToOneWithWhereWithoutUserInput, InvestidorUpdateWithoutUserInput>, InvestidorUncheckedUpdateWithoutUserInput>
  }

  export type ReclamacaoUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReclamacaoCreateWithoutUserInput, ReclamacaoUncheckedCreateWithoutUserInput> | ReclamacaoCreateWithoutUserInput[] | ReclamacaoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReclamacaoCreateOrConnectWithoutUserInput | ReclamacaoCreateOrConnectWithoutUserInput[]
    upsert?: ReclamacaoUpsertWithWhereUniqueWithoutUserInput | ReclamacaoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReclamacaoCreateManyUserInputEnvelope
    set?: ReclamacaoWhereUniqueInput | ReclamacaoWhereUniqueInput[]
    disconnect?: ReclamacaoWhereUniqueInput | ReclamacaoWhereUniqueInput[]
    delete?: ReclamacaoWhereUniqueInput | ReclamacaoWhereUniqueInput[]
    connect?: ReclamacaoWhereUniqueInput | ReclamacaoWhereUniqueInput[]
    update?: ReclamacaoUpdateWithWhereUniqueWithoutUserInput | ReclamacaoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReclamacaoUpdateManyWithWhereWithoutUserInput | ReclamacaoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReclamacaoScalarWhereInput | ReclamacaoScalarWhereInput[]
  }

  export type ProponenteUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProponenteCreateWithoutUserInput, ProponenteUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProponenteCreateOrConnectWithoutUserInput
    upsert?: ProponenteUpsertWithoutUserInput
    disconnect?: ProponenteWhereInput | boolean
    delete?: ProponenteWhereInput | boolean
    connect?: ProponenteWhereUniqueInput
    update?: XOR<XOR<ProponenteUpdateToOneWithWhereWithoutUserInput, ProponenteUpdateWithoutUserInput>, ProponenteUncheckedUpdateWithoutUserInput>
  }

  export type SaqueUpdateManyWithoutUserNestedInput = {
    create?: XOR<SaqueCreateWithoutUserInput, SaqueUncheckedCreateWithoutUserInput> | SaqueCreateWithoutUserInput[] | SaqueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SaqueCreateOrConnectWithoutUserInput | SaqueCreateOrConnectWithoutUserInput[]
    upsert?: SaqueUpsertWithWhereUniqueWithoutUserInput | SaqueUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SaqueCreateManyUserInputEnvelope
    set?: SaqueWhereUniqueInput | SaqueWhereUniqueInput[]
    disconnect?: SaqueWhereUniqueInput | SaqueWhereUniqueInput[]
    delete?: SaqueWhereUniqueInput | SaqueWhereUniqueInput[]
    connect?: SaqueWhereUniqueInput | SaqueWhereUniqueInput[]
    update?: SaqueUpdateWithWhereUniqueWithoutUserInput | SaqueUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SaqueUpdateManyWithWhereWithoutUserInput | SaqueUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SaqueScalarWhereInput | SaqueScalarWhereInput[]
  }

  export type DepositoUpdateManyWithoutUserNestedInput = {
    create?: XOR<DepositoCreateWithoutUserInput, DepositoUncheckedCreateWithoutUserInput> | DepositoCreateWithoutUserInput[] | DepositoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepositoCreateOrConnectWithoutUserInput | DepositoCreateOrConnectWithoutUserInput[]
    upsert?: DepositoUpsertWithWhereUniqueWithoutUserInput | DepositoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DepositoCreateManyUserInputEnvelope
    set?: DepositoWhereUniqueInput | DepositoWhereUniqueInput[]
    disconnect?: DepositoWhereUniqueInput | DepositoWhereUniqueInput[]
    delete?: DepositoWhereUniqueInput | DepositoWhereUniqueInput[]
    connect?: DepositoWhereUniqueInput | DepositoWhereUniqueInput[]
    update?: DepositoUpdateWithWhereUniqueWithoutUserInput | DepositoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DepositoUpdateManyWithWhereWithoutUserInput | DepositoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DepositoScalarWhereInput | DepositoScalarWhereInput[]
  }

  export type CarteiraUpdateOneWithoutUserNestedInput = {
    create?: XOR<CarteiraCreateWithoutUserInput, CarteiraUncheckedCreateWithoutUserInput>
    connectOrCreate?: CarteiraCreateOrConnectWithoutUserInput
    upsert?: CarteiraUpsertWithoutUserInput
    disconnect?: CarteiraWhereInput | boolean
    delete?: CarteiraWhereInput | boolean
    connect?: CarteiraWhereUniqueInput
    update?: XOR<XOR<CarteiraUpdateToOneWithWhereWithoutUserInput, CarteiraUpdateWithoutUserInput>, CarteiraUncheckedUpdateWithoutUserInput>
  }

  export type PapelUpdateOneWithoutUserNestedInput = {
    create?: XOR<PapelCreateWithoutUserInput, PapelUncheckedCreateWithoutUserInput>
    connectOrCreate?: PapelCreateOrConnectWithoutUserInput
    upsert?: PapelUpsertWithoutUserInput
    disconnect?: PapelWhereInput | boolean
    delete?: PapelWhereInput | boolean
    connect?: PapelWhereUniqueInput
    update?: XOR<XOR<PapelUpdateToOneWithWhereWithoutUserInput, PapelUpdateWithoutUserInput>, PapelUncheckedUpdateWithoutUserInput>
  }

  export type SolidarioUpdateManyWithoutUserNestedInput = {
    create?: XOR<SolidarioCreateWithoutUserInput, SolidarioUncheckedCreateWithoutUserInput> | SolidarioCreateWithoutUserInput[] | SolidarioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SolidarioCreateOrConnectWithoutUserInput | SolidarioCreateOrConnectWithoutUserInput[]
    upsert?: SolidarioUpsertWithWhereUniqueWithoutUserInput | SolidarioUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SolidarioCreateManyUserInputEnvelope
    set?: SolidarioWhereUniqueInput | SolidarioWhereUniqueInput[]
    disconnect?: SolidarioWhereUniqueInput | SolidarioWhereUniqueInput[]
    delete?: SolidarioWhereUniqueInput | SolidarioWhereUniqueInput[]
    connect?: SolidarioWhereUniqueInput | SolidarioWhereUniqueInput[]
    update?: SolidarioUpdateWithWhereUniqueWithoutUserInput | SolidarioUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SolidarioUpdateManyWithWhereWithoutUserInput | SolidarioUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SolidarioScalarWhereInput | SolidarioScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PessoaUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PessoaCreateWithoutUserInput, PessoaUncheckedCreateWithoutUserInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutUserInput
    upsert?: PessoaUpsertWithoutUserInput
    disconnect?: PessoaWhereInput | boolean
    delete?: PessoaWhereInput | boolean
    connect?: PessoaWhereUniqueInput
    update?: XOR<XOR<PessoaUpdateToOneWithWhereWithoutUserInput, PessoaUpdateWithoutUserInput>, PessoaUncheckedUpdateWithoutUserInput>
  }

  export type DocumentoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentoCreateWithoutUserInput, DocumentoUncheckedCreateWithoutUserInput> | DocumentoCreateWithoutUserInput[] | DocumentoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutUserInput | DocumentoCreateOrConnectWithoutUserInput[]
    upsert?: DocumentoUpsertWithWhereUniqueWithoutUserInput | DocumentoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentoCreateManyUserInputEnvelope
    set?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    disconnect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    delete?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    update?: DocumentoUpdateWithWhereUniqueWithoutUserInput | DocumentoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentoUpdateManyWithWhereWithoutUserInput | DocumentoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
  }

  export type DevedorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DevedorCreateWithoutUserInput, DevedorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DevedorCreateOrConnectWithoutUserInput
    upsert?: DevedorUpsertWithoutUserInput
    disconnect?: DevedorWhereInput | boolean
    delete?: DevedorWhereInput | boolean
    connect?: DevedorWhereUniqueInput
    update?: XOR<XOR<DevedorUpdateToOneWithWhereWithoutUserInput, DevedorUpdateWithoutUserInput>, DevedorUncheckedUpdateWithoutUserInput>
  }

  export type InvestidorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<InvestidorCreateWithoutUserInput, InvestidorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestidorCreateOrConnectWithoutUserInput
    upsert?: InvestidorUpsertWithoutUserInput
    disconnect?: InvestidorWhereInput | boolean
    delete?: InvestidorWhereInput | boolean
    connect?: InvestidorWhereUniqueInput
    update?: XOR<XOR<InvestidorUpdateToOneWithWhereWithoutUserInput, InvestidorUpdateWithoutUserInput>, InvestidorUncheckedUpdateWithoutUserInput>
  }

  export type ReclamacaoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReclamacaoCreateWithoutUserInput, ReclamacaoUncheckedCreateWithoutUserInput> | ReclamacaoCreateWithoutUserInput[] | ReclamacaoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReclamacaoCreateOrConnectWithoutUserInput | ReclamacaoCreateOrConnectWithoutUserInput[]
    upsert?: ReclamacaoUpsertWithWhereUniqueWithoutUserInput | ReclamacaoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReclamacaoCreateManyUserInputEnvelope
    set?: ReclamacaoWhereUniqueInput | ReclamacaoWhereUniqueInput[]
    disconnect?: ReclamacaoWhereUniqueInput | ReclamacaoWhereUniqueInput[]
    delete?: ReclamacaoWhereUniqueInput | ReclamacaoWhereUniqueInput[]
    connect?: ReclamacaoWhereUniqueInput | ReclamacaoWhereUniqueInput[]
    update?: ReclamacaoUpdateWithWhereUniqueWithoutUserInput | ReclamacaoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReclamacaoUpdateManyWithWhereWithoutUserInput | ReclamacaoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReclamacaoScalarWhereInput | ReclamacaoScalarWhereInput[]
  }

  export type ProponenteUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProponenteCreateWithoutUserInput, ProponenteUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProponenteCreateOrConnectWithoutUserInput
    upsert?: ProponenteUpsertWithoutUserInput
    disconnect?: ProponenteWhereInput | boolean
    delete?: ProponenteWhereInput | boolean
    connect?: ProponenteWhereUniqueInput
    update?: XOR<XOR<ProponenteUpdateToOneWithWhereWithoutUserInput, ProponenteUpdateWithoutUserInput>, ProponenteUncheckedUpdateWithoutUserInput>
  }

  export type SaqueUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SaqueCreateWithoutUserInput, SaqueUncheckedCreateWithoutUserInput> | SaqueCreateWithoutUserInput[] | SaqueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SaqueCreateOrConnectWithoutUserInput | SaqueCreateOrConnectWithoutUserInput[]
    upsert?: SaqueUpsertWithWhereUniqueWithoutUserInput | SaqueUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SaqueCreateManyUserInputEnvelope
    set?: SaqueWhereUniqueInput | SaqueWhereUniqueInput[]
    disconnect?: SaqueWhereUniqueInput | SaqueWhereUniqueInput[]
    delete?: SaqueWhereUniqueInput | SaqueWhereUniqueInput[]
    connect?: SaqueWhereUniqueInput | SaqueWhereUniqueInput[]
    update?: SaqueUpdateWithWhereUniqueWithoutUserInput | SaqueUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SaqueUpdateManyWithWhereWithoutUserInput | SaqueUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SaqueScalarWhereInput | SaqueScalarWhereInput[]
  }

  export type DepositoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DepositoCreateWithoutUserInput, DepositoUncheckedCreateWithoutUserInput> | DepositoCreateWithoutUserInput[] | DepositoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepositoCreateOrConnectWithoutUserInput | DepositoCreateOrConnectWithoutUserInput[]
    upsert?: DepositoUpsertWithWhereUniqueWithoutUserInput | DepositoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DepositoCreateManyUserInputEnvelope
    set?: DepositoWhereUniqueInput | DepositoWhereUniqueInput[]
    disconnect?: DepositoWhereUniqueInput | DepositoWhereUniqueInput[]
    delete?: DepositoWhereUniqueInput | DepositoWhereUniqueInput[]
    connect?: DepositoWhereUniqueInput | DepositoWhereUniqueInput[]
    update?: DepositoUpdateWithWhereUniqueWithoutUserInput | DepositoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DepositoUpdateManyWithWhereWithoutUserInput | DepositoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DepositoScalarWhereInput | DepositoScalarWhereInput[]
  }

  export type CarteiraUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CarteiraCreateWithoutUserInput, CarteiraUncheckedCreateWithoutUserInput>
    connectOrCreate?: CarteiraCreateOrConnectWithoutUserInput
    upsert?: CarteiraUpsertWithoutUserInput
    disconnect?: CarteiraWhereInput | boolean
    delete?: CarteiraWhereInput | boolean
    connect?: CarteiraWhereUniqueInput
    update?: XOR<XOR<CarteiraUpdateToOneWithWhereWithoutUserInput, CarteiraUpdateWithoutUserInput>, CarteiraUncheckedUpdateWithoutUserInput>
  }

  export type PapelUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PapelCreateWithoutUserInput, PapelUncheckedCreateWithoutUserInput>
    connectOrCreate?: PapelCreateOrConnectWithoutUserInput
    upsert?: PapelUpsertWithoutUserInput
    disconnect?: PapelWhereInput | boolean
    delete?: PapelWhereInput | boolean
    connect?: PapelWhereUniqueInput
    update?: XOR<XOR<PapelUpdateToOneWithWhereWithoutUserInput, PapelUpdateWithoutUserInput>, PapelUncheckedUpdateWithoutUserInput>
  }

  export type SolidarioUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SolidarioCreateWithoutUserInput, SolidarioUncheckedCreateWithoutUserInput> | SolidarioCreateWithoutUserInput[] | SolidarioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SolidarioCreateOrConnectWithoutUserInput | SolidarioCreateOrConnectWithoutUserInput[]
    upsert?: SolidarioUpsertWithWhereUniqueWithoutUserInput | SolidarioUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SolidarioCreateManyUserInputEnvelope
    set?: SolidarioWhereUniqueInput | SolidarioWhereUniqueInput[]
    disconnect?: SolidarioWhereUniqueInput | SolidarioWhereUniqueInput[]
    delete?: SolidarioWhereUniqueInput | SolidarioWhereUniqueInput[]
    connect?: SolidarioWhereUniqueInput | SolidarioWhereUniqueInput[]
    update?: SolidarioUpdateWithWhereUniqueWithoutUserInput | SolidarioUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SolidarioUpdateManyWithWhereWithoutUserInput | SolidarioUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SolidarioScalarWhereInput | SolidarioScalarWhereInput[]
  }

  export type PessoaCreateNestedManyWithoutEmpregoInput = {
    create?: XOR<PessoaCreateWithoutEmpregoInput, PessoaUncheckedCreateWithoutEmpregoInput> | PessoaCreateWithoutEmpregoInput[] | PessoaUncheckedCreateWithoutEmpregoInput[]
    connectOrCreate?: PessoaCreateOrConnectWithoutEmpregoInput | PessoaCreateOrConnectWithoutEmpregoInput[]
    createMany?: PessoaCreateManyEmpregoInputEnvelope
    connect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
  }

  export type PessoaUncheckedCreateNestedManyWithoutEmpregoInput = {
    create?: XOR<PessoaCreateWithoutEmpregoInput, PessoaUncheckedCreateWithoutEmpregoInput> | PessoaCreateWithoutEmpregoInput[] | PessoaUncheckedCreateWithoutEmpregoInput[]
    connectOrCreate?: PessoaCreateOrConnectWithoutEmpregoInput | PessoaCreateOrConnectWithoutEmpregoInput[]
    createMany?: PessoaCreateManyEmpregoInputEnvelope
    connect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumSectorFieldUpdateOperationsInput = {
    set?: $Enums.Sector
  }

  export type EnumAreaFieldUpdateOperationsInput = {
    set?: $Enums.Area
  }

  export type PessoaUpdateManyWithoutEmpregoNestedInput = {
    create?: XOR<PessoaCreateWithoutEmpregoInput, PessoaUncheckedCreateWithoutEmpregoInput> | PessoaCreateWithoutEmpregoInput[] | PessoaUncheckedCreateWithoutEmpregoInput[]
    connectOrCreate?: PessoaCreateOrConnectWithoutEmpregoInput | PessoaCreateOrConnectWithoutEmpregoInput[]
    upsert?: PessoaUpsertWithWhereUniqueWithoutEmpregoInput | PessoaUpsertWithWhereUniqueWithoutEmpregoInput[]
    createMany?: PessoaCreateManyEmpregoInputEnvelope
    set?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    disconnect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    delete?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    connect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    update?: PessoaUpdateWithWhereUniqueWithoutEmpregoInput | PessoaUpdateWithWhereUniqueWithoutEmpregoInput[]
    updateMany?: PessoaUpdateManyWithWhereWithoutEmpregoInput | PessoaUpdateManyWithWhereWithoutEmpregoInput[]
    deleteMany?: PessoaScalarWhereInput | PessoaScalarWhereInput[]
  }

  export type PessoaUncheckedUpdateManyWithoutEmpregoNestedInput = {
    create?: XOR<PessoaCreateWithoutEmpregoInput, PessoaUncheckedCreateWithoutEmpregoInput> | PessoaCreateWithoutEmpregoInput[] | PessoaUncheckedCreateWithoutEmpregoInput[]
    connectOrCreate?: PessoaCreateOrConnectWithoutEmpregoInput | PessoaCreateOrConnectWithoutEmpregoInput[]
    upsert?: PessoaUpsertWithWhereUniqueWithoutEmpregoInput | PessoaUpsertWithWhereUniqueWithoutEmpregoInput[]
    createMany?: PessoaCreateManyEmpregoInputEnvelope
    set?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    disconnect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    delete?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    connect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    update?: PessoaUpdateWithWhereUniqueWithoutEmpregoInput | PessoaUpdateWithWhereUniqueWithoutEmpregoInput[]
    updateMany?: PessoaUpdateManyWithWhereWithoutEmpregoInput | PessoaUpdateManyWithWhereWithoutEmpregoInput[]
    deleteMany?: PessoaScalarWhereInput | PessoaScalarWhereInput[]
  }

  export type PessoaCreateNestedManyWithoutResidenciaInput = {
    create?: XOR<PessoaCreateWithoutResidenciaInput, PessoaUncheckedCreateWithoutResidenciaInput> | PessoaCreateWithoutResidenciaInput[] | PessoaUncheckedCreateWithoutResidenciaInput[]
    connectOrCreate?: PessoaCreateOrConnectWithoutResidenciaInput | PessoaCreateOrConnectWithoutResidenciaInput[]
    createMany?: PessoaCreateManyResidenciaInputEnvelope
    connect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
  }

  export type PessoaUncheckedCreateNestedManyWithoutResidenciaInput = {
    create?: XOR<PessoaCreateWithoutResidenciaInput, PessoaUncheckedCreateWithoutResidenciaInput> | PessoaCreateWithoutResidenciaInput[] | PessoaUncheckedCreateWithoutResidenciaInput[]
    connectOrCreate?: PessoaCreateOrConnectWithoutResidenciaInput | PessoaCreateOrConnectWithoutResidenciaInput[]
    createMany?: PessoaCreateManyResidenciaInputEnvelope
    connect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
  }

  export type EnumPropriedadeFieldUpdateOperationsInput = {
    set?: $Enums.Propriedade
  }

  export type PessoaUpdateManyWithoutResidenciaNestedInput = {
    create?: XOR<PessoaCreateWithoutResidenciaInput, PessoaUncheckedCreateWithoutResidenciaInput> | PessoaCreateWithoutResidenciaInput[] | PessoaUncheckedCreateWithoutResidenciaInput[]
    connectOrCreate?: PessoaCreateOrConnectWithoutResidenciaInput | PessoaCreateOrConnectWithoutResidenciaInput[]
    upsert?: PessoaUpsertWithWhereUniqueWithoutResidenciaInput | PessoaUpsertWithWhereUniqueWithoutResidenciaInput[]
    createMany?: PessoaCreateManyResidenciaInputEnvelope
    set?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    disconnect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    delete?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    connect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    update?: PessoaUpdateWithWhereUniqueWithoutResidenciaInput | PessoaUpdateWithWhereUniqueWithoutResidenciaInput[]
    updateMany?: PessoaUpdateManyWithWhereWithoutResidenciaInput | PessoaUpdateManyWithWhereWithoutResidenciaInput[]
    deleteMany?: PessoaScalarWhereInput | PessoaScalarWhereInput[]
  }

  export type PessoaUncheckedUpdateManyWithoutResidenciaNestedInput = {
    create?: XOR<PessoaCreateWithoutResidenciaInput, PessoaUncheckedCreateWithoutResidenciaInput> | PessoaCreateWithoutResidenciaInput[] | PessoaUncheckedCreateWithoutResidenciaInput[]
    connectOrCreate?: PessoaCreateOrConnectWithoutResidenciaInput | PessoaCreateOrConnectWithoutResidenciaInput[]
    upsert?: PessoaUpsertWithWhereUniqueWithoutResidenciaInput | PessoaUpsertWithWhereUniqueWithoutResidenciaInput[]
    createMany?: PessoaCreateManyResidenciaInputEnvelope
    set?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    disconnect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    delete?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    connect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    update?: PessoaUpdateWithWhereUniqueWithoutResidenciaInput | PessoaUpdateWithWhereUniqueWithoutResidenciaInput[]
    updateMany?: PessoaUpdateManyWithWhereWithoutResidenciaInput | PessoaUpdateManyWithWhereWithoutResidenciaInput[]
    deleteMany?: PessoaScalarWhereInput | PessoaScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPapelInput = {
    create?: XOR<UserCreateWithoutPapelInput, UserUncheckedCreateWithoutPapelInput>
    connectOrCreate?: UserCreateOrConnectWithoutPapelInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPerfilFieldUpdateOperationsInput = {
    set?: $Enums.Perfil
  }

  export type UserUpdateOneRequiredWithoutPapelNestedInput = {
    create?: XOR<UserCreateWithoutPapelInput, UserUncheckedCreateWithoutPapelInput>
    connectOrCreate?: UserCreateOrConnectWithoutPapelInput
    upsert?: UserUpsertWithoutPapelInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPapelInput, UserUpdateWithoutPapelInput>, UserUncheckedUpdateWithoutPapelInput>
  }

  export type UserCreateNestedOneWithoutPessoaInput = {
    create?: XOR<UserCreateWithoutPessoaInput, UserUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: UserCreateOrConnectWithoutPessoaInput
    connect?: UserWhereUniqueInput
  }

  export type EmpregoCreateNestedOneWithoutPessoaInput = {
    create?: XOR<EmpregoCreateWithoutPessoaInput, EmpregoUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: EmpregoCreateOrConnectWithoutPessoaInput
    connect?: EmpregoWhereUniqueInput
  }

  export type ResidenciaCreateNestedOneWithoutPessoaInput = {
    create?: XOR<ResidenciaCreateWithoutPessoaInput, ResidenciaUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: ResidenciaCreateOrConnectWithoutPessoaInput
    connect?: ResidenciaWhereUniqueInput
  }

  export type ConjugueCreateNestedOneWithoutPessoaInput = {
    create?: XOR<ConjugueCreateWithoutPessoaInput, ConjugueUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: ConjugueCreateOrConnectWithoutPessoaInput
    connect?: ConjugueWhereUniqueInput
  }

  export type SolidarioCreateNestedOneWithoutPessoaInput = {
    create?: XOR<SolidarioCreateWithoutPessoaInput, SolidarioUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: SolidarioCreateOrConnectWithoutPessoaInput
    connect?: SolidarioWhereUniqueInput
  }

  export type ContaCreateNestedOneWithoutPessoaInput = {
    create?: XOR<ContaCreateWithoutPessoaInput, ContaUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: ContaCreateOrConnectWithoutPessoaInput
    connect?: ContaWhereUniqueInput
  }

  export type ConjugueUncheckedCreateNestedOneWithoutPessoaInput = {
    create?: XOR<ConjugueCreateWithoutPessoaInput, ConjugueUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: ConjugueCreateOrConnectWithoutPessoaInput
    connect?: ConjugueWhereUniqueInput
  }

  export type SolidarioUncheckedCreateNestedOneWithoutPessoaInput = {
    create?: XOR<SolidarioCreateWithoutPessoaInput, SolidarioUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: SolidarioCreateOrConnectWithoutPessoaInput
    connect?: SolidarioWhereUniqueInput
  }

  export type ContaUncheckedCreateNestedOneWithoutPessoaInput = {
    create?: XOR<ContaCreateWithoutPessoaInput, ContaUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: ContaCreateOrConnectWithoutPessoaInput
    connect?: ContaWhereUniqueInput
  }

  export type EnumEstadoFieldUpdateOperationsInput = {
    set?: $Enums.Estado
  }

  export type UserUpdateOneRequiredWithoutPessoaNestedInput = {
    create?: XOR<UserCreateWithoutPessoaInput, UserUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: UserCreateOrConnectWithoutPessoaInput
    upsert?: UserUpsertWithoutPessoaInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPessoaInput, UserUpdateWithoutPessoaInput>, UserUncheckedUpdateWithoutPessoaInput>
  }

  export type EmpregoUpdateOneRequiredWithoutPessoaNestedInput = {
    create?: XOR<EmpregoCreateWithoutPessoaInput, EmpregoUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: EmpregoCreateOrConnectWithoutPessoaInput
    upsert?: EmpregoUpsertWithoutPessoaInput
    connect?: EmpregoWhereUniqueInput
    update?: XOR<XOR<EmpregoUpdateToOneWithWhereWithoutPessoaInput, EmpregoUpdateWithoutPessoaInput>, EmpregoUncheckedUpdateWithoutPessoaInput>
  }

  export type ResidenciaUpdateOneRequiredWithoutPessoaNestedInput = {
    create?: XOR<ResidenciaCreateWithoutPessoaInput, ResidenciaUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: ResidenciaCreateOrConnectWithoutPessoaInput
    upsert?: ResidenciaUpsertWithoutPessoaInput
    connect?: ResidenciaWhereUniqueInput
    update?: XOR<XOR<ResidenciaUpdateToOneWithWhereWithoutPessoaInput, ResidenciaUpdateWithoutPessoaInput>, ResidenciaUncheckedUpdateWithoutPessoaInput>
  }

  export type ConjugueUpdateOneWithoutPessoaNestedInput = {
    create?: XOR<ConjugueCreateWithoutPessoaInput, ConjugueUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: ConjugueCreateOrConnectWithoutPessoaInput
    upsert?: ConjugueUpsertWithoutPessoaInput
    disconnect?: ConjugueWhereInput | boolean
    delete?: ConjugueWhereInput | boolean
    connect?: ConjugueWhereUniqueInput
    update?: XOR<XOR<ConjugueUpdateToOneWithWhereWithoutPessoaInput, ConjugueUpdateWithoutPessoaInput>, ConjugueUncheckedUpdateWithoutPessoaInput>
  }

  export type SolidarioUpdateOneWithoutPessoaNestedInput = {
    create?: XOR<SolidarioCreateWithoutPessoaInput, SolidarioUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: SolidarioCreateOrConnectWithoutPessoaInput
    upsert?: SolidarioUpsertWithoutPessoaInput
    disconnect?: SolidarioWhereInput | boolean
    delete?: SolidarioWhereInput | boolean
    connect?: SolidarioWhereUniqueInput
    update?: XOR<XOR<SolidarioUpdateToOneWithWhereWithoutPessoaInput, SolidarioUpdateWithoutPessoaInput>, SolidarioUncheckedUpdateWithoutPessoaInput>
  }

  export type ContaUpdateOneWithoutPessoaNestedInput = {
    create?: XOR<ContaCreateWithoutPessoaInput, ContaUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: ContaCreateOrConnectWithoutPessoaInput
    upsert?: ContaUpsertWithoutPessoaInput
    disconnect?: ContaWhereInput | boolean
    delete?: ContaWhereInput | boolean
    connect?: ContaWhereUniqueInput
    update?: XOR<XOR<ContaUpdateToOneWithWhereWithoutPessoaInput, ContaUpdateWithoutPessoaInput>, ContaUncheckedUpdateWithoutPessoaInput>
  }

  export type ConjugueUncheckedUpdateOneWithoutPessoaNestedInput = {
    create?: XOR<ConjugueCreateWithoutPessoaInput, ConjugueUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: ConjugueCreateOrConnectWithoutPessoaInput
    upsert?: ConjugueUpsertWithoutPessoaInput
    disconnect?: ConjugueWhereInput | boolean
    delete?: ConjugueWhereInput | boolean
    connect?: ConjugueWhereUniqueInput
    update?: XOR<XOR<ConjugueUpdateToOneWithWhereWithoutPessoaInput, ConjugueUpdateWithoutPessoaInput>, ConjugueUncheckedUpdateWithoutPessoaInput>
  }

  export type SolidarioUncheckedUpdateOneWithoutPessoaNestedInput = {
    create?: XOR<SolidarioCreateWithoutPessoaInput, SolidarioUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: SolidarioCreateOrConnectWithoutPessoaInput
    upsert?: SolidarioUpsertWithoutPessoaInput
    disconnect?: SolidarioWhereInput | boolean
    delete?: SolidarioWhereInput | boolean
    connect?: SolidarioWhereUniqueInput
    update?: XOR<XOR<SolidarioUpdateToOneWithWhereWithoutPessoaInput, SolidarioUpdateWithoutPessoaInput>, SolidarioUncheckedUpdateWithoutPessoaInput>
  }

  export type ContaUncheckedUpdateOneWithoutPessoaNestedInput = {
    create?: XOR<ContaCreateWithoutPessoaInput, ContaUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: ContaCreateOrConnectWithoutPessoaInput
    upsert?: ContaUpsertWithoutPessoaInput
    disconnect?: ContaWhereInput | boolean
    delete?: ContaWhereInput | boolean
    connect?: ContaWhereUniqueInput
    update?: XOR<XOR<ContaUpdateToOneWithWhereWithoutPessoaInput, ContaUpdateWithoutPessoaInput>, ContaUncheckedUpdateWithoutPessoaInput>
  }

  export type PessoaCreateNestedOneWithoutContaInput = {
    create?: XOR<PessoaCreateWithoutContaInput, PessoaUncheckedCreateWithoutContaInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutContaInput
    connect?: PessoaWhereUniqueInput
  }

  export type PessoaUpdateOneRequiredWithoutContaNestedInput = {
    create?: XOR<PessoaCreateWithoutContaInput, PessoaUncheckedCreateWithoutContaInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutContaInput
    upsert?: PessoaUpsertWithoutContaInput
    connect?: PessoaWhereUniqueInput
    update?: XOR<XOR<PessoaUpdateToOneWithWhereWithoutContaInput, PessoaUpdateWithoutContaInput>, PessoaUncheckedUpdateWithoutContaInput>
  }

  export type PessoaCreateNestedOneWithoutConjugueInput = {
    create?: XOR<PessoaCreateWithoutConjugueInput, PessoaUncheckedCreateWithoutConjugueInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutConjugueInput
    connect?: PessoaWhereUniqueInput
  }

  export type PessoaUpdateOneRequiredWithoutConjugueNestedInput = {
    create?: XOR<PessoaCreateWithoutConjugueInput, PessoaUncheckedCreateWithoutConjugueInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutConjugueInput
    upsert?: PessoaUpsertWithoutConjugueInput
    connect?: PessoaWhereUniqueInput
    update?: XOR<XOR<PessoaUpdateToOneWithWhereWithoutConjugueInput, PessoaUpdateWithoutConjugueInput>, PessoaUncheckedUpdateWithoutConjugueInput>
  }

  export type UserCreateNestedOneWithoutDocumentoInput = {
    create?: XOR<UserCreateWithoutDocumentoInput, UserUncheckedCreateWithoutDocumentoInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentoInput
    connect?: UserWhereUniqueInput
  }

  export type EnumComprovativoFieldUpdateOperationsInput = {
    set?: $Enums.Comprovativo
  }

  export type UserUpdateOneRequiredWithoutDocumentoNestedInput = {
    create?: XOR<UserCreateWithoutDocumentoInput, UserUncheckedCreateWithoutDocumentoInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentoInput
    upsert?: UserUpsertWithoutDocumentoInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentoInput, UserUpdateWithoutDocumentoInput>, UserUncheckedUpdateWithoutDocumentoInput>
  }

  export type UserCreateNestedOneWithoutDevedorInput = {
    create?: XOR<UserCreateWithoutDevedorInput, UserUncheckedCreateWithoutDevedorInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevedorInput
    connect?: UserWhereUniqueInput
  }

  export type CreditoCreateNestedManyWithoutDevedorInput = {
    create?: XOR<CreditoCreateWithoutDevedorInput, CreditoUncheckedCreateWithoutDevedorInput> | CreditoCreateWithoutDevedorInput[] | CreditoUncheckedCreateWithoutDevedorInput[]
    connectOrCreate?: CreditoCreateOrConnectWithoutDevedorInput | CreditoCreateOrConnectWithoutDevedorInput[]
    createMany?: CreditoCreateManyDevedorInputEnvelope
    connect?: CreditoWhereUniqueInput | CreditoWhereUniqueInput[]
  }

  export type MovelCreateNestedManyWithoutDevedorInput = {
    create?: XOR<MovelCreateWithoutDevedorInput, MovelUncheckedCreateWithoutDevedorInput> | MovelCreateWithoutDevedorInput[] | MovelUncheckedCreateWithoutDevedorInput[]
    connectOrCreate?: MovelCreateOrConnectWithoutDevedorInput | MovelCreateOrConnectWithoutDevedorInput[]
    createMany?: MovelCreateManyDevedorInputEnvelope
    connect?: MovelWhereUniqueInput | MovelWhereUniqueInput[]
  }

  export type PagamentoCreateNestedManyWithoutDevedorInput = {
    create?: XOR<PagamentoCreateWithoutDevedorInput, PagamentoUncheckedCreateWithoutDevedorInput> | PagamentoCreateWithoutDevedorInput[] | PagamentoUncheckedCreateWithoutDevedorInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutDevedorInput | PagamentoCreateOrConnectWithoutDevedorInput[]
    createMany?: PagamentoCreateManyDevedorInputEnvelope
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
  }

  export type CreditoUncheckedCreateNestedManyWithoutDevedorInput = {
    create?: XOR<CreditoCreateWithoutDevedorInput, CreditoUncheckedCreateWithoutDevedorInput> | CreditoCreateWithoutDevedorInput[] | CreditoUncheckedCreateWithoutDevedorInput[]
    connectOrCreate?: CreditoCreateOrConnectWithoutDevedorInput | CreditoCreateOrConnectWithoutDevedorInput[]
    createMany?: CreditoCreateManyDevedorInputEnvelope
    connect?: CreditoWhereUniqueInput | CreditoWhereUniqueInput[]
  }

  export type MovelUncheckedCreateNestedManyWithoutDevedorInput = {
    create?: XOR<MovelCreateWithoutDevedorInput, MovelUncheckedCreateWithoutDevedorInput> | MovelCreateWithoutDevedorInput[] | MovelUncheckedCreateWithoutDevedorInput[]
    connectOrCreate?: MovelCreateOrConnectWithoutDevedorInput | MovelCreateOrConnectWithoutDevedorInput[]
    createMany?: MovelCreateManyDevedorInputEnvelope
    connect?: MovelWhereUniqueInput | MovelWhereUniqueInput[]
  }

  export type PagamentoUncheckedCreateNestedManyWithoutDevedorInput = {
    create?: XOR<PagamentoCreateWithoutDevedorInput, PagamentoUncheckedCreateWithoutDevedorInput> | PagamentoCreateWithoutDevedorInput[] | PagamentoUncheckedCreateWithoutDevedorInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutDevedorInput | PagamentoCreateOrConnectWithoutDevedorInput[]
    createMany?: PagamentoCreateManyDevedorInputEnvelope
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutDevedorNestedInput = {
    create?: XOR<UserCreateWithoutDevedorInput, UserUncheckedCreateWithoutDevedorInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevedorInput
    upsert?: UserUpsertWithoutDevedorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDevedorInput, UserUpdateWithoutDevedorInput>, UserUncheckedUpdateWithoutDevedorInput>
  }

  export type CreditoUpdateManyWithoutDevedorNestedInput = {
    create?: XOR<CreditoCreateWithoutDevedorInput, CreditoUncheckedCreateWithoutDevedorInput> | CreditoCreateWithoutDevedorInput[] | CreditoUncheckedCreateWithoutDevedorInput[]
    connectOrCreate?: CreditoCreateOrConnectWithoutDevedorInput | CreditoCreateOrConnectWithoutDevedorInput[]
    upsert?: CreditoUpsertWithWhereUniqueWithoutDevedorInput | CreditoUpsertWithWhereUniqueWithoutDevedorInput[]
    createMany?: CreditoCreateManyDevedorInputEnvelope
    set?: CreditoWhereUniqueInput | CreditoWhereUniqueInput[]
    disconnect?: CreditoWhereUniqueInput | CreditoWhereUniqueInput[]
    delete?: CreditoWhereUniqueInput | CreditoWhereUniqueInput[]
    connect?: CreditoWhereUniqueInput | CreditoWhereUniqueInput[]
    update?: CreditoUpdateWithWhereUniqueWithoutDevedorInput | CreditoUpdateWithWhereUniqueWithoutDevedorInput[]
    updateMany?: CreditoUpdateManyWithWhereWithoutDevedorInput | CreditoUpdateManyWithWhereWithoutDevedorInput[]
    deleteMany?: CreditoScalarWhereInput | CreditoScalarWhereInput[]
  }

  export type MovelUpdateManyWithoutDevedorNestedInput = {
    create?: XOR<MovelCreateWithoutDevedorInput, MovelUncheckedCreateWithoutDevedorInput> | MovelCreateWithoutDevedorInput[] | MovelUncheckedCreateWithoutDevedorInput[]
    connectOrCreate?: MovelCreateOrConnectWithoutDevedorInput | MovelCreateOrConnectWithoutDevedorInput[]
    upsert?: MovelUpsertWithWhereUniqueWithoutDevedorInput | MovelUpsertWithWhereUniqueWithoutDevedorInput[]
    createMany?: MovelCreateManyDevedorInputEnvelope
    set?: MovelWhereUniqueInput | MovelWhereUniqueInput[]
    disconnect?: MovelWhereUniqueInput | MovelWhereUniqueInput[]
    delete?: MovelWhereUniqueInput | MovelWhereUniqueInput[]
    connect?: MovelWhereUniqueInput | MovelWhereUniqueInput[]
    update?: MovelUpdateWithWhereUniqueWithoutDevedorInput | MovelUpdateWithWhereUniqueWithoutDevedorInput[]
    updateMany?: MovelUpdateManyWithWhereWithoutDevedorInput | MovelUpdateManyWithWhereWithoutDevedorInput[]
    deleteMany?: MovelScalarWhereInput | MovelScalarWhereInput[]
  }

  export type PagamentoUpdateManyWithoutDevedorNestedInput = {
    create?: XOR<PagamentoCreateWithoutDevedorInput, PagamentoUncheckedCreateWithoutDevedorInput> | PagamentoCreateWithoutDevedorInput[] | PagamentoUncheckedCreateWithoutDevedorInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutDevedorInput | PagamentoCreateOrConnectWithoutDevedorInput[]
    upsert?: PagamentoUpsertWithWhereUniqueWithoutDevedorInput | PagamentoUpsertWithWhereUniqueWithoutDevedorInput[]
    createMany?: PagamentoCreateManyDevedorInputEnvelope
    set?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    disconnect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    delete?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    update?: PagamentoUpdateWithWhereUniqueWithoutDevedorInput | PagamentoUpdateWithWhereUniqueWithoutDevedorInput[]
    updateMany?: PagamentoUpdateManyWithWhereWithoutDevedorInput | PagamentoUpdateManyWithWhereWithoutDevedorInput[]
    deleteMany?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
  }

  export type CreditoUncheckedUpdateManyWithoutDevedorNestedInput = {
    create?: XOR<CreditoCreateWithoutDevedorInput, CreditoUncheckedCreateWithoutDevedorInput> | CreditoCreateWithoutDevedorInput[] | CreditoUncheckedCreateWithoutDevedorInput[]
    connectOrCreate?: CreditoCreateOrConnectWithoutDevedorInput | CreditoCreateOrConnectWithoutDevedorInput[]
    upsert?: CreditoUpsertWithWhereUniqueWithoutDevedorInput | CreditoUpsertWithWhereUniqueWithoutDevedorInput[]
    createMany?: CreditoCreateManyDevedorInputEnvelope
    set?: CreditoWhereUniqueInput | CreditoWhereUniqueInput[]
    disconnect?: CreditoWhereUniqueInput | CreditoWhereUniqueInput[]
    delete?: CreditoWhereUniqueInput | CreditoWhereUniqueInput[]
    connect?: CreditoWhereUniqueInput | CreditoWhereUniqueInput[]
    update?: CreditoUpdateWithWhereUniqueWithoutDevedorInput | CreditoUpdateWithWhereUniqueWithoutDevedorInput[]
    updateMany?: CreditoUpdateManyWithWhereWithoutDevedorInput | CreditoUpdateManyWithWhereWithoutDevedorInput[]
    deleteMany?: CreditoScalarWhereInput | CreditoScalarWhereInput[]
  }

  export type MovelUncheckedUpdateManyWithoutDevedorNestedInput = {
    create?: XOR<MovelCreateWithoutDevedorInput, MovelUncheckedCreateWithoutDevedorInput> | MovelCreateWithoutDevedorInput[] | MovelUncheckedCreateWithoutDevedorInput[]
    connectOrCreate?: MovelCreateOrConnectWithoutDevedorInput | MovelCreateOrConnectWithoutDevedorInput[]
    upsert?: MovelUpsertWithWhereUniqueWithoutDevedorInput | MovelUpsertWithWhereUniqueWithoutDevedorInput[]
    createMany?: MovelCreateManyDevedorInputEnvelope
    set?: MovelWhereUniqueInput | MovelWhereUniqueInput[]
    disconnect?: MovelWhereUniqueInput | MovelWhereUniqueInput[]
    delete?: MovelWhereUniqueInput | MovelWhereUniqueInput[]
    connect?: MovelWhereUniqueInput | MovelWhereUniqueInput[]
    update?: MovelUpdateWithWhereUniqueWithoutDevedorInput | MovelUpdateWithWhereUniqueWithoutDevedorInput[]
    updateMany?: MovelUpdateManyWithWhereWithoutDevedorInput | MovelUpdateManyWithWhereWithoutDevedorInput[]
    deleteMany?: MovelScalarWhereInput | MovelScalarWhereInput[]
  }

  export type PagamentoUncheckedUpdateManyWithoutDevedorNestedInput = {
    create?: XOR<PagamentoCreateWithoutDevedorInput, PagamentoUncheckedCreateWithoutDevedorInput> | PagamentoCreateWithoutDevedorInput[] | PagamentoUncheckedCreateWithoutDevedorInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutDevedorInput | PagamentoCreateOrConnectWithoutDevedorInput[]
    upsert?: PagamentoUpsertWithWhereUniqueWithoutDevedorInput | PagamentoUpsertWithWhereUniqueWithoutDevedorInput[]
    createMany?: PagamentoCreateManyDevedorInputEnvelope
    set?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    disconnect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    delete?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    update?: PagamentoUpdateWithWhereUniqueWithoutDevedorInput | PagamentoUpdateWithWhereUniqueWithoutDevedorInput[]
    updateMany?: PagamentoUpdateManyWithWhereWithoutDevedorInput | PagamentoUpdateManyWithWhereWithoutDevedorInput[]
    deleteMany?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
  }

  export type DiversificacaoCreateNestedManyWithoutInvestidorInput = {
    create?: XOR<DiversificacaoCreateWithoutInvestidorInput, DiversificacaoUncheckedCreateWithoutInvestidorInput> | DiversificacaoCreateWithoutInvestidorInput[] | DiversificacaoUncheckedCreateWithoutInvestidorInput[]
    connectOrCreate?: DiversificacaoCreateOrConnectWithoutInvestidorInput | DiversificacaoCreateOrConnectWithoutInvestidorInput[]
    createMany?: DiversificacaoCreateManyInvestidorInputEnvelope
    connect?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutInvestidorInput = {
    create?: XOR<UserCreateWithoutInvestidorInput, UserUncheckedCreateWithoutInvestidorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestidorInput
    connect?: UserWhereUniqueInput
  }

  export type DiversificacaoUncheckedCreateNestedManyWithoutInvestidorInput = {
    create?: XOR<DiversificacaoCreateWithoutInvestidorInput, DiversificacaoUncheckedCreateWithoutInvestidorInput> | DiversificacaoCreateWithoutInvestidorInput[] | DiversificacaoUncheckedCreateWithoutInvestidorInput[]
    connectOrCreate?: DiversificacaoCreateOrConnectWithoutInvestidorInput | DiversificacaoCreateOrConnectWithoutInvestidorInput[]
    createMany?: DiversificacaoCreateManyInvestidorInputEnvelope
    connect?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
  }

  export type DiversificacaoUpdateManyWithoutInvestidorNestedInput = {
    create?: XOR<DiversificacaoCreateWithoutInvestidorInput, DiversificacaoUncheckedCreateWithoutInvestidorInput> | DiversificacaoCreateWithoutInvestidorInput[] | DiversificacaoUncheckedCreateWithoutInvestidorInput[]
    connectOrCreate?: DiversificacaoCreateOrConnectWithoutInvestidorInput | DiversificacaoCreateOrConnectWithoutInvestidorInput[]
    upsert?: DiversificacaoUpsertWithWhereUniqueWithoutInvestidorInput | DiversificacaoUpsertWithWhereUniqueWithoutInvestidorInput[]
    createMany?: DiversificacaoCreateManyInvestidorInputEnvelope
    set?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
    disconnect?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
    delete?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
    connect?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
    update?: DiversificacaoUpdateWithWhereUniqueWithoutInvestidorInput | DiversificacaoUpdateWithWhereUniqueWithoutInvestidorInput[]
    updateMany?: DiversificacaoUpdateManyWithWhereWithoutInvestidorInput | DiversificacaoUpdateManyWithWhereWithoutInvestidorInput[]
    deleteMany?: DiversificacaoScalarWhereInput | DiversificacaoScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutInvestidorNestedInput = {
    create?: XOR<UserCreateWithoutInvestidorInput, UserUncheckedCreateWithoutInvestidorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestidorInput
    upsert?: UserUpsertWithoutInvestidorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvestidorInput, UserUpdateWithoutInvestidorInput>, UserUncheckedUpdateWithoutInvestidorInput>
  }

  export type DiversificacaoUncheckedUpdateManyWithoutInvestidorNestedInput = {
    create?: XOR<DiversificacaoCreateWithoutInvestidorInput, DiversificacaoUncheckedCreateWithoutInvestidorInput> | DiversificacaoCreateWithoutInvestidorInput[] | DiversificacaoUncheckedCreateWithoutInvestidorInput[]
    connectOrCreate?: DiversificacaoCreateOrConnectWithoutInvestidorInput | DiversificacaoCreateOrConnectWithoutInvestidorInput[]
    upsert?: DiversificacaoUpsertWithWhereUniqueWithoutInvestidorInput | DiversificacaoUpsertWithWhereUniqueWithoutInvestidorInput[]
    createMany?: DiversificacaoCreateManyInvestidorInputEnvelope
    set?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
    disconnect?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
    delete?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
    connect?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
    update?: DiversificacaoUpdateWithWhereUniqueWithoutInvestidorInput | DiversificacaoUpdateWithWhereUniqueWithoutInvestidorInput[]
    updateMany?: DiversificacaoUpdateManyWithWhereWithoutInvestidorInput | DiversificacaoUpdateManyWithWhereWithoutInvestidorInput[]
    deleteMany?: DiversificacaoScalarWhereInput | DiversificacaoScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutReclamacaoInput = {
    create?: XOR<UserCreateWithoutReclamacaoInput, UserUncheckedCreateWithoutReclamacaoInput>
    connectOrCreate?: UserCreateOrConnectWithoutReclamacaoInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReclamacaoNestedInput = {
    create?: XOR<UserCreateWithoutReclamacaoInput, UserUncheckedCreateWithoutReclamacaoInput>
    connectOrCreate?: UserCreateOrConnectWithoutReclamacaoInput
    upsert?: UserUpsertWithoutReclamacaoInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReclamacaoInput, UserUpdateWithoutReclamacaoInput>, UserUncheckedUpdateWithoutReclamacaoInput>
  }

  export type EmprestimoCreateNestedManyWithoutProponenteInput = {
    create?: XOR<EmprestimoCreateWithoutProponenteInput, EmprestimoUncheckedCreateWithoutProponenteInput> | EmprestimoCreateWithoutProponenteInput[] | EmprestimoUncheckedCreateWithoutProponenteInput[]
    connectOrCreate?: EmprestimoCreateOrConnectWithoutProponenteInput | EmprestimoCreateOrConnectWithoutProponenteInput[]
    createMany?: EmprestimoCreateManyProponenteInputEnvelope
    connect?: EmprestimoWhereUniqueInput | EmprestimoWhereUniqueInput[]
  }

  export type ReembolsoCreateNestedManyWithoutProponenteInput = {
    create?: XOR<ReembolsoCreateWithoutProponenteInput, ReembolsoUncheckedCreateWithoutProponenteInput> | ReembolsoCreateWithoutProponenteInput[] | ReembolsoUncheckedCreateWithoutProponenteInput[]
    connectOrCreate?: ReembolsoCreateOrConnectWithoutProponenteInput | ReembolsoCreateOrConnectWithoutProponenteInput[]
    createMany?: ReembolsoCreateManyProponenteInputEnvelope
    connect?: ReembolsoWhereUniqueInput | ReembolsoWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutProponenteInput = {
    create?: XOR<UserCreateWithoutProponenteInput, UserUncheckedCreateWithoutProponenteInput>
    connectOrCreate?: UserCreateOrConnectWithoutProponenteInput
    connect?: UserWhereUniqueInput
  }

  export type EmprestimoUncheckedCreateNestedManyWithoutProponenteInput = {
    create?: XOR<EmprestimoCreateWithoutProponenteInput, EmprestimoUncheckedCreateWithoutProponenteInput> | EmprestimoCreateWithoutProponenteInput[] | EmprestimoUncheckedCreateWithoutProponenteInput[]
    connectOrCreate?: EmprestimoCreateOrConnectWithoutProponenteInput | EmprestimoCreateOrConnectWithoutProponenteInput[]
    createMany?: EmprestimoCreateManyProponenteInputEnvelope
    connect?: EmprestimoWhereUniqueInput | EmprestimoWhereUniqueInput[]
  }

  export type ReembolsoUncheckedCreateNestedManyWithoutProponenteInput = {
    create?: XOR<ReembolsoCreateWithoutProponenteInput, ReembolsoUncheckedCreateWithoutProponenteInput> | ReembolsoCreateWithoutProponenteInput[] | ReembolsoUncheckedCreateWithoutProponenteInput[]
    connectOrCreate?: ReembolsoCreateOrConnectWithoutProponenteInput | ReembolsoCreateOrConnectWithoutProponenteInput[]
    createMany?: ReembolsoCreateManyProponenteInputEnvelope
    connect?: ReembolsoWhereUniqueInput | ReembolsoWhereUniqueInput[]
  }

  export type EmprestimoUpdateManyWithoutProponenteNestedInput = {
    create?: XOR<EmprestimoCreateWithoutProponenteInput, EmprestimoUncheckedCreateWithoutProponenteInput> | EmprestimoCreateWithoutProponenteInput[] | EmprestimoUncheckedCreateWithoutProponenteInput[]
    connectOrCreate?: EmprestimoCreateOrConnectWithoutProponenteInput | EmprestimoCreateOrConnectWithoutProponenteInput[]
    upsert?: EmprestimoUpsertWithWhereUniqueWithoutProponenteInput | EmprestimoUpsertWithWhereUniqueWithoutProponenteInput[]
    createMany?: EmprestimoCreateManyProponenteInputEnvelope
    set?: EmprestimoWhereUniqueInput | EmprestimoWhereUniqueInput[]
    disconnect?: EmprestimoWhereUniqueInput | EmprestimoWhereUniqueInput[]
    delete?: EmprestimoWhereUniqueInput | EmprestimoWhereUniqueInput[]
    connect?: EmprestimoWhereUniqueInput | EmprestimoWhereUniqueInput[]
    update?: EmprestimoUpdateWithWhereUniqueWithoutProponenteInput | EmprestimoUpdateWithWhereUniqueWithoutProponenteInput[]
    updateMany?: EmprestimoUpdateManyWithWhereWithoutProponenteInput | EmprestimoUpdateManyWithWhereWithoutProponenteInput[]
    deleteMany?: EmprestimoScalarWhereInput | EmprestimoScalarWhereInput[]
  }

  export type ReembolsoUpdateManyWithoutProponenteNestedInput = {
    create?: XOR<ReembolsoCreateWithoutProponenteInput, ReembolsoUncheckedCreateWithoutProponenteInput> | ReembolsoCreateWithoutProponenteInput[] | ReembolsoUncheckedCreateWithoutProponenteInput[]
    connectOrCreate?: ReembolsoCreateOrConnectWithoutProponenteInput | ReembolsoCreateOrConnectWithoutProponenteInput[]
    upsert?: ReembolsoUpsertWithWhereUniqueWithoutProponenteInput | ReembolsoUpsertWithWhereUniqueWithoutProponenteInput[]
    createMany?: ReembolsoCreateManyProponenteInputEnvelope
    set?: ReembolsoWhereUniqueInput | ReembolsoWhereUniqueInput[]
    disconnect?: ReembolsoWhereUniqueInput | ReembolsoWhereUniqueInput[]
    delete?: ReembolsoWhereUniqueInput | ReembolsoWhereUniqueInput[]
    connect?: ReembolsoWhereUniqueInput | ReembolsoWhereUniqueInput[]
    update?: ReembolsoUpdateWithWhereUniqueWithoutProponenteInput | ReembolsoUpdateWithWhereUniqueWithoutProponenteInput[]
    updateMany?: ReembolsoUpdateManyWithWhereWithoutProponenteInput | ReembolsoUpdateManyWithWhereWithoutProponenteInput[]
    deleteMany?: ReembolsoScalarWhereInput | ReembolsoScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutProponenteNestedInput = {
    create?: XOR<UserCreateWithoutProponenteInput, UserUncheckedCreateWithoutProponenteInput>
    connectOrCreate?: UserCreateOrConnectWithoutProponenteInput
    upsert?: UserUpsertWithoutProponenteInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProponenteInput, UserUpdateWithoutProponenteInput>, UserUncheckedUpdateWithoutProponenteInput>
  }

  export type EmprestimoUncheckedUpdateManyWithoutProponenteNestedInput = {
    create?: XOR<EmprestimoCreateWithoutProponenteInput, EmprestimoUncheckedCreateWithoutProponenteInput> | EmprestimoCreateWithoutProponenteInput[] | EmprestimoUncheckedCreateWithoutProponenteInput[]
    connectOrCreate?: EmprestimoCreateOrConnectWithoutProponenteInput | EmprestimoCreateOrConnectWithoutProponenteInput[]
    upsert?: EmprestimoUpsertWithWhereUniqueWithoutProponenteInput | EmprestimoUpsertWithWhereUniqueWithoutProponenteInput[]
    createMany?: EmprestimoCreateManyProponenteInputEnvelope
    set?: EmprestimoWhereUniqueInput | EmprestimoWhereUniqueInput[]
    disconnect?: EmprestimoWhereUniqueInput | EmprestimoWhereUniqueInput[]
    delete?: EmprestimoWhereUniqueInput | EmprestimoWhereUniqueInput[]
    connect?: EmprestimoWhereUniqueInput | EmprestimoWhereUniqueInput[]
    update?: EmprestimoUpdateWithWhereUniqueWithoutProponenteInput | EmprestimoUpdateWithWhereUniqueWithoutProponenteInput[]
    updateMany?: EmprestimoUpdateManyWithWhereWithoutProponenteInput | EmprestimoUpdateManyWithWhereWithoutProponenteInput[]
    deleteMany?: EmprestimoScalarWhereInput | EmprestimoScalarWhereInput[]
  }

  export type ReembolsoUncheckedUpdateManyWithoutProponenteNestedInput = {
    create?: XOR<ReembolsoCreateWithoutProponenteInput, ReembolsoUncheckedCreateWithoutProponenteInput> | ReembolsoCreateWithoutProponenteInput[] | ReembolsoUncheckedCreateWithoutProponenteInput[]
    connectOrCreate?: ReembolsoCreateOrConnectWithoutProponenteInput | ReembolsoCreateOrConnectWithoutProponenteInput[]
    upsert?: ReembolsoUpsertWithWhereUniqueWithoutProponenteInput | ReembolsoUpsertWithWhereUniqueWithoutProponenteInput[]
    createMany?: ReembolsoCreateManyProponenteInputEnvelope
    set?: ReembolsoWhereUniqueInput | ReembolsoWhereUniqueInput[]
    disconnect?: ReembolsoWhereUniqueInput | ReembolsoWhereUniqueInput[]
    delete?: ReembolsoWhereUniqueInput | ReembolsoWhereUniqueInput[]
    connect?: ReembolsoWhereUniqueInput | ReembolsoWhereUniqueInput[]
    update?: ReembolsoUpdateWithWhereUniqueWithoutProponenteInput | ReembolsoUpdateWithWhereUniqueWithoutProponenteInput[]
    updateMany?: ReembolsoUpdateManyWithWhereWithoutProponenteInput | ReembolsoUpdateManyWithWhereWithoutProponenteInput[]
    deleteMany?: ReembolsoScalarWhereInput | ReembolsoScalarWhereInput[]
  }

  export type PessoaCreateNestedOneWithoutSolidarioInput = {
    create?: XOR<PessoaCreateWithoutSolidarioInput, PessoaUncheckedCreateWithoutSolidarioInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutSolidarioInput
    connect?: PessoaWhereUniqueInput
  }

  export type EmprestimoSolidarioCreateNestedManyWithoutSolidarioInput = {
    create?: XOR<EmprestimoSolidarioCreateWithoutSolidarioInput, EmprestimoSolidarioUncheckedCreateWithoutSolidarioInput> | EmprestimoSolidarioCreateWithoutSolidarioInput[] | EmprestimoSolidarioUncheckedCreateWithoutSolidarioInput[]
    connectOrCreate?: EmprestimoSolidarioCreateOrConnectWithoutSolidarioInput | EmprestimoSolidarioCreateOrConnectWithoutSolidarioInput[]
    createMany?: EmprestimoSolidarioCreateManySolidarioInputEnvelope
    connect?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutSolidarioInput = {
    create?: XOR<UserCreateWithoutSolidarioInput, UserUncheckedCreateWithoutSolidarioInput>
    connectOrCreate?: UserCreateOrConnectWithoutSolidarioInput
    connect?: UserWhereUniqueInput
  }

  export type CreditoSolidarioCreateNestedManyWithoutSolidarioInput = {
    create?: XOR<CreditoSolidarioCreateWithoutSolidarioInput, CreditoSolidarioUncheckedCreateWithoutSolidarioInput> | CreditoSolidarioCreateWithoutSolidarioInput[] | CreditoSolidarioUncheckedCreateWithoutSolidarioInput[]
    connectOrCreate?: CreditoSolidarioCreateOrConnectWithoutSolidarioInput | CreditoSolidarioCreateOrConnectWithoutSolidarioInput[]
    createMany?: CreditoSolidarioCreateManySolidarioInputEnvelope
    connect?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
  }

  export type EmprestimoSolidarioUncheckedCreateNestedManyWithoutSolidarioInput = {
    create?: XOR<EmprestimoSolidarioCreateWithoutSolidarioInput, EmprestimoSolidarioUncheckedCreateWithoutSolidarioInput> | EmprestimoSolidarioCreateWithoutSolidarioInput[] | EmprestimoSolidarioUncheckedCreateWithoutSolidarioInput[]
    connectOrCreate?: EmprestimoSolidarioCreateOrConnectWithoutSolidarioInput | EmprestimoSolidarioCreateOrConnectWithoutSolidarioInput[]
    createMany?: EmprestimoSolidarioCreateManySolidarioInputEnvelope
    connect?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
  }

  export type CreditoSolidarioUncheckedCreateNestedManyWithoutSolidarioInput = {
    create?: XOR<CreditoSolidarioCreateWithoutSolidarioInput, CreditoSolidarioUncheckedCreateWithoutSolidarioInput> | CreditoSolidarioCreateWithoutSolidarioInput[] | CreditoSolidarioUncheckedCreateWithoutSolidarioInput[]
    connectOrCreate?: CreditoSolidarioCreateOrConnectWithoutSolidarioInput | CreditoSolidarioCreateOrConnectWithoutSolidarioInput[]
    createMany?: CreditoSolidarioCreateManySolidarioInputEnvelope
    connect?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
  }

  export type EnumAvalFieldUpdateOperationsInput = {
    set?: $Enums.Aval
  }

  export type EnumParentescoFieldUpdateOperationsInput = {
    set?: $Enums.Parentesco
  }

  export type PessoaUpdateOneRequiredWithoutSolidarioNestedInput = {
    create?: XOR<PessoaCreateWithoutSolidarioInput, PessoaUncheckedCreateWithoutSolidarioInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutSolidarioInput
    upsert?: PessoaUpsertWithoutSolidarioInput
    connect?: PessoaWhereUniqueInput
    update?: XOR<XOR<PessoaUpdateToOneWithWhereWithoutSolidarioInput, PessoaUpdateWithoutSolidarioInput>, PessoaUncheckedUpdateWithoutSolidarioInput>
  }

  export type EmprestimoSolidarioUpdateManyWithoutSolidarioNestedInput = {
    create?: XOR<EmprestimoSolidarioCreateWithoutSolidarioInput, EmprestimoSolidarioUncheckedCreateWithoutSolidarioInput> | EmprestimoSolidarioCreateWithoutSolidarioInput[] | EmprestimoSolidarioUncheckedCreateWithoutSolidarioInput[]
    connectOrCreate?: EmprestimoSolidarioCreateOrConnectWithoutSolidarioInput | EmprestimoSolidarioCreateOrConnectWithoutSolidarioInput[]
    upsert?: EmprestimoSolidarioUpsertWithWhereUniqueWithoutSolidarioInput | EmprestimoSolidarioUpsertWithWhereUniqueWithoutSolidarioInput[]
    createMany?: EmprestimoSolidarioCreateManySolidarioInputEnvelope
    set?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
    disconnect?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
    delete?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
    connect?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
    update?: EmprestimoSolidarioUpdateWithWhereUniqueWithoutSolidarioInput | EmprestimoSolidarioUpdateWithWhereUniqueWithoutSolidarioInput[]
    updateMany?: EmprestimoSolidarioUpdateManyWithWhereWithoutSolidarioInput | EmprestimoSolidarioUpdateManyWithWhereWithoutSolidarioInput[]
    deleteMany?: EmprestimoSolidarioScalarWhereInput | EmprestimoSolidarioScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutSolidarioNestedInput = {
    create?: XOR<UserCreateWithoutSolidarioInput, UserUncheckedCreateWithoutSolidarioInput>
    connectOrCreate?: UserCreateOrConnectWithoutSolidarioInput
    upsert?: UserUpsertWithoutSolidarioInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSolidarioInput, UserUpdateWithoutSolidarioInput>, UserUncheckedUpdateWithoutSolidarioInput>
  }

  export type CreditoSolidarioUpdateManyWithoutSolidarioNestedInput = {
    create?: XOR<CreditoSolidarioCreateWithoutSolidarioInput, CreditoSolidarioUncheckedCreateWithoutSolidarioInput> | CreditoSolidarioCreateWithoutSolidarioInput[] | CreditoSolidarioUncheckedCreateWithoutSolidarioInput[]
    connectOrCreate?: CreditoSolidarioCreateOrConnectWithoutSolidarioInput | CreditoSolidarioCreateOrConnectWithoutSolidarioInput[]
    upsert?: CreditoSolidarioUpsertWithWhereUniqueWithoutSolidarioInput | CreditoSolidarioUpsertWithWhereUniqueWithoutSolidarioInput[]
    createMany?: CreditoSolidarioCreateManySolidarioInputEnvelope
    set?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
    disconnect?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
    delete?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
    connect?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
    update?: CreditoSolidarioUpdateWithWhereUniqueWithoutSolidarioInput | CreditoSolidarioUpdateWithWhereUniqueWithoutSolidarioInput[]
    updateMany?: CreditoSolidarioUpdateManyWithWhereWithoutSolidarioInput | CreditoSolidarioUpdateManyWithWhereWithoutSolidarioInput[]
    deleteMany?: CreditoSolidarioScalarWhereInput | CreditoSolidarioScalarWhereInput[]
  }

  export type EmprestimoSolidarioUncheckedUpdateManyWithoutSolidarioNestedInput = {
    create?: XOR<EmprestimoSolidarioCreateWithoutSolidarioInput, EmprestimoSolidarioUncheckedCreateWithoutSolidarioInput> | EmprestimoSolidarioCreateWithoutSolidarioInput[] | EmprestimoSolidarioUncheckedCreateWithoutSolidarioInput[]
    connectOrCreate?: EmprestimoSolidarioCreateOrConnectWithoutSolidarioInput | EmprestimoSolidarioCreateOrConnectWithoutSolidarioInput[]
    upsert?: EmprestimoSolidarioUpsertWithWhereUniqueWithoutSolidarioInput | EmprestimoSolidarioUpsertWithWhereUniqueWithoutSolidarioInput[]
    createMany?: EmprestimoSolidarioCreateManySolidarioInputEnvelope
    set?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
    disconnect?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
    delete?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
    connect?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
    update?: EmprestimoSolidarioUpdateWithWhereUniqueWithoutSolidarioInput | EmprestimoSolidarioUpdateWithWhereUniqueWithoutSolidarioInput[]
    updateMany?: EmprestimoSolidarioUpdateManyWithWhereWithoutSolidarioInput | EmprestimoSolidarioUpdateManyWithWhereWithoutSolidarioInput[]
    deleteMany?: EmprestimoSolidarioScalarWhereInput | EmprestimoSolidarioScalarWhereInput[]
  }

  export type CreditoSolidarioUncheckedUpdateManyWithoutSolidarioNestedInput = {
    create?: XOR<CreditoSolidarioCreateWithoutSolidarioInput, CreditoSolidarioUncheckedCreateWithoutSolidarioInput> | CreditoSolidarioCreateWithoutSolidarioInput[] | CreditoSolidarioUncheckedCreateWithoutSolidarioInput[]
    connectOrCreate?: CreditoSolidarioCreateOrConnectWithoutSolidarioInput | CreditoSolidarioCreateOrConnectWithoutSolidarioInput[]
    upsert?: CreditoSolidarioUpsertWithWhereUniqueWithoutSolidarioInput | CreditoSolidarioUpsertWithWhereUniqueWithoutSolidarioInput[]
    createMany?: CreditoSolidarioCreateManySolidarioInputEnvelope
    set?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
    disconnect?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
    delete?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
    connect?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
    update?: CreditoSolidarioUpdateWithWhereUniqueWithoutSolidarioInput | CreditoSolidarioUpdateWithWhereUniqueWithoutSolidarioInput[]
    updateMany?: CreditoSolidarioUpdateManyWithWhereWithoutSolidarioInput | CreditoSolidarioUpdateManyWithWhereWithoutSolidarioInput[]
    deleteMany?: CreditoSolidarioScalarWhereInput | CreditoSolidarioScalarWhereInput[]
  }

  export type DevedorCreateNestedOneWithoutMovelInput = {
    create?: XOR<DevedorCreateWithoutMovelInput, DevedorUncheckedCreateWithoutMovelInput>
    connectOrCreate?: DevedorCreateOrConnectWithoutMovelInput
    connect?: DevedorWhereUniqueInput
  }

  export type EnumModeloFieldUpdateOperationsInput = {
    set?: $Enums.Modelo
  }

  export type DevedorUpdateOneRequiredWithoutMovelNestedInput = {
    create?: XOR<DevedorCreateWithoutMovelInput, DevedorUncheckedCreateWithoutMovelInput>
    connectOrCreate?: DevedorCreateOrConnectWithoutMovelInput
    upsert?: DevedorUpsertWithoutMovelInput
    connect?: DevedorWhereUniqueInput
    update?: XOR<XOR<DevedorUpdateToOneWithWhereWithoutMovelInput, DevedorUpdateWithoutMovelInput>, DevedorUncheckedUpdateWithoutMovelInput>
  }

  export type CreditoSolidarioCreateNestedManyWithoutCreditoInput = {
    create?: XOR<CreditoSolidarioCreateWithoutCreditoInput, CreditoSolidarioUncheckedCreateWithoutCreditoInput> | CreditoSolidarioCreateWithoutCreditoInput[] | CreditoSolidarioUncheckedCreateWithoutCreditoInput[]
    connectOrCreate?: CreditoSolidarioCreateOrConnectWithoutCreditoInput | CreditoSolidarioCreateOrConnectWithoutCreditoInput[]
    createMany?: CreditoSolidarioCreateManyCreditoInputEnvelope
    connect?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
  }

  export type DevedorCreateNestedOneWithoutCreditoInput = {
    create?: XOR<DevedorCreateWithoutCreditoInput, DevedorUncheckedCreateWithoutCreditoInput>
    connectOrCreate?: DevedorCreateOrConnectWithoutCreditoInput
    connect?: DevedorWhereUniqueInput
  }

  export type CreditoSolidarioUncheckedCreateNestedManyWithoutCreditoInput = {
    create?: XOR<CreditoSolidarioCreateWithoutCreditoInput, CreditoSolidarioUncheckedCreateWithoutCreditoInput> | CreditoSolidarioCreateWithoutCreditoInput[] | CreditoSolidarioUncheckedCreateWithoutCreditoInput[]
    connectOrCreate?: CreditoSolidarioCreateOrConnectWithoutCreditoInput | CreditoSolidarioCreateOrConnectWithoutCreditoInput[]
    createMany?: CreditoSolidarioCreateManyCreditoInputEnvelope
    connect?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
  }

  export type EnumProdutoFieldUpdateOperationsInput = {
    set?: $Enums.Produto
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumProgressoFieldUpdateOperationsInput = {
    set?: $Enums.Progresso
  }

  export type CreditoSolidarioUpdateManyWithoutCreditoNestedInput = {
    create?: XOR<CreditoSolidarioCreateWithoutCreditoInput, CreditoSolidarioUncheckedCreateWithoutCreditoInput> | CreditoSolidarioCreateWithoutCreditoInput[] | CreditoSolidarioUncheckedCreateWithoutCreditoInput[]
    connectOrCreate?: CreditoSolidarioCreateOrConnectWithoutCreditoInput | CreditoSolidarioCreateOrConnectWithoutCreditoInput[]
    upsert?: CreditoSolidarioUpsertWithWhereUniqueWithoutCreditoInput | CreditoSolidarioUpsertWithWhereUniqueWithoutCreditoInput[]
    createMany?: CreditoSolidarioCreateManyCreditoInputEnvelope
    set?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
    disconnect?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
    delete?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
    connect?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
    update?: CreditoSolidarioUpdateWithWhereUniqueWithoutCreditoInput | CreditoSolidarioUpdateWithWhereUniqueWithoutCreditoInput[]
    updateMany?: CreditoSolidarioUpdateManyWithWhereWithoutCreditoInput | CreditoSolidarioUpdateManyWithWhereWithoutCreditoInput[]
    deleteMany?: CreditoSolidarioScalarWhereInput | CreditoSolidarioScalarWhereInput[]
  }

  export type DevedorUpdateOneRequiredWithoutCreditoNestedInput = {
    create?: XOR<DevedorCreateWithoutCreditoInput, DevedorUncheckedCreateWithoutCreditoInput>
    connectOrCreate?: DevedorCreateOrConnectWithoutCreditoInput
    upsert?: DevedorUpsertWithoutCreditoInput
    connect?: DevedorWhereUniqueInput
    update?: XOR<XOR<DevedorUpdateToOneWithWhereWithoutCreditoInput, DevedorUpdateWithoutCreditoInput>, DevedorUncheckedUpdateWithoutCreditoInput>
  }

  export type CreditoSolidarioUncheckedUpdateManyWithoutCreditoNestedInput = {
    create?: XOR<CreditoSolidarioCreateWithoutCreditoInput, CreditoSolidarioUncheckedCreateWithoutCreditoInput> | CreditoSolidarioCreateWithoutCreditoInput[] | CreditoSolidarioUncheckedCreateWithoutCreditoInput[]
    connectOrCreate?: CreditoSolidarioCreateOrConnectWithoutCreditoInput | CreditoSolidarioCreateOrConnectWithoutCreditoInput[]
    upsert?: CreditoSolidarioUpsertWithWhereUniqueWithoutCreditoInput | CreditoSolidarioUpsertWithWhereUniqueWithoutCreditoInput[]
    createMany?: CreditoSolidarioCreateManyCreditoInputEnvelope
    set?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
    disconnect?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
    delete?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
    connect?: CreditoSolidarioWhereUniqueInput | CreditoSolidarioWhereUniqueInput[]
    update?: CreditoSolidarioUpdateWithWhereUniqueWithoutCreditoInput | CreditoSolidarioUpdateWithWhereUniqueWithoutCreditoInput[]
    updateMany?: CreditoSolidarioUpdateManyWithWhereWithoutCreditoInput | CreditoSolidarioUpdateManyWithWhereWithoutCreditoInput[]
    deleteMany?: CreditoSolidarioScalarWhereInput | CreditoSolidarioScalarWhereInput[]
  }

  export type DiversificacaoCreateNestedManyWithoutEmprestimoInput = {
    create?: XOR<DiversificacaoCreateWithoutEmprestimoInput, DiversificacaoUncheckedCreateWithoutEmprestimoInput> | DiversificacaoCreateWithoutEmprestimoInput[] | DiversificacaoUncheckedCreateWithoutEmprestimoInput[]
    connectOrCreate?: DiversificacaoCreateOrConnectWithoutEmprestimoInput | DiversificacaoCreateOrConnectWithoutEmprestimoInput[]
    createMany?: DiversificacaoCreateManyEmprestimoInputEnvelope
    connect?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
  }

  export type EmprestimoSolidarioCreateNestedManyWithoutEmprestimoInput = {
    create?: XOR<EmprestimoSolidarioCreateWithoutEmprestimoInput, EmprestimoSolidarioUncheckedCreateWithoutEmprestimoInput> | EmprestimoSolidarioCreateWithoutEmprestimoInput[] | EmprestimoSolidarioUncheckedCreateWithoutEmprestimoInput[]
    connectOrCreate?: EmprestimoSolidarioCreateOrConnectWithoutEmprestimoInput | EmprestimoSolidarioCreateOrConnectWithoutEmprestimoInput[]
    createMany?: EmprestimoSolidarioCreateManyEmprestimoInputEnvelope
    connect?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
  }

  export type ProponenteCreateNestedOneWithoutEmprestimoInput = {
    create?: XOR<ProponenteCreateWithoutEmprestimoInput, ProponenteUncheckedCreateWithoutEmprestimoInput>
    connectOrCreate?: ProponenteCreateOrConnectWithoutEmprestimoInput
    connect?: ProponenteWhereUniqueInput
  }

  export type DiversificacaoUncheckedCreateNestedManyWithoutEmprestimoInput = {
    create?: XOR<DiversificacaoCreateWithoutEmprestimoInput, DiversificacaoUncheckedCreateWithoutEmprestimoInput> | DiversificacaoCreateWithoutEmprestimoInput[] | DiversificacaoUncheckedCreateWithoutEmprestimoInput[]
    connectOrCreate?: DiversificacaoCreateOrConnectWithoutEmprestimoInput | DiversificacaoCreateOrConnectWithoutEmprestimoInput[]
    createMany?: DiversificacaoCreateManyEmprestimoInputEnvelope
    connect?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
  }

  export type EmprestimoSolidarioUncheckedCreateNestedManyWithoutEmprestimoInput = {
    create?: XOR<EmprestimoSolidarioCreateWithoutEmprestimoInput, EmprestimoSolidarioUncheckedCreateWithoutEmprestimoInput> | EmprestimoSolidarioCreateWithoutEmprestimoInput[] | EmprestimoSolidarioUncheckedCreateWithoutEmprestimoInput[]
    connectOrCreate?: EmprestimoSolidarioCreateOrConnectWithoutEmprestimoInput | EmprestimoSolidarioCreateOrConnectWithoutEmprestimoInput[]
    createMany?: EmprestimoSolidarioCreateManyEmprestimoInputEnvelope
    connect?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
  }

  export type DiversificacaoUpdateManyWithoutEmprestimoNestedInput = {
    create?: XOR<DiversificacaoCreateWithoutEmprestimoInput, DiversificacaoUncheckedCreateWithoutEmprestimoInput> | DiversificacaoCreateWithoutEmprestimoInput[] | DiversificacaoUncheckedCreateWithoutEmprestimoInput[]
    connectOrCreate?: DiversificacaoCreateOrConnectWithoutEmprestimoInput | DiversificacaoCreateOrConnectWithoutEmprestimoInput[]
    upsert?: DiversificacaoUpsertWithWhereUniqueWithoutEmprestimoInput | DiversificacaoUpsertWithWhereUniqueWithoutEmprestimoInput[]
    createMany?: DiversificacaoCreateManyEmprestimoInputEnvelope
    set?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
    disconnect?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
    delete?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
    connect?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
    update?: DiversificacaoUpdateWithWhereUniqueWithoutEmprestimoInput | DiversificacaoUpdateWithWhereUniqueWithoutEmprestimoInput[]
    updateMany?: DiversificacaoUpdateManyWithWhereWithoutEmprestimoInput | DiversificacaoUpdateManyWithWhereWithoutEmprestimoInput[]
    deleteMany?: DiversificacaoScalarWhereInput | DiversificacaoScalarWhereInput[]
  }

  export type EmprestimoSolidarioUpdateManyWithoutEmprestimoNestedInput = {
    create?: XOR<EmprestimoSolidarioCreateWithoutEmprestimoInput, EmprestimoSolidarioUncheckedCreateWithoutEmprestimoInput> | EmprestimoSolidarioCreateWithoutEmprestimoInput[] | EmprestimoSolidarioUncheckedCreateWithoutEmprestimoInput[]
    connectOrCreate?: EmprestimoSolidarioCreateOrConnectWithoutEmprestimoInput | EmprestimoSolidarioCreateOrConnectWithoutEmprestimoInput[]
    upsert?: EmprestimoSolidarioUpsertWithWhereUniqueWithoutEmprestimoInput | EmprestimoSolidarioUpsertWithWhereUniqueWithoutEmprestimoInput[]
    createMany?: EmprestimoSolidarioCreateManyEmprestimoInputEnvelope
    set?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
    disconnect?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
    delete?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
    connect?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
    update?: EmprestimoSolidarioUpdateWithWhereUniqueWithoutEmprestimoInput | EmprestimoSolidarioUpdateWithWhereUniqueWithoutEmprestimoInput[]
    updateMany?: EmprestimoSolidarioUpdateManyWithWhereWithoutEmprestimoInput | EmprestimoSolidarioUpdateManyWithWhereWithoutEmprestimoInput[]
    deleteMany?: EmprestimoSolidarioScalarWhereInput | EmprestimoSolidarioScalarWhereInput[]
  }

  export type ProponenteUpdateOneRequiredWithoutEmprestimoNestedInput = {
    create?: XOR<ProponenteCreateWithoutEmprestimoInput, ProponenteUncheckedCreateWithoutEmprestimoInput>
    connectOrCreate?: ProponenteCreateOrConnectWithoutEmprestimoInput
    upsert?: ProponenteUpsertWithoutEmprestimoInput
    connect?: ProponenteWhereUniqueInput
    update?: XOR<XOR<ProponenteUpdateToOneWithWhereWithoutEmprestimoInput, ProponenteUpdateWithoutEmprestimoInput>, ProponenteUncheckedUpdateWithoutEmprestimoInput>
  }

  export type DiversificacaoUncheckedUpdateManyWithoutEmprestimoNestedInput = {
    create?: XOR<DiversificacaoCreateWithoutEmprestimoInput, DiversificacaoUncheckedCreateWithoutEmprestimoInput> | DiversificacaoCreateWithoutEmprestimoInput[] | DiversificacaoUncheckedCreateWithoutEmprestimoInput[]
    connectOrCreate?: DiversificacaoCreateOrConnectWithoutEmprestimoInput | DiversificacaoCreateOrConnectWithoutEmprestimoInput[]
    upsert?: DiversificacaoUpsertWithWhereUniqueWithoutEmprestimoInput | DiversificacaoUpsertWithWhereUniqueWithoutEmprestimoInput[]
    createMany?: DiversificacaoCreateManyEmprestimoInputEnvelope
    set?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
    disconnect?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
    delete?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
    connect?: DiversificacaoWhereUniqueInput | DiversificacaoWhereUniqueInput[]
    update?: DiversificacaoUpdateWithWhereUniqueWithoutEmprestimoInput | DiversificacaoUpdateWithWhereUniqueWithoutEmprestimoInput[]
    updateMany?: DiversificacaoUpdateManyWithWhereWithoutEmprestimoInput | DiversificacaoUpdateManyWithWhereWithoutEmprestimoInput[]
    deleteMany?: DiversificacaoScalarWhereInput | DiversificacaoScalarWhereInput[]
  }

  export type EmprestimoSolidarioUncheckedUpdateManyWithoutEmprestimoNestedInput = {
    create?: XOR<EmprestimoSolidarioCreateWithoutEmprestimoInput, EmprestimoSolidarioUncheckedCreateWithoutEmprestimoInput> | EmprestimoSolidarioCreateWithoutEmprestimoInput[] | EmprestimoSolidarioUncheckedCreateWithoutEmprestimoInput[]
    connectOrCreate?: EmprestimoSolidarioCreateOrConnectWithoutEmprestimoInput | EmprestimoSolidarioCreateOrConnectWithoutEmprestimoInput[]
    upsert?: EmprestimoSolidarioUpsertWithWhereUniqueWithoutEmprestimoInput | EmprestimoSolidarioUpsertWithWhereUniqueWithoutEmprestimoInput[]
    createMany?: EmprestimoSolidarioCreateManyEmprestimoInputEnvelope
    set?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
    disconnect?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
    delete?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
    connect?: EmprestimoSolidarioWhereUniqueInput | EmprestimoSolidarioWhereUniqueInput[]
    update?: EmprestimoSolidarioUpdateWithWhereUniqueWithoutEmprestimoInput | EmprestimoSolidarioUpdateWithWhereUniqueWithoutEmprestimoInput[]
    updateMany?: EmprestimoSolidarioUpdateManyWithWhereWithoutEmprestimoInput | EmprestimoSolidarioUpdateManyWithWhereWithoutEmprestimoInput[]
    deleteMany?: EmprestimoSolidarioScalarWhereInput | EmprestimoSolidarioScalarWhereInput[]
  }

  export type SolidarioCreateNestedOneWithoutEmprestimoInput = {
    create?: XOR<SolidarioCreateWithoutEmprestimoInput, SolidarioUncheckedCreateWithoutEmprestimoInput>
    connectOrCreate?: SolidarioCreateOrConnectWithoutEmprestimoInput
    connect?: SolidarioWhereUniqueInput
  }

  export type EmprestimoCreateNestedOneWithoutSolidarioInput = {
    create?: XOR<EmprestimoCreateWithoutSolidarioInput, EmprestimoUncheckedCreateWithoutSolidarioInput>
    connectOrCreate?: EmprestimoCreateOrConnectWithoutSolidarioInput
    connect?: EmprestimoWhereUniqueInput
  }

  export type SolidarioUpdateOneRequiredWithoutEmprestimoNestedInput = {
    create?: XOR<SolidarioCreateWithoutEmprestimoInput, SolidarioUncheckedCreateWithoutEmprestimoInput>
    connectOrCreate?: SolidarioCreateOrConnectWithoutEmprestimoInput
    upsert?: SolidarioUpsertWithoutEmprestimoInput
    connect?: SolidarioWhereUniqueInput
    update?: XOR<XOR<SolidarioUpdateToOneWithWhereWithoutEmprestimoInput, SolidarioUpdateWithoutEmprestimoInput>, SolidarioUncheckedUpdateWithoutEmprestimoInput>
  }

  export type EmprestimoUpdateOneRequiredWithoutSolidarioNestedInput = {
    create?: XOR<EmprestimoCreateWithoutSolidarioInput, EmprestimoUncheckedCreateWithoutSolidarioInput>
    connectOrCreate?: EmprestimoCreateOrConnectWithoutSolidarioInput
    upsert?: EmprestimoUpsertWithoutSolidarioInput
    connect?: EmprestimoWhereUniqueInput
    update?: XOR<XOR<EmprestimoUpdateToOneWithWhereWithoutSolidarioInput, EmprestimoUpdateWithoutSolidarioInput>, EmprestimoUncheckedUpdateWithoutSolidarioInput>
  }

  export type SolidarioCreateNestedOneWithoutCreditoInput = {
    create?: XOR<SolidarioCreateWithoutCreditoInput, SolidarioUncheckedCreateWithoutCreditoInput>
    connectOrCreate?: SolidarioCreateOrConnectWithoutCreditoInput
    connect?: SolidarioWhereUniqueInput
  }

  export type CreditoCreateNestedOneWithoutSolidarioInput = {
    create?: XOR<CreditoCreateWithoutSolidarioInput, CreditoUncheckedCreateWithoutSolidarioInput>
    connectOrCreate?: CreditoCreateOrConnectWithoutSolidarioInput
    connect?: CreditoWhereUniqueInput
  }

  export type SolidarioUpdateOneRequiredWithoutCreditoNestedInput = {
    create?: XOR<SolidarioCreateWithoutCreditoInput, SolidarioUncheckedCreateWithoutCreditoInput>
    connectOrCreate?: SolidarioCreateOrConnectWithoutCreditoInput
    upsert?: SolidarioUpsertWithoutCreditoInput
    connect?: SolidarioWhereUniqueInput
    update?: XOR<XOR<SolidarioUpdateToOneWithWhereWithoutCreditoInput, SolidarioUpdateWithoutCreditoInput>, SolidarioUncheckedUpdateWithoutCreditoInput>
  }

  export type CreditoUpdateOneRequiredWithoutSolidarioNestedInput = {
    create?: XOR<CreditoCreateWithoutSolidarioInput, CreditoUncheckedCreateWithoutSolidarioInput>
    connectOrCreate?: CreditoCreateOrConnectWithoutSolidarioInput
    upsert?: CreditoUpsertWithoutSolidarioInput
    connect?: CreditoWhereUniqueInput
    update?: XOR<XOR<CreditoUpdateToOneWithWhereWithoutSolidarioInput, CreditoUpdateWithoutSolidarioInput>, CreditoUncheckedUpdateWithoutSolidarioInput>
  }

  export type InvestidorCreateNestedOneWithoutDiversificacaoInput = {
    create?: XOR<InvestidorCreateWithoutDiversificacaoInput, InvestidorUncheckedCreateWithoutDiversificacaoInput>
    connectOrCreate?: InvestidorCreateOrConnectWithoutDiversificacaoInput
    connect?: InvestidorWhereUniqueInput
  }

  export type EmprestimoCreateNestedOneWithoutDiversificacaoInput = {
    create?: XOR<EmprestimoCreateWithoutDiversificacaoInput, EmprestimoUncheckedCreateWithoutDiversificacaoInput>
    connectOrCreate?: EmprestimoCreateOrConnectWithoutDiversificacaoInput
    connect?: EmprestimoWhereUniqueInput
  }

  export type InvestidorUpdateOneRequiredWithoutDiversificacaoNestedInput = {
    create?: XOR<InvestidorCreateWithoutDiversificacaoInput, InvestidorUncheckedCreateWithoutDiversificacaoInput>
    connectOrCreate?: InvestidorCreateOrConnectWithoutDiversificacaoInput
    upsert?: InvestidorUpsertWithoutDiversificacaoInput
    connect?: InvestidorWhereUniqueInput
    update?: XOR<XOR<InvestidorUpdateToOneWithWhereWithoutDiversificacaoInput, InvestidorUpdateWithoutDiversificacaoInput>, InvestidorUncheckedUpdateWithoutDiversificacaoInput>
  }

  export type EmprestimoUpdateOneRequiredWithoutDiversificacaoNestedInput = {
    create?: XOR<EmprestimoCreateWithoutDiversificacaoInput, EmprestimoUncheckedCreateWithoutDiversificacaoInput>
    connectOrCreate?: EmprestimoCreateOrConnectWithoutDiversificacaoInput
    upsert?: EmprestimoUpsertWithoutDiversificacaoInput
    connect?: EmprestimoWhereUniqueInput
    update?: XOR<XOR<EmprestimoUpdateToOneWithWhereWithoutDiversificacaoInput, EmprestimoUpdateWithoutDiversificacaoInput>, EmprestimoUncheckedUpdateWithoutDiversificacaoInput>
  }

  export type UserCreateNestedOneWithoutSaqueInput = {
    create?: XOR<UserCreateWithoutSaqueInput, UserUncheckedCreateWithoutSaqueInput>
    connectOrCreate?: UserCreateOrConnectWithoutSaqueInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSaqueNestedInput = {
    create?: XOR<UserCreateWithoutSaqueInput, UserUncheckedCreateWithoutSaqueInput>
    connectOrCreate?: UserCreateOrConnectWithoutSaqueInput
    upsert?: UserUpsertWithoutSaqueInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSaqueInput, UserUpdateWithoutSaqueInput>, UserUncheckedUpdateWithoutSaqueInput>
  }

  export type UserCreateNestedOneWithoutDepositoInput = {
    create?: XOR<UserCreateWithoutDepositoInput, UserUncheckedCreateWithoutDepositoInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepositoInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDepositoNestedInput = {
    create?: XOR<UserCreateWithoutDepositoInput, UserUncheckedCreateWithoutDepositoInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepositoInput
    upsert?: UserUpsertWithoutDepositoInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDepositoInput, UserUpdateWithoutDepositoInput>, UserUncheckedUpdateWithoutDepositoInput>
  }

  export type UserCreateNestedOneWithoutCarteiraInput = {
    create?: XOR<UserCreateWithoutCarteiraInput, UserUncheckedCreateWithoutCarteiraInput>
    connectOrCreate?: UserCreateOrConnectWithoutCarteiraInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCarteiraNestedInput = {
    create?: XOR<UserCreateWithoutCarteiraInput, UserUncheckedCreateWithoutCarteiraInput>
    connectOrCreate?: UserCreateOrConnectWithoutCarteiraInput
    upsert?: UserUpsertWithoutCarteiraInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCarteiraInput, UserUpdateWithoutCarteiraInput>, UserUncheckedUpdateWithoutCarteiraInput>
  }

  export type DevedorCreateNestedOneWithoutPagamentoInput = {
    create?: XOR<DevedorCreateWithoutPagamentoInput, DevedorUncheckedCreateWithoutPagamentoInput>
    connectOrCreate?: DevedorCreateOrConnectWithoutPagamentoInput
    connect?: DevedorWhereUniqueInput
  }

  export type DevedorUpdateOneRequiredWithoutPagamentoNestedInput = {
    create?: XOR<DevedorCreateWithoutPagamentoInput, DevedorUncheckedCreateWithoutPagamentoInput>
    connectOrCreate?: DevedorCreateOrConnectWithoutPagamentoInput
    upsert?: DevedorUpsertWithoutPagamentoInput
    connect?: DevedorWhereUniqueInput
    update?: XOR<XOR<DevedorUpdateToOneWithWhereWithoutPagamentoInput, DevedorUpdateWithoutPagamentoInput>, DevedorUncheckedUpdateWithoutPagamentoInput>
  }

  export type ProponenteCreateNestedOneWithoutReembolsoInput = {
    create?: XOR<ProponenteCreateWithoutReembolsoInput, ProponenteUncheckedCreateWithoutReembolsoInput>
    connectOrCreate?: ProponenteCreateOrConnectWithoutReembolsoInput
    connect?: ProponenteWhereUniqueInput
  }

  export type ProponenteUpdateOneRequiredWithoutReembolsoNestedInput = {
    create?: XOR<ProponenteCreateWithoutReembolsoInput, ProponenteUncheckedCreateWithoutReembolsoInput>
    connectOrCreate?: ProponenteCreateOrConnectWithoutReembolsoInput
    upsert?: ProponenteUpsertWithoutReembolsoInput
    connect?: ProponenteWhereUniqueInput
    update?: XOR<XOR<ProponenteUpdateToOneWithWhereWithoutReembolsoInput, ProponenteUpdateWithoutReembolsoInput>, ProponenteUncheckedUpdateWithoutReembolsoInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumGeneroFilter<$PrismaModel = never> = {
    equals?: $Enums.Genero | EnumGeneroFieldRefInput<$PrismaModel>
    in?: $Enums.Genero[]
    notIn?: $Enums.Genero[]
    not?: NestedEnumGeneroFilter<$PrismaModel> | $Enums.Genero
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumGeneroWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Genero | EnumGeneroFieldRefInput<$PrismaModel>
    in?: $Enums.Genero[]
    notIn?: $Enums.Genero[]
    not?: NestedEnumGeneroWithAggregatesFilter<$PrismaModel> | $Enums.Genero
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGeneroFilter<$PrismaModel>
    _max?: NestedEnumGeneroFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumSectorFilter<$PrismaModel = never> = {
    equals?: $Enums.Sector | EnumSectorFieldRefInput<$PrismaModel>
    in?: $Enums.Sector[]
    notIn?: $Enums.Sector[]
    not?: NestedEnumSectorFilter<$PrismaModel> | $Enums.Sector
  }

  export type NestedEnumAreaFilter<$PrismaModel = never> = {
    equals?: $Enums.Area | EnumAreaFieldRefInput<$PrismaModel>
    in?: $Enums.Area[]
    notIn?: $Enums.Area[]
    not?: NestedEnumAreaFilter<$PrismaModel> | $Enums.Area
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumSectorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sector | EnumSectorFieldRefInput<$PrismaModel>
    in?: $Enums.Sector[]
    notIn?: $Enums.Sector[]
    not?: NestedEnumSectorWithAggregatesFilter<$PrismaModel> | $Enums.Sector
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSectorFilter<$PrismaModel>
    _max?: NestedEnumSectorFilter<$PrismaModel>
  }

  export type NestedEnumAreaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Area | EnumAreaFieldRefInput<$PrismaModel>
    in?: $Enums.Area[]
    notIn?: $Enums.Area[]
    not?: NestedEnumAreaWithAggregatesFilter<$PrismaModel> | $Enums.Area
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAreaFilter<$PrismaModel>
    _max?: NestedEnumAreaFilter<$PrismaModel>
  }

  export type NestedEnumPropriedadeFilter<$PrismaModel = never> = {
    equals?: $Enums.Propriedade | EnumPropriedadeFieldRefInput<$PrismaModel>
    in?: $Enums.Propriedade[]
    notIn?: $Enums.Propriedade[]
    not?: NestedEnumPropriedadeFilter<$PrismaModel> | $Enums.Propriedade
  }

  export type NestedEnumPropriedadeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Propriedade | EnumPropriedadeFieldRefInput<$PrismaModel>
    in?: $Enums.Propriedade[]
    notIn?: $Enums.Propriedade[]
    not?: NestedEnumPropriedadeWithAggregatesFilter<$PrismaModel> | $Enums.Propriedade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropriedadeFilter<$PrismaModel>
    _max?: NestedEnumPropriedadeFilter<$PrismaModel>
  }

  export type NestedEnumPerfilFilter<$PrismaModel = never> = {
    equals?: $Enums.Perfil | EnumPerfilFieldRefInput<$PrismaModel>
    in?: $Enums.Perfil[]
    notIn?: $Enums.Perfil[]
    not?: NestedEnumPerfilFilter<$PrismaModel> | $Enums.Perfil
  }

  export type NestedEnumPerfilWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Perfil | EnumPerfilFieldRefInput<$PrismaModel>
    in?: $Enums.Perfil[]
    notIn?: $Enums.Perfil[]
    not?: NestedEnumPerfilWithAggregatesFilter<$PrismaModel> | $Enums.Perfil
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPerfilFilter<$PrismaModel>
    _max?: NestedEnumPerfilFilter<$PrismaModel>
  }

  export type NestedEnumEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[]
    notIn?: $Enums.Estado[]
    not?: NestedEnumEstadoFilter<$PrismaModel> | $Enums.Estado
  }

  export type NestedEnumEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[]
    notIn?: $Enums.Estado[]
    not?: NestedEnumEstadoWithAggregatesFilter<$PrismaModel> | $Enums.Estado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoFilter<$PrismaModel>
    _max?: NestedEnumEstadoFilter<$PrismaModel>
  }

  export type NestedEnumComprovativoFilter<$PrismaModel = never> = {
    equals?: $Enums.Comprovativo | EnumComprovativoFieldRefInput<$PrismaModel>
    in?: $Enums.Comprovativo[]
    notIn?: $Enums.Comprovativo[]
    not?: NestedEnumComprovativoFilter<$PrismaModel> | $Enums.Comprovativo
  }

  export type NestedEnumComprovativoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Comprovativo | EnumComprovativoFieldRefInput<$PrismaModel>
    in?: $Enums.Comprovativo[]
    notIn?: $Enums.Comprovativo[]
    not?: NestedEnumComprovativoWithAggregatesFilter<$PrismaModel> | $Enums.Comprovativo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComprovativoFilter<$PrismaModel>
    _max?: NestedEnumComprovativoFilter<$PrismaModel>
  }

  export type NestedEnumAvalFilter<$PrismaModel = never> = {
    equals?: $Enums.Aval | EnumAvalFieldRefInput<$PrismaModel>
    in?: $Enums.Aval[]
    notIn?: $Enums.Aval[]
    not?: NestedEnumAvalFilter<$PrismaModel> | $Enums.Aval
  }

  export type NestedEnumParentescoFilter<$PrismaModel = never> = {
    equals?: $Enums.Parentesco | EnumParentescoFieldRefInput<$PrismaModel>
    in?: $Enums.Parentesco[]
    notIn?: $Enums.Parentesco[]
    not?: NestedEnumParentescoFilter<$PrismaModel> | $Enums.Parentesco
  }

  export type NestedEnumAvalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Aval | EnumAvalFieldRefInput<$PrismaModel>
    in?: $Enums.Aval[]
    notIn?: $Enums.Aval[]
    not?: NestedEnumAvalWithAggregatesFilter<$PrismaModel> | $Enums.Aval
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAvalFilter<$PrismaModel>
    _max?: NestedEnumAvalFilter<$PrismaModel>
  }

  export type NestedEnumParentescoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Parentesco | EnumParentescoFieldRefInput<$PrismaModel>
    in?: $Enums.Parentesco[]
    notIn?: $Enums.Parentesco[]
    not?: NestedEnumParentescoWithAggregatesFilter<$PrismaModel> | $Enums.Parentesco
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParentescoFilter<$PrismaModel>
    _max?: NestedEnumParentescoFilter<$PrismaModel>
  }

  export type NestedEnumModeloFilter<$PrismaModel = never> = {
    equals?: $Enums.Modelo | EnumModeloFieldRefInput<$PrismaModel>
    in?: $Enums.Modelo[]
    notIn?: $Enums.Modelo[]
    not?: NestedEnumModeloFilter<$PrismaModel> | $Enums.Modelo
  }

  export type NestedEnumModeloWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Modelo | EnumModeloFieldRefInput<$PrismaModel>
    in?: $Enums.Modelo[]
    notIn?: $Enums.Modelo[]
    not?: NestedEnumModeloWithAggregatesFilter<$PrismaModel> | $Enums.Modelo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModeloFilter<$PrismaModel>
    _max?: NestedEnumModeloFilter<$PrismaModel>
  }

  export type NestedEnumProdutoFilter<$PrismaModel = never> = {
    equals?: $Enums.Produto | EnumProdutoFieldRefInput<$PrismaModel>
    in?: $Enums.Produto[]
    notIn?: $Enums.Produto[]
    not?: NestedEnumProdutoFilter<$PrismaModel> | $Enums.Produto
  }

  export type NestedEnumProgressoFilter<$PrismaModel = never> = {
    equals?: $Enums.Progresso | EnumProgressoFieldRefInput<$PrismaModel>
    in?: $Enums.Progresso[]
    notIn?: $Enums.Progresso[]
    not?: NestedEnumProgressoFilter<$PrismaModel> | $Enums.Progresso
  }

  export type NestedEnumProdutoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Produto | EnumProdutoFieldRefInput<$PrismaModel>
    in?: $Enums.Produto[]
    notIn?: $Enums.Produto[]
    not?: NestedEnumProdutoWithAggregatesFilter<$PrismaModel> | $Enums.Produto
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProdutoFilter<$PrismaModel>
    _max?: NestedEnumProdutoFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumProgressoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Progresso | EnumProgressoFieldRefInput<$PrismaModel>
    in?: $Enums.Progresso[]
    notIn?: $Enums.Progresso[]
    not?: NestedEnumProgressoWithAggregatesFilter<$PrismaModel> | $Enums.Progresso
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProgressoFilter<$PrismaModel>
    _max?: NestedEnumProgressoFilter<$PrismaModel>
  }

  export type PessoaCreateWithoutUserInput = {
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado?: boolean
    nivel_instrucao: string
    data_nascimento: Date | string
    emprego: EmpregoCreateNestedOneWithoutPessoaInput
    residencia: ResidenciaCreateNestedOneWithoutPessoaInput
    conjugue?: ConjugueCreateNestedOneWithoutPessoaInput
    solidario?: SolidarioCreateNestedOneWithoutPessoaInput
    conta?: ContaCreateNestedOneWithoutPessoaInput
  }

  export type PessoaUncheckedCreateWithoutUserInput = {
    id?: number
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado?: boolean
    nivel_instrucao: string
    data_nascimento: Date | string
    emprego_id: number
    residencia_id: number
    conjugue?: ConjugueUncheckedCreateNestedOneWithoutPessoaInput
    solidario?: SolidarioUncheckedCreateNestedOneWithoutPessoaInput
    conta?: ContaUncheckedCreateNestedOneWithoutPessoaInput
  }

  export type PessoaCreateOrConnectWithoutUserInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutUserInput, PessoaUncheckedCreateWithoutUserInput>
  }

  export type DocumentoCreateWithoutUserInput = {
    tipo: $Enums.Comprovativo
    titulo: string
    extensao: string
    tamanho: string
    nome_original: string
    nome_salvado: string
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentoUncheckedCreateWithoutUserInput = {
    id?: number
    tipo: $Enums.Comprovativo
    titulo: string
    extensao: string
    tamanho: string
    nome_original: string
    nome_salvado: string
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentoCreateOrConnectWithoutUserInput = {
    where: DocumentoWhereUniqueInput
    create: XOR<DocumentoCreateWithoutUserInput, DocumentoUncheckedCreateWithoutUserInput>
  }

  export type DocumentoCreateManyUserInputEnvelope = {
    data: DocumentoCreateManyUserInput | DocumentoCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DevedorCreateWithoutUserInput = {
    solicitacao?: number
    adimplencia?: number
    inadimplencia?: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    credito?: CreditoCreateNestedManyWithoutDevedorInput
    movel?: MovelCreateNestedManyWithoutDevedorInput
    pagamento?: PagamentoCreateNestedManyWithoutDevedorInput
  }

  export type DevedorUncheckedCreateWithoutUserInput = {
    id?: number
    solicitacao?: number
    adimplencia?: number
    inadimplencia?: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    credito?: CreditoUncheckedCreateNestedManyWithoutDevedorInput
    movel?: MovelUncheckedCreateNestedManyWithoutDevedorInput
    pagamento?: PagamentoUncheckedCreateNestedManyWithoutDevedorInput
  }

  export type DevedorCreateOrConnectWithoutUserInput = {
    where: DevedorWhereUniqueInput
    create: XOR<DevedorCreateWithoutUserInput, DevedorUncheckedCreateWithoutUserInput>
  }

  export type InvestidorCreateWithoutUserInput = {
    maior_risco: boolean
    maior_seguranca: boolean
    saque_antecipado: boolean
    fundo_protegido: boolean
    estado?: boolean
    partilhar_emprestimo: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    diversificacao?: DiversificacaoCreateNestedManyWithoutInvestidorInput
  }

  export type InvestidorUncheckedCreateWithoutUserInput = {
    id?: number
    maior_risco: boolean
    maior_seguranca: boolean
    saque_antecipado: boolean
    fundo_protegido: boolean
    estado?: boolean
    partilhar_emprestimo: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    diversificacao?: DiversificacaoUncheckedCreateNestedManyWithoutInvestidorInput
  }

  export type InvestidorCreateOrConnectWithoutUserInput = {
    where: InvestidorWhereUniqueInput
    create: XOR<InvestidorCreateWithoutUserInput, InvestidorUncheckedCreateWithoutUserInput>
  }

  export type ReclamacaoCreateWithoutUserInput = {
    estado?: boolean
    assunto: string
    conteudo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReclamacaoUncheckedCreateWithoutUserInput = {
    id?: number
    estado?: boolean
    assunto: string
    conteudo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReclamacaoCreateOrConnectWithoutUserInput = {
    where: ReclamacaoWhereUniqueInput
    create: XOR<ReclamacaoCreateWithoutUserInput, ReclamacaoUncheckedCreateWithoutUserInput>
  }

  export type ReclamacaoCreateManyUserInputEnvelope = {
    data: ReclamacaoCreateManyUserInput | ReclamacaoCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProponenteCreateWithoutUserInput = {
    solicitacao: number
    reembolsar: number
    satisfeitos: number
    insatisfeitos: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    emprestimo?: EmprestimoCreateNestedManyWithoutProponenteInput
    reembolso?: ReembolsoCreateNestedManyWithoutProponenteInput
  }

  export type ProponenteUncheckedCreateWithoutUserInput = {
    id?: number
    solicitacao: number
    reembolsar: number
    satisfeitos: number
    insatisfeitos: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    emprestimo?: EmprestimoUncheckedCreateNestedManyWithoutProponenteInput
    reembolso?: ReembolsoUncheckedCreateNestedManyWithoutProponenteInput
  }

  export type ProponenteCreateOrConnectWithoutUserInput = {
    where: ProponenteWhereUniqueInput
    create: XOR<ProponenteCreateWithoutUserInput, ProponenteUncheckedCreateWithoutUserInput>
  }

  export type SaqueCreateWithoutUserInput = {
    valor: number
    taxa: number
    estado?: boolean
    pendencia: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaqueUncheckedCreateWithoutUserInput = {
    id?: number
    valor: number
    taxa: number
    estado?: boolean
    pendencia: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaqueCreateOrConnectWithoutUserInput = {
    where: SaqueWhereUniqueInput
    create: XOR<SaqueCreateWithoutUserInput, SaqueUncheckedCreateWithoutUserInput>
  }

  export type SaqueCreateManyUserInputEnvelope = {
    data: SaqueCreateManyUserInput | SaqueCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DepositoCreateWithoutUserInput = {
    valor: number
    estado?: boolean
    pendencia: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositoUncheckedCreateWithoutUserInput = {
    id?: number
    valor: number
    estado?: boolean
    pendencia: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositoCreateOrConnectWithoutUserInput = {
    where: DepositoWhereUniqueInput
    create: XOR<DepositoCreateWithoutUserInput, DepositoUncheckedCreateWithoutUserInput>
  }

  export type DepositoCreateManyUserInputEnvelope = {
    data: DepositoCreateManyUserInput | DepositoCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CarteiraCreateWithoutUserInput = {
    saldo: number
    estado?: boolean
    numero: number
    codigo: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CarteiraUncheckedCreateWithoutUserInput = {
    id?: number
    saldo: number
    estado?: boolean
    numero: number
    codigo: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CarteiraCreateOrConnectWithoutUserInput = {
    where: CarteiraWhereUniqueInput
    create: XOR<CarteiraCreateWithoutUserInput, CarteiraUncheckedCreateWithoutUserInput>
  }

  export type PapelCreateWithoutUserInput = {
    perfil: $Enums.Perfil
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PapelUncheckedCreateWithoutUserInput = {
    id?: number
    perfil: $Enums.Perfil
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PapelCreateOrConnectWithoutUserInput = {
    where: PapelWhereUniqueInput
    create: XOR<PapelCreateWithoutUserInput, PapelUncheckedCreateWithoutUserInput>
  }

  export type SolidarioCreateWithoutUserInput = {
    tipo: $Enums.Aval
    parentesco: $Enums.Parentesco
    taxa: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pessoa: PessoaCreateNestedOneWithoutSolidarioInput
    emprestimo?: EmprestimoSolidarioCreateNestedManyWithoutSolidarioInput
    credito?: CreditoSolidarioCreateNestedManyWithoutSolidarioInput
  }

  export type SolidarioUncheckedCreateWithoutUserInput = {
    id?: number
    tipo: $Enums.Aval
    parentesco: $Enums.Parentesco
    taxa: number
    estado?: boolean
    pessoa_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emprestimo?: EmprestimoSolidarioUncheckedCreateNestedManyWithoutSolidarioInput
    credito?: CreditoSolidarioUncheckedCreateNestedManyWithoutSolidarioInput
  }

  export type SolidarioCreateOrConnectWithoutUserInput = {
    where: SolidarioWhereUniqueInput
    create: XOR<SolidarioCreateWithoutUserInput, SolidarioUncheckedCreateWithoutUserInput>
  }

  export type SolidarioCreateManyUserInputEnvelope = {
    data: SolidarioCreateManyUserInput | SolidarioCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PessoaUpsertWithoutUserInput = {
    update: XOR<PessoaUpdateWithoutUserInput, PessoaUncheckedUpdateWithoutUserInput>
    create: XOR<PessoaCreateWithoutUserInput, PessoaUncheckedCreateWithoutUserInput>
    where?: PessoaWhereInput
  }

  export type PessoaUpdateToOneWithWhereWithoutUserInput = {
    where?: PessoaWhereInput
    data: XOR<PessoaUpdateWithoutUserInput, PessoaUncheckedUpdateWithoutUserInput>
  }

  export type PessoaUpdateWithoutUserInput = {
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    emprego?: EmpregoUpdateOneRequiredWithoutPessoaNestedInput
    residencia?: ResidenciaUpdateOneRequiredWithoutPessoaNestedInput
    conjugue?: ConjugueUpdateOneWithoutPessoaNestedInput
    solidario?: SolidarioUpdateOneWithoutPessoaNestedInput
    conta?: ContaUpdateOneWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    emprego_id?: IntFieldUpdateOperationsInput | number
    residencia_id?: IntFieldUpdateOperationsInput | number
    conjugue?: ConjugueUncheckedUpdateOneWithoutPessoaNestedInput
    solidario?: SolidarioUncheckedUpdateOneWithoutPessoaNestedInput
    conta?: ContaUncheckedUpdateOneWithoutPessoaNestedInput
  }

  export type DocumentoUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentoWhereUniqueInput
    update: XOR<DocumentoUpdateWithoutUserInput, DocumentoUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentoCreateWithoutUserInput, DocumentoUncheckedCreateWithoutUserInput>
  }

  export type DocumentoUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentoWhereUniqueInput
    data: XOR<DocumentoUpdateWithoutUserInput, DocumentoUncheckedUpdateWithoutUserInput>
  }

  export type DocumentoUpdateManyWithWhereWithoutUserInput = {
    where: DocumentoScalarWhereInput
    data: XOR<DocumentoUpdateManyMutationInput, DocumentoUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentoScalarWhereInput = {
    AND?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
    OR?: DocumentoScalarWhereInput[]
    NOT?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
    id?: IntFilter<"Documento"> | number
    tipo?: EnumComprovativoFilter<"Documento"> | $Enums.Comprovativo
    titulo?: StringFilter<"Documento"> | string
    extensao?: StringFilter<"Documento"> | string
    tamanho?: StringFilter<"Documento"> | string
    nome_original?: StringFilter<"Documento"> | string
    nome_salvado?: StringFilter<"Documento"> | string
    estado?: BoolFilter<"Documento"> | boolean
    user_id?: IntFilter<"Documento"> | number
    createdAt?: DateTimeFilter<"Documento"> | Date | string
    updatedAt?: DateTimeFilter<"Documento"> | Date | string
  }

  export type DevedorUpsertWithoutUserInput = {
    update: XOR<DevedorUpdateWithoutUserInput, DevedorUncheckedUpdateWithoutUserInput>
    create: XOR<DevedorCreateWithoutUserInput, DevedorUncheckedCreateWithoutUserInput>
    where?: DevedorWhereInput
  }

  export type DevedorUpdateToOneWithWhereWithoutUserInput = {
    where?: DevedorWhereInput
    data: XOR<DevedorUpdateWithoutUserInput, DevedorUncheckedUpdateWithoutUserInput>
  }

  export type DevedorUpdateWithoutUserInput = {
    solicitacao?: IntFieldUpdateOperationsInput | number
    adimplencia?: IntFieldUpdateOperationsInput | number
    inadimplencia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credito?: CreditoUpdateManyWithoutDevedorNestedInput
    movel?: MovelUpdateManyWithoutDevedorNestedInput
    pagamento?: PagamentoUpdateManyWithoutDevedorNestedInput
  }

  export type DevedorUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    solicitacao?: IntFieldUpdateOperationsInput | number
    adimplencia?: IntFieldUpdateOperationsInput | number
    inadimplencia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credito?: CreditoUncheckedUpdateManyWithoutDevedorNestedInput
    movel?: MovelUncheckedUpdateManyWithoutDevedorNestedInput
    pagamento?: PagamentoUncheckedUpdateManyWithoutDevedorNestedInput
  }

  export type InvestidorUpsertWithoutUserInput = {
    update: XOR<InvestidorUpdateWithoutUserInput, InvestidorUncheckedUpdateWithoutUserInput>
    create: XOR<InvestidorCreateWithoutUserInput, InvestidorUncheckedCreateWithoutUserInput>
    where?: InvestidorWhereInput
  }

  export type InvestidorUpdateToOneWithWhereWithoutUserInput = {
    where?: InvestidorWhereInput
    data: XOR<InvestidorUpdateWithoutUserInput, InvestidorUncheckedUpdateWithoutUserInput>
  }

  export type InvestidorUpdateWithoutUserInput = {
    maior_risco?: BoolFieldUpdateOperationsInput | boolean
    maior_seguranca?: BoolFieldUpdateOperationsInput | boolean
    saque_antecipado?: BoolFieldUpdateOperationsInput | boolean
    fundo_protegido?: BoolFieldUpdateOperationsInput | boolean
    estado?: BoolFieldUpdateOperationsInput | boolean
    partilhar_emprestimo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    diversificacao?: DiversificacaoUpdateManyWithoutInvestidorNestedInput
  }

  export type InvestidorUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    maior_risco?: BoolFieldUpdateOperationsInput | boolean
    maior_seguranca?: BoolFieldUpdateOperationsInput | boolean
    saque_antecipado?: BoolFieldUpdateOperationsInput | boolean
    fundo_protegido?: BoolFieldUpdateOperationsInput | boolean
    estado?: BoolFieldUpdateOperationsInput | boolean
    partilhar_emprestimo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    diversificacao?: DiversificacaoUncheckedUpdateManyWithoutInvestidorNestedInput
  }

  export type ReclamacaoUpsertWithWhereUniqueWithoutUserInput = {
    where: ReclamacaoWhereUniqueInput
    update: XOR<ReclamacaoUpdateWithoutUserInput, ReclamacaoUncheckedUpdateWithoutUserInput>
    create: XOR<ReclamacaoCreateWithoutUserInput, ReclamacaoUncheckedCreateWithoutUserInput>
  }

  export type ReclamacaoUpdateWithWhereUniqueWithoutUserInput = {
    where: ReclamacaoWhereUniqueInput
    data: XOR<ReclamacaoUpdateWithoutUserInput, ReclamacaoUncheckedUpdateWithoutUserInput>
  }

  export type ReclamacaoUpdateManyWithWhereWithoutUserInput = {
    where: ReclamacaoScalarWhereInput
    data: XOR<ReclamacaoUpdateManyMutationInput, ReclamacaoUncheckedUpdateManyWithoutUserInput>
  }

  export type ReclamacaoScalarWhereInput = {
    AND?: ReclamacaoScalarWhereInput | ReclamacaoScalarWhereInput[]
    OR?: ReclamacaoScalarWhereInput[]
    NOT?: ReclamacaoScalarWhereInput | ReclamacaoScalarWhereInput[]
    id?: IntFilter<"Reclamacao"> | number
    user_id?: IntFilter<"Reclamacao"> | number
    estado?: BoolFilter<"Reclamacao"> | boolean
    assunto?: StringFilter<"Reclamacao"> | string
    conteudo?: StringFilter<"Reclamacao"> | string
    createdAt?: DateTimeFilter<"Reclamacao"> | Date | string
    updatedAt?: DateTimeFilter<"Reclamacao"> | Date | string
  }

  export type ProponenteUpsertWithoutUserInput = {
    update: XOR<ProponenteUpdateWithoutUserInput, ProponenteUncheckedUpdateWithoutUserInput>
    create: XOR<ProponenteCreateWithoutUserInput, ProponenteUncheckedCreateWithoutUserInput>
    where?: ProponenteWhereInput
  }

  export type ProponenteUpdateToOneWithWhereWithoutUserInput = {
    where?: ProponenteWhereInput
    data: XOR<ProponenteUpdateWithoutUserInput, ProponenteUncheckedUpdateWithoutUserInput>
  }

  export type ProponenteUpdateWithoutUserInput = {
    solicitacao?: IntFieldUpdateOperationsInput | number
    reembolsar?: IntFieldUpdateOperationsInput | number
    satisfeitos?: IntFieldUpdateOperationsInput | number
    insatisfeitos?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprestimo?: EmprestimoUpdateManyWithoutProponenteNestedInput
    reembolso?: ReembolsoUpdateManyWithoutProponenteNestedInput
  }

  export type ProponenteUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    solicitacao?: IntFieldUpdateOperationsInput | number
    reembolsar?: IntFieldUpdateOperationsInput | number
    satisfeitos?: IntFieldUpdateOperationsInput | number
    insatisfeitos?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprestimo?: EmprestimoUncheckedUpdateManyWithoutProponenteNestedInput
    reembolso?: ReembolsoUncheckedUpdateManyWithoutProponenteNestedInput
  }

  export type SaqueUpsertWithWhereUniqueWithoutUserInput = {
    where: SaqueWhereUniqueInput
    update: XOR<SaqueUpdateWithoutUserInput, SaqueUncheckedUpdateWithoutUserInput>
    create: XOR<SaqueCreateWithoutUserInput, SaqueUncheckedCreateWithoutUserInput>
  }

  export type SaqueUpdateWithWhereUniqueWithoutUserInput = {
    where: SaqueWhereUniqueInput
    data: XOR<SaqueUpdateWithoutUserInput, SaqueUncheckedUpdateWithoutUserInput>
  }

  export type SaqueUpdateManyWithWhereWithoutUserInput = {
    where: SaqueScalarWhereInput
    data: XOR<SaqueUpdateManyMutationInput, SaqueUncheckedUpdateManyWithoutUserInput>
  }

  export type SaqueScalarWhereInput = {
    AND?: SaqueScalarWhereInput | SaqueScalarWhereInput[]
    OR?: SaqueScalarWhereInput[]
    NOT?: SaqueScalarWhereInput | SaqueScalarWhereInput[]
    id?: IntFilter<"Saque"> | number
    valor?: FloatFilter<"Saque"> | number
    taxa?: IntFilter<"Saque"> | number
    estado?: BoolFilter<"Saque"> | boolean
    pendencia?: BoolFilter<"Saque"> | boolean
    user_id?: IntFilter<"Saque"> | number
    createdAt?: DateTimeFilter<"Saque"> | Date | string
    updatedAt?: DateTimeFilter<"Saque"> | Date | string
  }

  export type DepositoUpsertWithWhereUniqueWithoutUserInput = {
    where: DepositoWhereUniqueInput
    update: XOR<DepositoUpdateWithoutUserInput, DepositoUncheckedUpdateWithoutUserInput>
    create: XOR<DepositoCreateWithoutUserInput, DepositoUncheckedCreateWithoutUserInput>
  }

  export type DepositoUpdateWithWhereUniqueWithoutUserInput = {
    where: DepositoWhereUniqueInput
    data: XOR<DepositoUpdateWithoutUserInput, DepositoUncheckedUpdateWithoutUserInput>
  }

  export type DepositoUpdateManyWithWhereWithoutUserInput = {
    where: DepositoScalarWhereInput
    data: XOR<DepositoUpdateManyMutationInput, DepositoUncheckedUpdateManyWithoutUserInput>
  }

  export type DepositoScalarWhereInput = {
    AND?: DepositoScalarWhereInput | DepositoScalarWhereInput[]
    OR?: DepositoScalarWhereInput[]
    NOT?: DepositoScalarWhereInput | DepositoScalarWhereInput[]
    id?: IntFilter<"Deposito"> | number
    valor?: FloatFilter<"Deposito"> | number
    estado?: BoolFilter<"Deposito"> | boolean
    pendencia?: BoolFilter<"Deposito"> | boolean
    user_id?: IntFilter<"Deposito"> | number
    createdAt?: DateTimeFilter<"Deposito"> | Date | string
    updatedAt?: DateTimeFilter<"Deposito"> | Date | string
  }

  export type CarteiraUpsertWithoutUserInput = {
    update: XOR<CarteiraUpdateWithoutUserInput, CarteiraUncheckedUpdateWithoutUserInput>
    create: XOR<CarteiraCreateWithoutUserInput, CarteiraUncheckedCreateWithoutUserInput>
    where?: CarteiraWhereInput
  }

  export type CarteiraUpdateToOneWithWhereWithoutUserInput = {
    where?: CarteiraWhereInput
    data: XOR<CarteiraUpdateWithoutUserInput, CarteiraUncheckedUpdateWithoutUserInput>
  }

  export type CarteiraUpdateWithoutUserInput = {
    saldo?: FloatFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    numero?: IntFieldUpdateOperationsInput | number
    codigo?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarteiraUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    saldo?: FloatFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    numero?: IntFieldUpdateOperationsInput | number
    codigo?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PapelUpsertWithoutUserInput = {
    update: XOR<PapelUpdateWithoutUserInput, PapelUncheckedUpdateWithoutUserInput>
    create: XOR<PapelCreateWithoutUserInput, PapelUncheckedCreateWithoutUserInput>
    where?: PapelWhereInput
  }

  export type PapelUpdateToOneWithWhereWithoutUserInput = {
    where?: PapelWhereInput
    data: XOR<PapelUpdateWithoutUserInput, PapelUncheckedUpdateWithoutUserInput>
  }

  export type PapelUpdateWithoutUserInput = {
    perfil?: EnumPerfilFieldUpdateOperationsInput | $Enums.Perfil
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PapelUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    perfil?: EnumPerfilFieldUpdateOperationsInput | $Enums.Perfil
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SolidarioUpsertWithWhereUniqueWithoutUserInput = {
    where: SolidarioWhereUniqueInput
    update: XOR<SolidarioUpdateWithoutUserInput, SolidarioUncheckedUpdateWithoutUserInput>
    create: XOR<SolidarioCreateWithoutUserInput, SolidarioUncheckedCreateWithoutUserInput>
  }

  export type SolidarioUpdateWithWhereUniqueWithoutUserInput = {
    where: SolidarioWhereUniqueInput
    data: XOR<SolidarioUpdateWithoutUserInput, SolidarioUncheckedUpdateWithoutUserInput>
  }

  export type SolidarioUpdateManyWithWhereWithoutUserInput = {
    where: SolidarioScalarWhereInput
    data: XOR<SolidarioUpdateManyMutationInput, SolidarioUncheckedUpdateManyWithoutUserInput>
  }

  export type SolidarioScalarWhereInput = {
    AND?: SolidarioScalarWhereInput | SolidarioScalarWhereInput[]
    OR?: SolidarioScalarWhereInput[]
    NOT?: SolidarioScalarWhereInput | SolidarioScalarWhereInput[]
    id?: IntFilter<"Solidario"> | number
    tipo?: EnumAvalFilter<"Solidario"> | $Enums.Aval
    parentesco?: EnumParentescoFilter<"Solidario"> | $Enums.Parentesco
    taxa?: IntFilter<"Solidario"> | number
    estado?: BoolFilter<"Solidario"> | boolean
    pessoa_id?: IntFilter<"Solidario"> | number
    user_id?: IntFilter<"Solidario"> | number
    createdAt?: DateTimeFilter<"Solidario"> | Date | string
    updatedAt?: DateTimeFilter<"Solidario"> | Date | string
  }

  export type PessoaCreateWithoutEmpregoInput = {
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado?: boolean
    nivel_instrucao: string
    data_nascimento: Date | string
    user: UserCreateNestedOneWithoutPessoaInput
    residencia: ResidenciaCreateNestedOneWithoutPessoaInput
    conjugue?: ConjugueCreateNestedOneWithoutPessoaInput
    solidario?: SolidarioCreateNestedOneWithoutPessoaInput
    conta?: ContaCreateNestedOneWithoutPessoaInput
  }

  export type PessoaUncheckedCreateWithoutEmpregoInput = {
    id?: number
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado?: boolean
    nivel_instrucao: string
    data_nascimento: Date | string
    user_id: number
    residencia_id: number
    conjugue?: ConjugueUncheckedCreateNestedOneWithoutPessoaInput
    solidario?: SolidarioUncheckedCreateNestedOneWithoutPessoaInput
    conta?: ContaUncheckedCreateNestedOneWithoutPessoaInput
  }

  export type PessoaCreateOrConnectWithoutEmpregoInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutEmpregoInput, PessoaUncheckedCreateWithoutEmpregoInput>
  }

  export type PessoaCreateManyEmpregoInputEnvelope = {
    data: PessoaCreateManyEmpregoInput | PessoaCreateManyEmpregoInput[]
    skipDuplicates?: boolean
  }

  export type PessoaUpsertWithWhereUniqueWithoutEmpregoInput = {
    where: PessoaWhereUniqueInput
    update: XOR<PessoaUpdateWithoutEmpregoInput, PessoaUncheckedUpdateWithoutEmpregoInput>
    create: XOR<PessoaCreateWithoutEmpregoInput, PessoaUncheckedCreateWithoutEmpregoInput>
  }

  export type PessoaUpdateWithWhereUniqueWithoutEmpregoInput = {
    where: PessoaWhereUniqueInput
    data: XOR<PessoaUpdateWithoutEmpregoInput, PessoaUncheckedUpdateWithoutEmpregoInput>
  }

  export type PessoaUpdateManyWithWhereWithoutEmpregoInput = {
    where: PessoaScalarWhereInput
    data: XOR<PessoaUpdateManyMutationInput, PessoaUncheckedUpdateManyWithoutEmpregoInput>
  }

  export type PessoaScalarWhereInput = {
    AND?: PessoaScalarWhereInput | PessoaScalarWhereInput[]
    OR?: PessoaScalarWhereInput[]
    NOT?: PessoaScalarWhereInput | PessoaScalarWhereInput[]
    id?: IntFilter<"Pessoa"> | number
    estado_civil?: EnumEstadoFilter<"Pessoa"> | $Enums.Estado
    provincia?: StringFilter<"Pessoa"> | string
    municipio?: StringFilter<"Pessoa"> | string
    profissao?: StringFilter<"Pessoa"> | string
    estado?: BoolFilter<"Pessoa"> | boolean
    nivel_instrucao?: StringFilter<"Pessoa"> | string
    data_nascimento?: DateTimeFilter<"Pessoa"> | Date | string
    user_id?: IntFilter<"Pessoa"> | number
    emprego_id?: IntFilter<"Pessoa"> | number
    residencia_id?: IntFilter<"Pessoa"> | number
  }

  export type PessoaCreateWithoutResidenciaInput = {
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado?: boolean
    nivel_instrucao: string
    data_nascimento: Date | string
    user: UserCreateNestedOneWithoutPessoaInput
    emprego: EmpregoCreateNestedOneWithoutPessoaInput
    conjugue?: ConjugueCreateNestedOneWithoutPessoaInput
    solidario?: SolidarioCreateNestedOneWithoutPessoaInput
    conta?: ContaCreateNestedOneWithoutPessoaInput
  }

  export type PessoaUncheckedCreateWithoutResidenciaInput = {
    id?: number
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado?: boolean
    nivel_instrucao: string
    data_nascimento: Date | string
    user_id: number
    emprego_id: number
    conjugue?: ConjugueUncheckedCreateNestedOneWithoutPessoaInput
    solidario?: SolidarioUncheckedCreateNestedOneWithoutPessoaInput
    conta?: ContaUncheckedCreateNestedOneWithoutPessoaInput
  }

  export type PessoaCreateOrConnectWithoutResidenciaInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutResidenciaInput, PessoaUncheckedCreateWithoutResidenciaInput>
  }

  export type PessoaCreateManyResidenciaInputEnvelope = {
    data: PessoaCreateManyResidenciaInput | PessoaCreateManyResidenciaInput[]
    skipDuplicates?: boolean
  }

  export type PessoaUpsertWithWhereUniqueWithoutResidenciaInput = {
    where: PessoaWhereUniqueInput
    update: XOR<PessoaUpdateWithoutResidenciaInput, PessoaUncheckedUpdateWithoutResidenciaInput>
    create: XOR<PessoaCreateWithoutResidenciaInput, PessoaUncheckedCreateWithoutResidenciaInput>
  }

  export type PessoaUpdateWithWhereUniqueWithoutResidenciaInput = {
    where: PessoaWhereUniqueInput
    data: XOR<PessoaUpdateWithoutResidenciaInput, PessoaUncheckedUpdateWithoutResidenciaInput>
  }

  export type PessoaUpdateManyWithWhereWithoutResidenciaInput = {
    where: PessoaScalarWhereInput
    data: XOR<PessoaUpdateManyMutationInput, PessoaUncheckedUpdateManyWithoutResidenciaInput>
  }

  export type UserCreateWithoutPapelInput = {
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaCreateNestedOneWithoutUserInput
    documento?: DocumentoCreateNestedManyWithoutUserInput
    devedor?: DevedorCreateNestedOneWithoutUserInput
    investidor?: InvestidorCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoCreateNestedManyWithoutUserInput
    proponente?: ProponenteCreateNestedOneWithoutUserInput
    saque?: SaqueCreateNestedManyWithoutUserInput
    deposito?: DepositoCreateNestedManyWithoutUserInput
    carteira?: CarteiraCreateNestedOneWithoutUserInput
    solidario?: SolidarioCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPapelInput = {
    id?: number
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaUncheckedCreateNestedOneWithoutUserInput
    documento?: DocumentoUncheckedCreateNestedManyWithoutUserInput
    devedor?: DevedorUncheckedCreateNestedOneWithoutUserInput
    investidor?: InvestidorUncheckedCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoUncheckedCreateNestedManyWithoutUserInput
    proponente?: ProponenteUncheckedCreateNestedOneWithoutUserInput
    saque?: SaqueUncheckedCreateNestedManyWithoutUserInput
    deposito?: DepositoUncheckedCreateNestedManyWithoutUserInput
    carteira?: CarteiraUncheckedCreateNestedOneWithoutUserInput
    solidario?: SolidarioUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPapelInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPapelInput, UserUncheckedCreateWithoutPapelInput>
  }

  export type UserUpsertWithoutPapelInput = {
    update: XOR<UserUpdateWithoutPapelInput, UserUncheckedUpdateWithoutPapelInput>
    create: XOR<UserCreateWithoutPapelInput, UserUncheckedCreateWithoutPapelInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPapelInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPapelInput, UserUncheckedUpdateWithoutPapelInput>
  }

  export type UserUpdateWithoutPapelInput = {
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUpdateOneWithoutUserNestedInput
    documento?: DocumentoUpdateManyWithoutUserNestedInput
    devedor?: DevedorUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUpdateOneWithoutUserNestedInput
    saque?: SaqueUpdateManyWithoutUserNestedInput
    deposito?: DepositoUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPapelInput = {
    id?: IntFieldUpdateOperationsInput | number
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUncheckedUpdateOneWithoutUserNestedInput
    documento?: DocumentoUncheckedUpdateManyWithoutUserNestedInput
    devedor?: DevedorUncheckedUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUncheckedUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUncheckedUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUncheckedUpdateOneWithoutUserNestedInput
    saque?: SaqueUncheckedUpdateManyWithoutUserNestedInput
    deposito?: DepositoUncheckedUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUncheckedUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPessoaInput = {
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    documento?: DocumentoCreateNestedManyWithoutUserInput
    devedor?: DevedorCreateNestedOneWithoutUserInput
    investidor?: InvestidorCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoCreateNestedManyWithoutUserInput
    proponente?: ProponenteCreateNestedOneWithoutUserInput
    saque?: SaqueCreateNestedManyWithoutUserInput
    deposito?: DepositoCreateNestedManyWithoutUserInput
    carteira?: CarteiraCreateNestedOneWithoutUserInput
    papel?: PapelCreateNestedOneWithoutUserInput
    solidario?: SolidarioCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPessoaInput = {
    id?: number
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    documento?: DocumentoUncheckedCreateNestedManyWithoutUserInput
    devedor?: DevedorUncheckedCreateNestedOneWithoutUserInput
    investidor?: InvestidorUncheckedCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoUncheckedCreateNestedManyWithoutUserInput
    proponente?: ProponenteUncheckedCreateNestedOneWithoutUserInput
    saque?: SaqueUncheckedCreateNestedManyWithoutUserInput
    deposito?: DepositoUncheckedCreateNestedManyWithoutUserInput
    carteira?: CarteiraUncheckedCreateNestedOneWithoutUserInput
    papel?: PapelUncheckedCreateNestedOneWithoutUserInput
    solidario?: SolidarioUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPessoaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPessoaInput, UserUncheckedCreateWithoutPessoaInput>
  }

  export type EmpregoCreateWithoutPessoaInput = {
    data_inicio: Date | string
    sector: $Enums.Sector
    cargo: string
    area: $Enums.Area
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmpregoUncheckedCreateWithoutPessoaInput = {
    id?: number
    data_inicio: Date | string
    sector: $Enums.Sector
    cargo: string
    area: $Enums.Area
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmpregoCreateOrConnectWithoutPessoaInput = {
    where: EmpregoWhereUniqueInput
    create: XOR<EmpregoCreateWithoutPessoaInput, EmpregoUncheckedCreateWithoutPessoaInput>
  }

  export type ResidenciaCreateWithoutPessoaInput = {
    tipo: $Enums.Propriedade
    data_inicio: Date | string
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResidenciaUncheckedCreateWithoutPessoaInput = {
    id?: number
    tipo: $Enums.Propriedade
    data_inicio: Date | string
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResidenciaCreateOrConnectWithoutPessoaInput = {
    where: ResidenciaWhereUniqueInput
    create: XOR<ResidenciaCreateWithoutPessoaInput, ResidenciaUncheckedCreateWithoutPessoaInput>
  }

  export type ConjugueCreateWithoutPessoaInput = {
    nome_completo: string
    dependentes: number
    nivel_instrucao: string
    estado?: boolean
    data_nascimento: Date | string
  }

  export type ConjugueUncheckedCreateWithoutPessoaInput = {
    id?: number
    nome_completo: string
    dependentes: number
    nivel_instrucao: string
    estado?: boolean
    data_nascimento: Date | string
  }

  export type ConjugueCreateOrConnectWithoutPessoaInput = {
    where: ConjugueWhereUniqueInput
    create: XOR<ConjugueCreateWithoutPessoaInput, ConjugueUncheckedCreateWithoutPessoaInput>
  }

  export type SolidarioCreateWithoutPessoaInput = {
    tipo: $Enums.Aval
    parentesco: $Enums.Parentesco
    taxa: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    emprestimo?: EmprestimoSolidarioCreateNestedManyWithoutSolidarioInput
    user: UserCreateNestedOneWithoutSolidarioInput
    credito?: CreditoSolidarioCreateNestedManyWithoutSolidarioInput
  }

  export type SolidarioUncheckedCreateWithoutPessoaInput = {
    id?: number
    tipo: $Enums.Aval
    parentesco: $Enums.Parentesco
    taxa: number
    estado?: boolean
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emprestimo?: EmprestimoSolidarioUncheckedCreateNestedManyWithoutSolidarioInput
    credito?: CreditoSolidarioUncheckedCreateNestedManyWithoutSolidarioInput
  }

  export type SolidarioCreateOrConnectWithoutPessoaInput = {
    where: SolidarioWhereUniqueInput
    create: XOR<SolidarioCreateWithoutPessoaInput, SolidarioUncheckedCreateWithoutPessoaInput>
  }

  export type ContaCreateWithoutPessoaInput = {
    nome: string
    salario: number
    iban: string
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContaUncheckedCreateWithoutPessoaInput = {
    id?: number
    nome: string
    salario: number
    iban: string
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContaCreateOrConnectWithoutPessoaInput = {
    where: ContaWhereUniqueInput
    create: XOR<ContaCreateWithoutPessoaInput, ContaUncheckedCreateWithoutPessoaInput>
  }

  export type UserUpsertWithoutPessoaInput = {
    update: XOR<UserUpdateWithoutPessoaInput, UserUncheckedUpdateWithoutPessoaInput>
    create: XOR<UserCreateWithoutPessoaInput, UserUncheckedCreateWithoutPessoaInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPessoaInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPessoaInput, UserUncheckedUpdateWithoutPessoaInput>
  }

  export type UserUpdateWithoutPessoaInput = {
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    documento?: DocumentoUpdateManyWithoutUserNestedInput
    devedor?: DevedorUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUpdateOneWithoutUserNestedInput
    saque?: SaqueUpdateManyWithoutUserNestedInput
    deposito?: DepositoUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUpdateOneWithoutUserNestedInput
    papel?: PapelUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPessoaInput = {
    id?: IntFieldUpdateOperationsInput | number
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    documento?: DocumentoUncheckedUpdateManyWithoutUserNestedInput
    devedor?: DevedorUncheckedUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUncheckedUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUncheckedUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUncheckedUpdateOneWithoutUserNestedInput
    saque?: SaqueUncheckedUpdateManyWithoutUserNestedInput
    deposito?: DepositoUncheckedUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUncheckedUpdateOneWithoutUserNestedInput
    papel?: PapelUncheckedUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmpregoUpsertWithoutPessoaInput = {
    update: XOR<EmpregoUpdateWithoutPessoaInput, EmpregoUncheckedUpdateWithoutPessoaInput>
    create: XOR<EmpregoCreateWithoutPessoaInput, EmpregoUncheckedCreateWithoutPessoaInput>
    where?: EmpregoWhereInput
  }

  export type EmpregoUpdateToOneWithWhereWithoutPessoaInput = {
    where?: EmpregoWhereInput
    data: XOR<EmpregoUpdateWithoutPessoaInput, EmpregoUncheckedUpdateWithoutPessoaInput>
  }

  export type EmpregoUpdateWithoutPessoaInput = {
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    cargo?: StringFieldUpdateOperationsInput | string
    area?: EnumAreaFieldUpdateOperationsInput | $Enums.Area
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpregoUncheckedUpdateWithoutPessoaInput = {
    id?: IntFieldUpdateOperationsInput | number
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    cargo?: StringFieldUpdateOperationsInput | string
    area?: EnumAreaFieldUpdateOperationsInput | $Enums.Area
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResidenciaUpsertWithoutPessoaInput = {
    update: XOR<ResidenciaUpdateWithoutPessoaInput, ResidenciaUncheckedUpdateWithoutPessoaInput>
    create: XOR<ResidenciaCreateWithoutPessoaInput, ResidenciaUncheckedCreateWithoutPessoaInput>
    where?: ResidenciaWhereInput
  }

  export type ResidenciaUpdateToOneWithWhereWithoutPessoaInput = {
    where?: ResidenciaWhereInput
    data: XOR<ResidenciaUpdateWithoutPessoaInput, ResidenciaUncheckedUpdateWithoutPessoaInput>
  }

  export type ResidenciaUpdateWithoutPessoaInput = {
    tipo?: EnumPropriedadeFieldUpdateOperationsInput | $Enums.Propriedade
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResidenciaUncheckedUpdateWithoutPessoaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumPropriedadeFieldUpdateOperationsInput | $Enums.Propriedade
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConjugueUpsertWithoutPessoaInput = {
    update: XOR<ConjugueUpdateWithoutPessoaInput, ConjugueUncheckedUpdateWithoutPessoaInput>
    create: XOR<ConjugueCreateWithoutPessoaInput, ConjugueUncheckedCreateWithoutPessoaInput>
    where?: ConjugueWhereInput
  }

  export type ConjugueUpdateToOneWithWhereWithoutPessoaInput = {
    where?: ConjugueWhereInput
    data: XOR<ConjugueUpdateWithoutPessoaInput, ConjugueUncheckedUpdateWithoutPessoaInput>
  }

  export type ConjugueUpdateWithoutPessoaInput = {
    nome_completo?: StringFieldUpdateOperationsInput | string
    dependentes?: IntFieldUpdateOperationsInput | number
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConjugueUncheckedUpdateWithoutPessoaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome_completo?: StringFieldUpdateOperationsInput | string
    dependentes?: IntFieldUpdateOperationsInput | number
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SolidarioUpsertWithoutPessoaInput = {
    update: XOR<SolidarioUpdateWithoutPessoaInput, SolidarioUncheckedUpdateWithoutPessoaInput>
    create: XOR<SolidarioCreateWithoutPessoaInput, SolidarioUncheckedCreateWithoutPessoaInput>
    where?: SolidarioWhereInput
  }

  export type SolidarioUpdateToOneWithWhereWithoutPessoaInput = {
    where?: SolidarioWhereInput
    data: XOR<SolidarioUpdateWithoutPessoaInput, SolidarioUncheckedUpdateWithoutPessoaInput>
  }

  export type SolidarioUpdateWithoutPessoaInput = {
    tipo?: EnumAvalFieldUpdateOperationsInput | $Enums.Aval
    parentesco?: EnumParentescoFieldUpdateOperationsInput | $Enums.Parentesco
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprestimo?: EmprestimoSolidarioUpdateManyWithoutSolidarioNestedInput
    user?: UserUpdateOneRequiredWithoutSolidarioNestedInput
    credito?: CreditoSolidarioUpdateManyWithoutSolidarioNestedInput
  }

  export type SolidarioUncheckedUpdateWithoutPessoaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumAvalFieldUpdateOperationsInput | $Enums.Aval
    parentesco?: EnumParentescoFieldUpdateOperationsInput | $Enums.Parentesco
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprestimo?: EmprestimoSolidarioUncheckedUpdateManyWithoutSolidarioNestedInput
    credito?: CreditoSolidarioUncheckedUpdateManyWithoutSolidarioNestedInput
  }

  export type ContaUpsertWithoutPessoaInput = {
    update: XOR<ContaUpdateWithoutPessoaInput, ContaUncheckedUpdateWithoutPessoaInput>
    create: XOR<ContaCreateWithoutPessoaInput, ContaUncheckedCreateWithoutPessoaInput>
    where?: ContaWhereInput
  }

  export type ContaUpdateToOneWithWhereWithoutPessoaInput = {
    where?: ContaWhereInput
    data: XOR<ContaUpdateWithoutPessoaInput, ContaUncheckedUpdateWithoutPessoaInput>
  }

  export type ContaUpdateWithoutPessoaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    salario?: IntFieldUpdateOperationsInput | number
    iban?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContaUncheckedUpdateWithoutPessoaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    salario?: IntFieldUpdateOperationsInput | number
    iban?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PessoaCreateWithoutContaInput = {
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado?: boolean
    nivel_instrucao: string
    data_nascimento: Date | string
    user: UserCreateNestedOneWithoutPessoaInput
    emprego: EmpregoCreateNestedOneWithoutPessoaInput
    residencia: ResidenciaCreateNestedOneWithoutPessoaInput
    conjugue?: ConjugueCreateNestedOneWithoutPessoaInput
    solidario?: SolidarioCreateNestedOneWithoutPessoaInput
  }

  export type PessoaUncheckedCreateWithoutContaInput = {
    id?: number
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado?: boolean
    nivel_instrucao: string
    data_nascimento: Date | string
    user_id: number
    emprego_id: number
    residencia_id: number
    conjugue?: ConjugueUncheckedCreateNestedOneWithoutPessoaInput
    solidario?: SolidarioUncheckedCreateNestedOneWithoutPessoaInput
  }

  export type PessoaCreateOrConnectWithoutContaInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutContaInput, PessoaUncheckedCreateWithoutContaInput>
  }

  export type PessoaUpsertWithoutContaInput = {
    update: XOR<PessoaUpdateWithoutContaInput, PessoaUncheckedUpdateWithoutContaInput>
    create: XOR<PessoaCreateWithoutContaInput, PessoaUncheckedCreateWithoutContaInput>
    where?: PessoaWhereInput
  }

  export type PessoaUpdateToOneWithWhereWithoutContaInput = {
    where?: PessoaWhereInput
    data: XOR<PessoaUpdateWithoutContaInput, PessoaUncheckedUpdateWithoutContaInput>
  }

  export type PessoaUpdateWithoutContaInput = {
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPessoaNestedInput
    emprego?: EmpregoUpdateOneRequiredWithoutPessoaNestedInput
    residencia?: ResidenciaUpdateOneRequiredWithoutPessoaNestedInput
    conjugue?: ConjugueUpdateOneWithoutPessoaNestedInput
    solidario?: SolidarioUpdateOneWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateWithoutContaInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    emprego_id?: IntFieldUpdateOperationsInput | number
    residencia_id?: IntFieldUpdateOperationsInput | number
    conjugue?: ConjugueUncheckedUpdateOneWithoutPessoaNestedInput
    solidario?: SolidarioUncheckedUpdateOneWithoutPessoaNestedInput
  }

  export type PessoaCreateWithoutConjugueInput = {
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado?: boolean
    nivel_instrucao: string
    data_nascimento: Date | string
    user: UserCreateNestedOneWithoutPessoaInput
    emprego: EmpregoCreateNestedOneWithoutPessoaInput
    residencia: ResidenciaCreateNestedOneWithoutPessoaInput
    solidario?: SolidarioCreateNestedOneWithoutPessoaInput
    conta?: ContaCreateNestedOneWithoutPessoaInput
  }

  export type PessoaUncheckedCreateWithoutConjugueInput = {
    id?: number
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado?: boolean
    nivel_instrucao: string
    data_nascimento: Date | string
    user_id: number
    emprego_id: number
    residencia_id: number
    solidario?: SolidarioUncheckedCreateNestedOneWithoutPessoaInput
    conta?: ContaUncheckedCreateNestedOneWithoutPessoaInput
  }

  export type PessoaCreateOrConnectWithoutConjugueInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutConjugueInput, PessoaUncheckedCreateWithoutConjugueInput>
  }

  export type PessoaUpsertWithoutConjugueInput = {
    update: XOR<PessoaUpdateWithoutConjugueInput, PessoaUncheckedUpdateWithoutConjugueInput>
    create: XOR<PessoaCreateWithoutConjugueInput, PessoaUncheckedCreateWithoutConjugueInput>
    where?: PessoaWhereInput
  }

  export type PessoaUpdateToOneWithWhereWithoutConjugueInput = {
    where?: PessoaWhereInput
    data: XOR<PessoaUpdateWithoutConjugueInput, PessoaUncheckedUpdateWithoutConjugueInput>
  }

  export type PessoaUpdateWithoutConjugueInput = {
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPessoaNestedInput
    emprego?: EmpregoUpdateOneRequiredWithoutPessoaNestedInput
    residencia?: ResidenciaUpdateOneRequiredWithoutPessoaNestedInput
    solidario?: SolidarioUpdateOneWithoutPessoaNestedInput
    conta?: ContaUpdateOneWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateWithoutConjugueInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    emprego_id?: IntFieldUpdateOperationsInput | number
    residencia_id?: IntFieldUpdateOperationsInput | number
    solidario?: SolidarioUncheckedUpdateOneWithoutPessoaNestedInput
    conta?: ContaUncheckedUpdateOneWithoutPessoaNestedInput
  }

  export type UserCreateWithoutDocumentoInput = {
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaCreateNestedOneWithoutUserInput
    devedor?: DevedorCreateNestedOneWithoutUserInput
    investidor?: InvestidorCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoCreateNestedManyWithoutUserInput
    proponente?: ProponenteCreateNestedOneWithoutUserInput
    saque?: SaqueCreateNestedManyWithoutUserInput
    deposito?: DepositoCreateNestedManyWithoutUserInput
    carteira?: CarteiraCreateNestedOneWithoutUserInput
    papel?: PapelCreateNestedOneWithoutUserInput
    solidario?: SolidarioCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentoInput = {
    id?: number
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaUncheckedCreateNestedOneWithoutUserInput
    devedor?: DevedorUncheckedCreateNestedOneWithoutUserInput
    investidor?: InvestidorUncheckedCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoUncheckedCreateNestedManyWithoutUserInput
    proponente?: ProponenteUncheckedCreateNestedOneWithoutUserInput
    saque?: SaqueUncheckedCreateNestedManyWithoutUserInput
    deposito?: DepositoUncheckedCreateNestedManyWithoutUserInput
    carteira?: CarteiraUncheckedCreateNestedOneWithoutUserInput
    papel?: PapelUncheckedCreateNestedOneWithoutUserInput
    solidario?: SolidarioUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentoInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentoInput, UserUncheckedCreateWithoutDocumentoInput>
  }

  export type UserUpsertWithoutDocumentoInput = {
    update: XOR<UserUpdateWithoutDocumentoInput, UserUncheckedUpdateWithoutDocumentoInput>
    create: XOR<UserCreateWithoutDocumentoInput, UserUncheckedCreateWithoutDocumentoInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentoInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentoInput, UserUncheckedUpdateWithoutDocumentoInput>
  }

  export type UserUpdateWithoutDocumentoInput = {
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUpdateOneWithoutUserNestedInput
    devedor?: DevedorUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUpdateOneWithoutUserNestedInput
    saque?: SaqueUpdateManyWithoutUserNestedInput
    deposito?: DepositoUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUpdateOneWithoutUserNestedInput
    papel?: PapelUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUncheckedUpdateOneWithoutUserNestedInput
    devedor?: DevedorUncheckedUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUncheckedUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUncheckedUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUncheckedUpdateOneWithoutUserNestedInput
    saque?: SaqueUncheckedUpdateManyWithoutUserNestedInput
    deposito?: DepositoUncheckedUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUncheckedUpdateOneWithoutUserNestedInput
    papel?: PapelUncheckedUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDevedorInput = {
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaCreateNestedOneWithoutUserInput
    documento?: DocumentoCreateNestedManyWithoutUserInput
    investidor?: InvestidorCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoCreateNestedManyWithoutUserInput
    proponente?: ProponenteCreateNestedOneWithoutUserInput
    saque?: SaqueCreateNestedManyWithoutUserInput
    deposito?: DepositoCreateNestedManyWithoutUserInput
    carteira?: CarteiraCreateNestedOneWithoutUserInput
    papel?: PapelCreateNestedOneWithoutUserInput
    solidario?: SolidarioCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDevedorInput = {
    id?: number
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaUncheckedCreateNestedOneWithoutUserInput
    documento?: DocumentoUncheckedCreateNestedManyWithoutUserInput
    investidor?: InvestidorUncheckedCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoUncheckedCreateNestedManyWithoutUserInput
    proponente?: ProponenteUncheckedCreateNestedOneWithoutUserInput
    saque?: SaqueUncheckedCreateNestedManyWithoutUserInput
    deposito?: DepositoUncheckedCreateNestedManyWithoutUserInput
    carteira?: CarteiraUncheckedCreateNestedOneWithoutUserInput
    papel?: PapelUncheckedCreateNestedOneWithoutUserInput
    solidario?: SolidarioUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDevedorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDevedorInput, UserUncheckedCreateWithoutDevedorInput>
  }

  export type CreditoCreateWithoutDevedorInput = {
    tipo: $Enums.Produto
    valor: number
    prestacao: number
    juro: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    createdAt?: Date | string
    updatedAt?: Date | string
    solidario?: CreditoSolidarioCreateNestedManyWithoutCreditoInput
  }

  export type CreditoUncheckedCreateWithoutDevedorInput = {
    id?: number
    tipo: $Enums.Produto
    valor: number
    prestacao: number
    juro: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    createdAt?: Date | string
    updatedAt?: Date | string
    solidario?: CreditoSolidarioUncheckedCreateNestedManyWithoutCreditoInput
  }

  export type CreditoCreateOrConnectWithoutDevedorInput = {
    where: CreditoWhereUniqueInput
    create: XOR<CreditoCreateWithoutDevedorInput, CreditoUncheckedCreateWithoutDevedorInput>
  }

  export type CreditoCreateManyDevedorInputEnvelope = {
    data: CreditoCreateManyDevedorInput | CreditoCreateManyDevedorInput[]
    skipDuplicates?: boolean
  }

  export type MovelCreateWithoutDevedorInput = {
    modelo: $Enums.Modelo
    matricula: string
    detalhes: string
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovelUncheckedCreateWithoutDevedorInput = {
    id?: number
    modelo: $Enums.Modelo
    matricula: string
    detalhes: string
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovelCreateOrConnectWithoutDevedorInput = {
    where: MovelWhereUniqueInput
    create: XOR<MovelCreateWithoutDevedorInput, MovelUncheckedCreateWithoutDevedorInput>
  }

  export type MovelCreateManyDevedorInputEnvelope = {
    data: MovelCreateManyDevedorInput | MovelCreateManyDevedorInput[]
    skipDuplicates?: boolean
  }

  export type PagamentoCreateWithoutDevedorInput = {
    valor: number
    detalhe: string
    prestacao: number
    estado?: boolean
    pendencia: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagamentoUncheckedCreateWithoutDevedorInput = {
    id?: number
    valor: number
    detalhe: string
    prestacao: number
    estado?: boolean
    pendencia: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagamentoCreateOrConnectWithoutDevedorInput = {
    where: PagamentoWhereUniqueInput
    create: XOR<PagamentoCreateWithoutDevedorInput, PagamentoUncheckedCreateWithoutDevedorInput>
  }

  export type PagamentoCreateManyDevedorInputEnvelope = {
    data: PagamentoCreateManyDevedorInput | PagamentoCreateManyDevedorInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDevedorInput = {
    update: XOR<UserUpdateWithoutDevedorInput, UserUncheckedUpdateWithoutDevedorInput>
    create: XOR<UserCreateWithoutDevedorInput, UserUncheckedCreateWithoutDevedorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDevedorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDevedorInput, UserUncheckedUpdateWithoutDevedorInput>
  }

  export type UserUpdateWithoutDevedorInput = {
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUpdateOneWithoutUserNestedInput
    documento?: DocumentoUpdateManyWithoutUserNestedInput
    investidor?: InvestidorUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUpdateOneWithoutUserNestedInput
    saque?: SaqueUpdateManyWithoutUserNestedInput
    deposito?: DepositoUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUpdateOneWithoutUserNestedInput
    papel?: PapelUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDevedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUncheckedUpdateOneWithoutUserNestedInput
    documento?: DocumentoUncheckedUpdateManyWithoutUserNestedInput
    investidor?: InvestidorUncheckedUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUncheckedUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUncheckedUpdateOneWithoutUserNestedInput
    saque?: SaqueUncheckedUpdateManyWithoutUserNestedInput
    deposito?: DepositoUncheckedUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUncheckedUpdateOneWithoutUserNestedInput
    papel?: PapelUncheckedUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CreditoUpsertWithWhereUniqueWithoutDevedorInput = {
    where: CreditoWhereUniqueInput
    update: XOR<CreditoUpdateWithoutDevedorInput, CreditoUncheckedUpdateWithoutDevedorInput>
    create: XOR<CreditoCreateWithoutDevedorInput, CreditoUncheckedCreateWithoutDevedorInput>
  }

  export type CreditoUpdateWithWhereUniqueWithoutDevedorInput = {
    where: CreditoWhereUniqueInput
    data: XOR<CreditoUpdateWithoutDevedorInput, CreditoUncheckedUpdateWithoutDevedorInput>
  }

  export type CreditoUpdateManyWithWhereWithoutDevedorInput = {
    where: CreditoScalarWhereInput
    data: XOR<CreditoUpdateManyMutationInput, CreditoUncheckedUpdateManyWithoutDevedorInput>
  }

  export type CreditoScalarWhereInput = {
    AND?: CreditoScalarWhereInput | CreditoScalarWhereInput[]
    OR?: CreditoScalarWhereInput[]
    NOT?: CreditoScalarWhereInput | CreditoScalarWhereInput[]
    id?: IntFilter<"Credito"> | number
    tipo?: EnumProdutoFilter<"Credito"> | $Enums.Produto
    valor?: FloatFilter<"Credito"> | number
    prestacao?: IntFilter<"Credito"> | number
    juro?: IntFilter<"Credito"> | number
    termino?: DateTimeFilter<"Credito"> | Date | string
    estado?: BoolFilter<"Credito"> | boolean
    pendencia?: BoolFilter<"Credito"> | boolean
    progresso?: EnumProgressoFilter<"Credito"> | $Enums.Progresso
    devedor_id?: IntFilter<"Credito"> | number
    createdAt?: DateTimeFilter<"Credito"> | Date | string
    updatedAt?: DateTimeFilter<"Credito"> | Date | string
  }

  export type MovelUpsertWithWhereUniqueWithoutDevedorInput = {
    where: MovelWhereUniqueInput
    update: XOR<MovelUpdateWithoutDevedorInput, MovelUncheckedUpdateWithoutDevedorInput>
    create: XOR<MovelCreateWithoutDevedorInput, MovelUncheckedCreateWithoutDevedorInput>
  }

  export type MovelUpdateWithWhereUniqueWithoutDevedorInput = {
    where: MovelWhereUniqueInput
    data: XOR<MovelUpdateWithoutDevedorInput, MovelUncheckedUpdateWithoutDevedorInput>
  }

  export type MovelUpdateManyWithWhereWithoutDevedorInput = {
    where: MovelScalarWhereInput
    data: XOR<MovelUpdateManyMutationInput, MovelUncheckedUpdateManyWithoutDevedorInput>
  }

  export type MovelScalarWhereInput = {
    AND?: MovelScalarWhereInput | MovelScalarWhereInput[]
    OR?: MovelScalarWhereInput[]
    NOT?: MovelScalarWhereInput | MovelScalarWhereInput[]
    id?: IntFilter<"Movel"> | number
    modelo?: EnumModeloFilter<"Movel"> | $Enums.Modelo
    matricula?: StringFilter<"Movel"> | string
    detalhes?: StringFilter<"Movel"> | string
    devedor_id?: IntFilter<"Movel"> | number
    estado?: BoolFilter<"Movel"> | boolean
    createdAt?: DateTimeFilter<"Movel"> | Date | string
    updatedAt?: DateTimeFilter<"Movel"> | Date | string
  }

  export type PagamentoUpsertWithWhereUniqueWithoutDevedorInput = {
    where: PagamentoWhereUniqueInput
    update: XOR<PagamentoUpdateWithoutDevedorInput, PagamentoUncheckedUpdateWithoutDevedorInput>
    create: XOR<PagamentoCreateWithoutDevedorInput, PagamentoUncheckedCreateWithoutDevedorInput>
  }

  export type PagamentoUpdateWithWhereUniqueWithoutDevedorInput = {
    where: PagamentoWhereUniqueInput
    data: XOR<PagamentoUpdateWithoutDevedorInput, PagamentoUncheckedUpdateWithoutDevedorInput>
  }

  export type PagamentoUpdateManyWithWhereWithoutDevedorInput = {
    where: PagamentoScalarWhereInput
    data: XOR<PagamentoUpdateManyMutationInput, PagamentoUncheckedUpdateManyWithoutDevedorInput>
  }

  export type PagamentoScalarWhereInput = {
    AND?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
    OR?: PagamentoScalarWhereInput[]
    NOT?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
    id?: IntFilter<"Pagamento"> | number
    valor?: FloatFilter<"Pagamento"> | number
    detalhe?: StringFilter<"Pagamento"> | string
    prestacao?: IntFilter<"Pagamento"> | number
    estado?: BoolFilter<"Pagamento"> | boolean
    pendencia?: BoolFilter<"Pagamento"> | boolean
    devedor_id?: IntFilter<"Pagamento"> | number
    createdAt?: DateTimeFilter<"Pagamento"> | Date | string
    updatedAt?: DateTimeFilter<"Pagamento"> | Date | string
  }

  export type DiversificacaoCreateWithoutInvestidorInput = {
    estado?: boolean
    taxa: number
    protencao: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    emprestimo: EmprestimoCreateNestedOneWithoutDiversificacaoInput
  }

  export type DiversificacaoUncheckedCreateWithoutInvestidorInput = {
    estado?: boolean
    emprestimo_id: number
    taxa: number
    protencao: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiversificacaoCreateOrConnectWithoutInvestidorInput = {
    where: DiversificacaoWhereUniqueInput
    create: XOR<DiversificacaoCreateWithoutInvestidorInput, DiversificacaoUncheckedCreateWithoutInvestidorInput>
  }

  export type DiversificacaoCreateManyInvestidorInputEnvelope = {
    data: DiversificacaoCreateManyInvestidorInput | DiversificacaoCreateManyInvestidorInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutInvestidorInput = {
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaCreateNestedOneWithoutUserInput
    documento?: DocumentoCreateNestedManyWithoutUserInput
    devedor?: DevedorCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoCreateNestedManyWithoutUserInput
    proponente?: ProponenteCreateNestedOneWithoutUserInput
    saque?: SaqueCreateNestedManyWithoutUserInput
    deposito?: DepositoCreateNestedManyWithoutUserInput
    carteira?: CarteiraCreateNestedOneWithoutUserInput
    papel?: PapelCreateNestedOneWithoutUserInput
    solidario?: SolidarioCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvestidorInput = {
    id?: number
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaUncheckedCreateNestedOneWithoutUserInput
    documento?: DocumentoUncheckedCreateNestedManyWithoutUserInput
    devedor?: DevedorUncheckedCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoUncheckedCreateNestedManyWithoutUserInput
    proponente?: ProponenteUncheckedCreateNestedOneWithoutUserInput
    saque?: SaqueUncheckedCreateNestedManyWithoutUserInput
    deposito?: DepositoUncheckedCreateNestedManyWithoutUserInput
    carteira?: CarteiraUncheckedCreateNestedOneWithoutUserInput
    papel?: PapelUncheckedCreateNestedOneWithoutUserInput
    solidario?: SolidarioUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvestidorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvestidorInput, UserUncheckedCreateWithoutInvestidorInput>
  }

  export type DiversificacaoUpsertWithWhereUniqueWithoutInvestidorInput = {
    where: DiversificacaoWhereUniqueInput
    update: XOR<DiversificacaoUpdateWithoutInvestidorInput, DiversificacaoUncheckedUpdateWithoutInvestidorInput>
    create: XOR<DiversificacaoCreateWithoutInvestidorInput, DiversificacaoUncheckedCreateWithoutInvestidorInput>
  }

  export type DiversificacaoUpdateWithWhereUniqueWithoutInvestidorInput = {
    where: DiversificacaoWhereUniqueInput
    data: XOR<DiversificacaoUpdateWithoutInvestidorInput, DiversificacaoUncheckedUpdateWithoutInvestidorInput>
  }

  export type DiversificacaoUpdateManyWithWhereWithoutInvestidorInput = {
    where: DiversificacaoScalarWhereInput
    data: XOR<DiversificacaoUpdateManyMutationInput, DiversificacaoUncheckedUpdateManyWithoutInvestidorInput>
  }

  export type DiversificacaoScalarWhereInput = {
    AND?: DiversificacaoScalarWhereInput | DiversificacaoScalarWhereInput[]
    OR?: DiversificacaoScalarWhereInput[]
    NOT?: DiversificacaoScalarWhereInput | DiversificacaoScalarWhereInput[]
    estado?: BoolFilter<"Diversificacao"> | boolean
    investidor_id?: IntFilter<"Diversificacao"> | number
    emprestimo_id?: IntFilter<"Diversificacao"> | number
    taxa?: IntFilter<"Diversificacao"> | number
    protencao?: BoolFilter<"Diversificacao"> | boolean
    createdAt?: DateTimeFilter<"Diversificacao"> | Date | string
    updatedAt?: DateTimeFilter<"Diversificacao"> | Date | string
  }

  export type UserUpsertWithoutInvestidorInput = {
    update: XOR<UserUpdateWithoutInvestidorInput, UserUncheckedUpdateWithoutInvestidorInput>
    create: XOR<UserCreateWithoutInvestidorInput, UserUncheckedCreateWithoutInvestidorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvestidorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvestidorInput, UserUncheckedUpdateWithoutInvestidorInput>
  }

  export type UserUpdateWithoutInvestidorInput = {
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUpdateOneWithoutUserNestedInput
    documento?: DocumentoUpdateManyWithoutUserNestedInput
    devedor?: DevedorUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUpdateOneWithoutUserNestedInput
    saque?: SaqueUpdateManyWithoutUserNestedInput
    deposito?: DepositoUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUpdateOneWithoutUserNestedInput
    papel?: PapelUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvestidorInput = {
    id?: IntFieldUpdateOperationsInput | number
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUncheckedUpdateOneWithoutUserNestedInput
    documento?: DocumentoUncheckedUpdateManyWithoutUserNestedInput
    devedor?: DevedorUncheckedUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUncheckedUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUncheckedUpdateOneWithoutUserNestedInput
    saque?: SaqueUncheckedUpdateManyWithoutUserNestedInput
    deposito?: DepositoUncheckedUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUncheckedUpdateOneWithoutUserNestedInput
    papel?: PapelUncheckedUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReclamacaoInput = {
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaCreateNestedOneWithoutUserInput
    documento?: DocumentoCreateNestedManyWithoutUserInput
    devedor?: DevedorCreateNestedOneWithoutUserInput
    investidor?: InvestidorCreateNestedOneWithoutUserInput
    proponente?: ProponenteCreateNestedOneWithoutUserInput
    saque?: SaqueCreateNestedManyWithoutUserInput
    deposito?: DepositoCreateNestedManyWithoutUserInput
    carteira?: CarteiraCreateNestedOneWithoutUserInput
    papel?: PapelCreateNestedOneWithoutUserInput
    solidario?: SolidarioCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReclamacaoInput = {
    id?: number
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaUncheckedCreateNestedOneWithoutUserInput
    documento?: DocumentoUncheckedCreateNestedManyWithoutUserInput
    devedor?: DevedorUncheckedCreateNestedOneWithoutUserInput
    investidor?: InvestidorUncheckedCreateNestedOneWithoutUserInput
    proponente?: ProponenteUncheckedCreateNestedOneWithoutUserInput
    saque?: SaqueUncheckedCreateNestedManyWithoutUserInput
    deposito?: DepositoUncheckedCreateNestedManyWithoutUserInput
    carteira?: CarteiraUncheckedCreateNestedOneWithoutUserInput
    papel?: PapelUncheckedCreateNestedOneWithoutUserInput
    solidario?: SolidarioUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReclamacaoInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReclamacaoInput, UserUncheckedCreateWithoutReclamacaoInput>
  }

  export type UserUpsertWithoutReclamacaoInput = {
    update: XOR<UserUpdateWithoutReclamacaoInput, UserUncheckedUpdateWithoutReclamacaoInput>
    create: XOR<UserCreateWithoutReclamacaoInput, UserUncheckedCreateWithoutReclamacaoInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReclamacaoInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReclamacaoInput, UserUncheckedUpdateWithoutReclamacaoInput>
  }

  export type UserUpdateWithoutReclamacaoInput = {
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUpdateOneWithoutUserNestedInput
    documento?: DocumentoUpdateManyWithoutUserNestedInput
    devedor?: DevedorUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUpdateOneWithoutUserNestedInput
    proponente?: ProponenteUpdateOneWithoutUserNestedInput
    saque?: SaqueUpdateManyWithoutUserNestedInput
    deposito?: DepositoUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUpdateOneWithoutUserNestedInput
    papel?: PapelUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReclamacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUncheckedUpdateOneWithoutUserNestedInput
    documento?: DocumentoUncheckedUpdateManyWithoutUserNestedInput
    devedor?: DevedorUncheckedUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUncheckedUpdateOneWithoutUserNestedInput
    proponente?: ProponenteUncheckedUpdateOneWithoutUserNestedInput
    saque?: SaqueUncheckedUpdateManyWithoutUserNestedInput
    deposito?: DepositoUncheckedUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUncheckedUpdateOneWithoutUserNestedInput
    papel?: PapelUncheckedUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmprestimoCreateWithoutProponenteInput = {
    valor: number
    juro_proponente: number
    taxa_investidor: number
    prestacao: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    createdAt?: Date | string
    updatedAt?: Date | string
    diversificacao?: DiversificacaoCreateNestedManyWithoutEmprestimoInput
    solidario?: EmprestimoSolidarioCreateNestedManyWithoutEmprestimoInput
  }

  export type EmprestimoUncheckedCreateWithoutProponenteInput = {
    id?: number
    valor: number
    juro_proponente: number
    taxa_investidor: number
    prestacao: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    createdAt?: Date | string
    updatedAt?: Date | string
    diversificacao?: DiversificacaoUncheckedCreateNestedManyWithoutEmprestimoInput
    solidario?: EmprestimoSolidarioUncheckedCreateNestedManyWithoutEmprestimoInput
  }

  export type EmprestimoCreateOrConnectWithoutProponenteInput = {
    where: EmprestimoWhereUniqueInput
    create: XOR<EmprestimoCreateWithoutProponenteInput, EmprestimoUncheckedCreateWithoutProponenteInput>
  }

  export type EmprestimoCreateManyProponenteInputEnvelope = {
    data: EmprestimoCreateManyProponenteInput | EmprestimoCreateManyProponenteInput[]
    skipDuplicates?: boolean
  }

  export type ReembolsoCreateWithoutProponenteInput = {
    valor: number
    prestacao: number
    estado?: boolean
    detalhe: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReembolsoUncheckedCreateWithoutProponenteInput = {
    id?: number
    valor: number
    prestacao: number
    estado?: boolean
    detalhe: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReembolsoCreateOrConnectWithoutProponenteInput = {
    where: ReembolsoWhereUniqueInput
    create: XOR<ReembolsoCreateWithoutProponenteInput, ReembolsoUncheckedCreateWithoutProponenteInput>
  }

  export type ReembolsoCreateManyProponenteInputEnvelope = {
    data: ReembolsoCreateManyProponenteInput | ReembolsoCreateManyProponenteInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutProponenteInput = {
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaCreateNestedOneWithoutUserInput
    documento?: DocumentoCreateNestedManyWithoutUserInput
    devedor?: DevedorCreateNestedOneWithoutUserInput
    investidor?: InvestidorCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoCreateNestedManyWithoutUserInput
    saque?: SaqueCreateNestedManyWithoutUserInput
    deposito?: DepositoCreateNestedManyWithoutUserInput
    carteira?: CarteiraCreateNestedOneWithoutUserInput
    papel?: PapelCreateNestedOneWithoutUserInput
    solidario?: SolidarioCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProponenteInput = {
    id?: number
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaUncheckedCreateNestedOneWithoutUserInput
    documento?: DocumentoUncheckedCreateNestedManyWithoutUserInput
    devedor?: DevedorUncheckedCreateNestedOneWithoutUserInput
    investidor?: InvestidorUncheckedCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoUncheckedCreateNestedManyWithoutUserInput
    saque?: SaqueUncheckedCreateNestedManyWithoutUserInput
    deposito?: DepositoUncheckedCreateNestedManyWithoutUserInput
    carteira?: CarteiraUncheckedCreateNestedOneWithoutUserInput
    papel?: PapelUncheckedCreateNestedOneWithoutUserInput
    solidario?: SolidarioUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProponenteInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProponenteInput, UserUncheckedCreateWithoutProponenteInput>
  }

  export type EmprestimoUpsertWithWhereUniqueWithoutProponenteInput = {
    where: EmprestimoWhereUniqueInput
    update: XOR<EmprestimoUpdateWithoutProponenteInput, EmprestimoUncheckedUpdateWithoutProponenteInput>
    create: XOR<EmprestimoCreateWithoutProponenteInput, EmprestimoUncheckedCreateWithoutProponenteInput>
  }

  export type EmprestimoUpdateWithWhereUniqueWithoutProponenteInput = {
    where: EmprestimoWhereUniqueInput
    data: XOR<EmprestimoUpdateWithoutProponenteInput, EmprestimoUncheckedUpdateWithoutProponenteInput>
  }

  export type EmprestimoUpdateManyWithWhereWithoutProponenteInput = {
    where: EmprestimoScalarWhereInput
    data: XOR<EmprestimoUpdateManyMutationInput, EmprestimoUncheckedUpdateManyWithoutProponenteInput>
  }

  export type EmprestimoScalarWhereInput = {
    AND?: EmprestimoScalarWhereInput | EmprestimoScalarWhereInput[]
    OR?: EmprestimoScalarWhereInput[]
    NOT?: EmprestimoScalarWhereInput | EmprestimoScalarWhereInput[]
    id?: IntFilter<"Emprestimo"> | number
    valor?: FloatFilter<"Emprestimo"> | number
    juro_proponente?: IntFilter<"Emprestimo"> | number
    taxa_investidor?: IntFilter<"Emprestimo"> | number
    prestacao?: IntFilter<"Emprestimo"> | number
    termino?: DateTimeFilter<"Emprestimo"> | Date | string
    estado?: BoolFilter<"Emprestimo"> | boolean
    pendencia?: BoolFilter<"Emprestimo"> | boolean
    progresso?: EnumProgressoFilter<"Emprestimo"> | $Enums.Progresso
    proponente_id?: IntFilter<"Emprestimo"> | number
    createdAt?: DateTimeFilter<"Emprestimo"> | Date | string
    updatedAt?: DateTimeFilter<"Emprestimo"> | Date | string
  }

  export type ReembolsoUpsertWithWhereUniqueWithoutProponenteInput = {
    where: ReembolsoWhereUniqueInput
    update: XOR<ReembolsoUpdateWithoutProponenteInput, ReembolsoUncheckedUpdateWithoutProponenteInput>
    create: XOR<ReembolsoCreateWithoutProponenteInput, ReembolsoUncheckedCreateWithoutProponenteInput>
  }

  export type ReembolsoUpdateWithWhereUniqueWithoutProponenteInput = {
    where: ReembolsoWhereUniqueInput
    data: XOR<ReembolsoUpdateWithoutProponenteInput, ReembolsoUncheckedUpdateWithoutProponenteInput>
  }

  export type ReembolsoUpdateManyWithWhereWithoutProponenteInput = {
    where: ReembolsoScalarWhereInput
    data: XOR<ReembolsoUpdateManyMutationInput, ReembolsoUncheckedUpdateManyWithoutProponenteInput>
  }

  export type ReembolsoScalarWhereInput = {
    AND?: ReembolsoScalarWhereInput | ReembolsoScalarWhereInput[]
    OR?: ReembolsoScalarWhereInput[]
    NOT?: ReembolsoScalarWhereInput | ReembolsoScalarWhereInput[]
    id?: IntFilter<"Reembolso"> | number
    valor?: FloatFilter<"Reembolso"> | number
    prestacao?: IntFilter<"Reembolso"> | number
    estado?: BoolFilter<"Reembolso"> | boolean
    detalhe?: StringFilter<"Reembolso"> | string
    proponente_id?: IntFilter<"Reembolso"> | number
    createdAt?: DateTimeFilter<"Reembolso"> | Date | string
    updatedAt?: DateTimeFilter<"Reembolso"> | Date | string
  }

  export type UserUpsertWithoutProponenteInput = {
    update: XOR<UserUpdateWithoutProponenteInput, UserUncheckedUpdateWithoutProponenteInput>
    create: XOR<UserCreateWithoutProponenteInput, UserUncheckedCreateWithoutProponenteInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProponenteInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProponenteInput, UserUncheckedUpdateWithoutProponenteInput>
  }

  export type UserUpdateWithoutProponenteInput = {
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUpdateOneWithoutUserNestedInput
    documento?: DocumentoUpdateManyWithoutUserNestedInput
    devedor?: DevedorUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUpdateManyWithoutUserNestedInput
    saque?: SaqueUpdateManyWithoutUserNestedInput
    deposito?: DepositoUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUpdateOneWithoutUserNestedInput
    papel?: PapelUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProponenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUncheckedUpdateOneWithoutUserNestedInput
    documento?: DocumentoUncheckedUpdateManyWithoutUserNestedInput
    devedor?: DevedorUncheckedUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUncheckedUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUncheckedUpdateManyWithoutUserNestedInput
    saque?: SaqueUncheckedUpdateManyWithoutUserNestedInput
    deposito?: DepositoUncheckedUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUncheckedUpdateOneWithoutUserNestedInput
    papel?: PapelUncheckedUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PessoaCreateWithoutSolidarioInput = {
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado?: boolean
    nivel_instrucao: string
    data_nascimento: Date | string
    user: UserCreateNestedOneWithoutPessoaInput
    emprego: EmpregoCreateNestedOneWithoutPessoaInput
    residencia: ResidenciaCreateNestedOneWithoutPessoaInput
    conjugue?: ConjugueCreateNestedOneWithoutPessoaInput
    conta?: ContaCreateNestedOneWithoutPessoaInput
  }

  export type PessoaUncheckedCreateWithoutSolidarioInput = {
    id?: number
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado?: boolean
    nivel_instrucao: string
    data_nascimento: Date | string
    user_id: number
    emprego_id: number
    residencia_id: number
    conjugue?: ConjugueUncheckedCreateNestedOneWithoutPessoaInput
    conta?: ContaUncheckedCreateNestedOneWithoutPessoaInput
  }

  export type PessoaCreateOrConnectWithoutSolidarioInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutSolidarioInput, PessoaUncheckedCreateWithoutSolidarioInput>
  }

  export type EmprestimoSolidarioCreateWithoutSolidarioInput = {
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    emprestimo: EmprestimoCreateNestedOneWithoutSolidarioInput
  }

  export type EmprestimoSolidarioUncheckedCreateWithoutSolidarioInput = {
    estado?: boolean
    emprestimo_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmprestimoSolidarioCreateOrConnectWithoutSolidarioInput = {
    where: EmprestimoSolidarioWhereUniqueInput
    create: XOR<EmprestimoSolidarioCreateWithoutSolidarioInput, EmprestimoSolidarioUncheckedCreateWithoutSolidarioInput>
  }

  export type EmprestimoSolidarioCreateManySolidarioInputEnvelope = {
    data: EmprestimoSolidarioCreateManySolidarioInput | EmprestimoSolidarioCreateManySolidarioInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutSolidarioInput = {
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaCreateNestedOneWithoutUserInput
    documento?: DocumentoCreateNestedManyWithoutUserInput
    devedor?: DevedorCreateNestedOneWithoutUserInput
    investidor?: InvestidorCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoCreateNestedManyWithoutUserInput
    proponente?: ProponenteCreateNestedOneWithoutUserInput
    saque?: SaqueCreateNestedManyWithoutUserInput
    deposito?: DepositoCreateNestedManyWithoutUserInput
    carteira?: CarteiraCreateNestedOneWithoutUserInput
    papel?: PapelCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSolidarioInput = {
    id?: number
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaUncheckedCreateNestedOneWithoutUserInput
    documento?: DocumentoUncheckedCreateNestedManyWithoutUserInput
    devedor?: DevedorUncheckedCreateNestedOneWithoutUserInput
    investidor?: InvestidorUncheckedCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoUncheckedCreateNestedManyWithoutUserInput
    proponente?: ProponenteUncheckedCreateNestedOneWithoutUserInput
    saque?: SaqueUncheckedCreateNestedManyWithoutUserInput
    deposito?: DepositoUncheckedCreateNestedManyWithoutUserInput
    carteira?: CarteiraUncheckedCreateNestedOneWithoutUserInput
    papel?: PapelUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSolidarioInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSolidarioInput, UserUncheckedCreateWithoutSolidarioInput>
  }

  export type CreditoSolidarioCreateWithoutSolidarioInput = {
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    credito: CreditoCreateNestedOneWithoutSolidarioInput
  }

  export type CreditoSolidarioUncheckedCreateWithoutSolidarioInput = {
    estado?: boolean
    credito_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditoSolidarioCreateOrConnectWithoutSolidarioInput = {
    where: CreditoSolidarioWhereUniqueInput
    create: XOR<CreditoSolidarioCreateWithoutSolidarioInput, CreditoSolidarioUncheckedCreateWithoutSolidarioInput>
  }

  export type CreditoSolidarioCreateManySolidarioInputEnvelope = {
    data: CreditoSolidarioCreateManySolidarioInput | CreditoSolidarioCreateManySolidarioInput[]
    skipDuplicates?: boolean
  }

  export type PessoaUpsertWithoutSolidarioInput = {
    update: XOR<PessoaUpdateWithoutSolidarioInput, PessoaUncheckedUpdateWithoutSolidarioInput>
    create: XOR<PessoaCreateWithoutSolidarioInput, PessoaUncheckedCreateWithoutSolidarioInput>
    where?: PessoaWhereInput
  }

  export type PessoaUpdateToOneWithWhereWithoutSolidarioInput = {
    where?: PessoaWhereInput
    data: XOR<PessoaUpdateWithoutSolidarioInput, PessoaUncheckedUpdateWithoutSolidarioInput>
  }

  export type PessoaUpdateWithoutSolidarioInput = {
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPessoaNestedInput
    emprego?: EmpregoUpdateOneRequiredWithoutPessoaNestedInput
    residencia?: ResidenciaUpdateOneRequiredWithoutPessoaNestedInput
    conjugue?: ConjugueUpdateOneWithoutPessoaNestedInput
    conta?: ContaUpdateOneWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateWithoutSolidarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    emprego_id?: IntFieldUpdateOperationsInput | number
    residencia_id?: IntFieldUpdateOperationsInput | number
    conjugue?: ConjugueUncheckedUpdateOneWithoutPessoaNestedInput
    conta?: ContaUncheckedUpdateOneWithoutPessoaNestedInput
  }

  export type EmprestimoSolidarioUpsertWithWhereUniqueWithoutSolidarioInput = {
    where: EmprestimoSolidarioWhereUniqueInput
    update: XOR<EmprestimoSolidarioUpdateWithoutSolidarioInput, EmprestimoSolidarioUncheckedUpdateWithoutSolidarioInput>
    create: XOR<EmprestimoSolidarioCreateWithoutSolidarioInput, EmprestimoSolidarioUncheckedCreateWithoutSolidarioInput>
  }

  export type EmprestimoSolidarioUpdateWithWhereUniqueWithoutSolidarioInput = {
    where: EmprestimoSolidarioWhereUniqueInput
    data: XOR<EmprestimoSolidarioUpdateWithoutSolidarioInput, EmprestimoSolidarioUncheckedUpdateWithoutSolidarioInput>
  }

  export type EmprestimoSolidarioUpdateManyWithWhereWithoutSolidarioInput = {
    where: EmprestimoSolidarioScalarWhereInput
    data: XOR<EmprestimoSolidarioUpdateManyMutationInput, EmprestimoSolidarioUncheckedUpdateManyWithoutSolidarioInput>
  }

  export type EmprestimoSolidarioScalarWhereInput = {
    AND?: EmprestimoSolidarioScalarWhereInput | EmprestimoSolidarioScalarWhereInput[]
    OR?: EmprestimoSolidarioScalarWhereInput[]
    NOT?: EmprestimoSolidarioScalarWhereInput | EmprestimoSolidarioScalarWhereInput[]
    estado?: BoolFilter<"EmprestimoSolidario"> | boolean
    solidario_id?: IntFilter<"EmprestimoSolidario"> | number
    emprestimo_id?: IntFilter<"EmprestimoSolidario"> | number
    createdAt?: DateTimeFilter<"EmprestimoSolidario"> | Date | string
    updatedAt?: DateTimeFilter<"EmprestimoSolidario"> | Date | string
  }

  export type UserUpsertWithoutSolidarioInput = {
    update: XOR<UserUpdateWithoutSolidarioInput, UserUncheckedUpdateWithoutSolidarioInput>
    create: XOR<UserCreateWithoutSolidarioInput, UserUncheckedCreateWithoutSolidarioInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSolidarioInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSolidarioInput, UserUncheckedUpdateWithoutSolidarioInput>
  }

  export type UserUpdateWithoutSolidarioInput = {
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUpdateOneWithoutUserNestedInput
    documento?: DocumentoUpdateManyWithoutUserNestedInput
    devedor?: DevedorUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUpdateOneWithoutUserNestedInput
    saque?: SaqueUpdateManyWithoutUserNestedInput
    deposito?: DepositoUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUpdateOneWithoutUserNestedInput
    papel?: PapelUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSolidarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUncheckedUpdateOneWithoutUserNestedInput
    documento?: DocumentoUncheckedUpdateManyWithoutUserNestedInput
    devedor?: DevedorUncheckedUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUncheckedUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUncheckedUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUncheckedUpdateOneWithoutUserNestedInput
    saque?: SaqueUncheckedUpdateManyWithoutUserNestedInput
    deposito?: DepositoUncheckedUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUncheckedUpdateOneWithoutUserNestedInput
    papel?: PapelUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CreditoSolidarioUpsertWithWhereUniqueWithoutSolidarioInput = {
    where: CreditoSolidarioWhereUniqueInput
    update: XOR<CreditoSolidarioUpdateWithoutSolidarioInput, CreditoSolidarioUncheckedUpdateWithoutSolidarioInput>
    create: XOR<CreditoSolidarioCreateWithoutSolidarioInput, CreditoSolidarioUncheckedCreateWithoutSolidarioInput>
  }

  export type CreditoSolidarioUpdateWithWhereUniqueWithoutSolidarioInput = {
    where: CreditoSolidarioWhereUniqueInput
    data: XOR<CreditoSolidarioUpdateWithoutSolidarioInput, CreditoSolidarioUncheckedUpdateWithoutSolidarioInput>
  }

  export type CreditoSolidarioUpdateManyWithWhereWithoutSolidarioInput = {
    where: CreditoSolidarioScalarWhereInput
    data: XOR<CreditoSolidarioUpdateManyMutationInput, CreditoSolidarioUncheckedUpdateManyWithoutSolidarioInput>
  }

  export type CreditoSolidarioScalarWhereInput = {
    AND?: CreditoSolidarioScalarWhereInput | CreditoSolidarioScalarWhereInput[]
    OR?: CreditoSolidarioScalarWhereInput[]
    NOT?: CreditoSolidarioScalarWhereInput | CreditoSolidarioScalarWhereInput[]
    estado?: BoolFilter<"CreditoSolidario"> | boolean
    solidario_id?: IntFilter<"CreditoSolidario"> | number
    credito_id?: IntFilter<"CreditoSolidario"> | number
    createdAt?: DateTimeFilter<"CreditoSolidario"> | Date | string
    updatedAt?: DateTimeFilter<"CreditoSolidario"> | Date | string
  }

  export type DevedorCreateWithoutMovelInput = {
    solicitacao?: number
    adimplencia?: number
    inadimplencia?: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDevedorInput
    credito?: CreditoCreateNestedManyWithoutDevedorInput
    pagamento?: PagamentoCreateNestedManyWithoutDevedorInput
  }

  export type DevedorUncheckedCreateWithoutMovelInput = {
    id?: number
    user_id: number
    solicitacao?: number
    adimplencia?: number
    inadimplencia?: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    credito?: CreditoUncheckedCreateNestedManyWithoutDevedorInput
    pagamento?: PagamentoUncheckedCreateNestedManyWithoutDevedorInput
  }

  export type DevedorCreateOrConnectWithoutMovelInput = {
    where: DevedorWhereUniqueInput
    create: XOR<DevedorCreateWithoutMovelInput, DevedorUncheckedCreateWithoutMovelInput>
  }

  export type DevedorUpsertWithoutMovelInput = {
    update: XOR<DevedorUpdateWithoutMovelInput, DevedorUncheckedUpdateWithoutMovelInput>
    create: XOR<DevedorCreateWithoutMovelInput, DevedorUncheckedCreateWithoutMovelInput>
    where?: DevedorWhereInput
  }

  export type DevedorUpdateToOneWithWhereWithoutMovelInput = {
    where?: DevedorWhereInput
    data: XOR<DevedorUpdateWithoutMovelInput, DevedorUncheckedUpdateWithoutMovelInput>
  }

  export type DevedorUpdateWithoutMovelInput = {
    solicitacao?: IntFieldUpdateOperationsInput | number
    adimplencia?: IntFieldUpdateOperationsInput | number
    inadimplencia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevedorNestedInput
    credito?: CreditoUpdateManyWithoutDevedorNestedInput
    pagamento?: PagamentoUpdateManyWithoutDevedorNestedInput
  }

  export type DevedorUncheckedUpdateWithoutMovelInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    solicitacao?: IntFieldUpdateOperationsInput | number
    adimplencia?: IntFieldUpdateOperationsInput | number
    inadimplencia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credito?: CreditoUncheckedUpdateManyWithoutDevedorNestedInput
    pagamento?: PagamentoUncheckedUpdateManyWithoutDevedorNestedInput
  }

  export type CreditoSolidarioCreateWithoutCreditoInput = {
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    solidario: SolidarioCreateNestedOneWithoutCreditoInput
  }

  export type CreditoSolidarioUncheckedCreateWithoutCreditoInput = {
    estado?: boolean
    solidario_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditoSolidarioCreateOrConnectWithoutCreditoInput = {
    where: CreditoSolidarioWhereUniqueInput
    create: XOR<CreditoSolidarioCreateWithoutCreditoInput, CreditoSolidarioUncheckedCreateWithoutCreditoInput>
  }

  export type CreditoSolidarioCreateManyCreditoInputEnvelope = {
    data: CreditoSolidarioCreateManyCreditoInput | CreditoSolidarioCreateManyCreditoInput[]
    skipDuplicates?: boolean
  }

  export type DevedorCreateWithoutCreditoInput = {
    solicitacao?: number
    adimplencia?: number
    inadimplencia?: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDevedorInput
    movel?: MovelCreateNestedManyWithoutDevedorInput
    pagamento?: PagamentoCreateNestedManyWithoutDevedorInput
  }

  export type DevedorUncheckedCreateWithoutCreditoInput = {
    id?: number
    user_id: number
    solicitacao?: number
    adimplencia?: number
    inadimplencia?: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    movel?: MovelUncheckedCreateNestedManyWithoutDevedorInput
    pagamento?: PagamentoUncheckedCreateNestedManyWithoutDevedorInput
  }

  export type DevedorCreateOrConnectWithoutCreditoInput = {
    where: DevedorWhereUniqueInput
    create: XOR<DevedorCreateWithoutCreditoInput, DevedorUncheckedCreateWithoutCreditoInput>
  }

  export type CreditoSolidarioUpsertWithWhereUniqueWithoutCreditoInput = {
    where: CreditoSolidarioWhereUniqueInput
    update: XOR<CreditoSolidarioUpdateWithoutCreditoInput, CreditoSolidarioUncheckedUpdateWithoutCreditoInput>
    create: XOR<CreditoSolidarioCreateWithoutCreditoInput, CreditoSolidarioUncheckedCreateWithoutCreditoInput>
  }

  export type CreditoSolidarioUpdateWithWhereUniqueWithoutCreditoInput = {
    where: CreditoSolidarioWhereUniqueInput
    data: XOR<CreditoSolidarioUpdateWithoutCreditoInput, CreditoSolidarioUncheckedUpdateWithoutCreditoInput>
  }

  export type CreditoSolidarioUpdateManyWithWhereWithoutCreditoInput = {
    where: CreditoSolidarioScalarWhereInput
    data: XOR<CreditoSolidarioUpdateManyMutationInput, CreditoSolidarioUncheckedUpdateManyWithoutCreditoInput>
  }

  export type DevedorUpsertWithoutCreditoInput = {
    update: XOR<DevedorUpdateWithoutCreditoInput, DevedorUncheckedUpdateWithoutCreditoInput>
    create: XOR<DevedorCreateWithoutCreditoInput, DevedorUncheckedCreateWithoutCreditoInput>
    where?: DevedorWhereInput
  }

  export type DevedorUpdateToOneWithWhereWithoutCreditoInput = {
    where?: DevedorWhereInput
    data: XOR<DevedorUpdateWithoutCreditoInput, DevedorUncheckedUpdateWithoutCreditoInput>
  }

  export type DevedorUpdateWithoutCreditoInput = {
    solicitacao?: IntFieldUpdateOperationsInput | number
    adimplencia?: IntFieldUpdateOperationsInput | number
    inadimplencia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevedorNestedInput
    movel?: MovelUpdateManyWithoutDevedorNestedInput
    pagamento?: PagamentoUpdateManyWithoutDevedorNestedInput
  }

  export type DevedorUncheckedUpdateWithoutCreditoInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    solicitacao?: IntFieldUpdateOperationsInput | number
    adimplencia?: IntFieldUpdateOperationsInput | number
    inadimplencia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movel?: MovelUncheckedUpdateManyWithoutDevedorNestedInput
    pagamento?: PagamentoUncheckedUpdateManyWithoutDevedorNestedInput
  }

  export type DiversificacaoCreateWithoutEmprestimoInput = {
    estado?: boolean
    taxa: number
    protencao: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    investidor: InvestidorCreateNestedOneWithoutDiversificacaoInput
  }

  export type DiversificacaoUncheckedCreateWithoutEmprestimoInput = {
    estado?: boolean
    investidor_id: number
    taxa: number
    protencao: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiversificacaoCreateOrConnectWithoutEmprestimoInput = {
    where: DiversificacaoWhereUniqueInput
    create: XOR<DiversificacaoCreateWithoutEmprestimoInput, DiversificacaoUncheckedCreateWithoutEmprestimoInput>
  }

  export type DiversificacaoCreateManyEmprestimoInputEnvelope = {
    data: DiversificacaoCreateManyEmprestimoInput | DiversificacaoCreateManyEmprestimoInput[]
    skipDuplicates?: boolean
  }

  export type EmprestimoSolidarioCreateWithoutEmprestimoInput = {
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    solidario: SolidarioCreateNestedOneWithoutEmprestimoInput
  }

  export type EmprestimoSolidarioUncheckedCreateWithoutEmprestimoInput = {
    estado?: boolean
    solidario_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmprestimoSolidarioCreateOrConnectWithoutEmprestimoInput = {
    where: EmprestimoSolidarioWhereUniqueInput
    create: XOR<EmprestimoSolidarioCreateWithoutEmprestimoInput, EmprestimoSolidarioUncheckedCreateWithoutEmprestimoInput>
  }

  export type EmprestimoSolidarioCreateManyEmprestimoInputEnvelope = {
    data: EmprestimoSolidarioCreateManyEmprestimoInput | EmprestimoSolidarioCreateManyEmprestimoInput[]
    skipDuplicates?: boolean
  }

  export type ProponenteCreateWithoutEmprestimoInput = {
    solicitacao: number
    reembolsar: number
    satisfeitos: number
    insatisfeitos: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reembolso?: ReembolsoCreateNestedManyWithoutProponenteInput
    user: UserCreateNestedOneWithoutProponenteInput
  }

  export type ProponenteUncheckedCreateWithoutEmprestimoInput = {
    id?: number
    solicitacao: number
    reembolsar: number
    satisfeitos: number
    insatisfeitos: number
    estado?: boolean
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reembolso?: ReembolsoUncheckedCreateNestedManyWithoutProponenteInput
  }

  export type ProponenteCreateOrConnectWithoutEmprestimoInput = {
    where: ProponenteWhereUniqueInput
    create: XOR<ProponenteCreateWithoutEmprestimoInput, ProponenteUncheckedCreateWithoutEmprestimoInput>
  }

  export type DiversificacaoUpsertWithWhereUniqueWithoutEmprestimoInput = {
    where: DiversificacaoWhereUniqueInput
    update: XOR<DiversificacaoUpdateWithoutEmprestimoInput, DiversificacaoUncheckedUpdateWithoutEmprestimoInput>
    create: XOR<DiversificacaoCreateWithoutEmprestimoInput, DiversificacaoUncheckedCreateWithoutEmprestimoInput>
  }

  export type DiversificacaoUpdateWithWhereUniqueWithoutEmprestimoInput = {
    where: DiversificacaoWhereUniqueInput
    data: XOR<DiversificacaoUpdateWithoutEmprestimoInput, DiversificacaoUncheckedUpdateWithoutEmprestimoInput>
  }

  export type DiversificacaoUpdateManyWithWhereWithoutEmprestimoInput = {
    where: DiversificacaoScalarWhereInput
    data: XOR<DiversificacaoUpdateManyMutationInput, DiversificacaoUncheckedUpdateManyWithoutEmprestimoInput>
  }

  export type EmprestimoSolidarioUpsertWithWhereUniqueWithoutEmprestimoInput = {
    where: EmprestimoSolidarioWhereUniqueInput
    update: XOR<EmprestimoSolidarioUpdateWithoutEmprestimoInput, EmprestimoSolidarioUncheckedUpdateWithoutEmprestimoInput>
    create: XOR<EmprestimoSolidarioCreateWithoutEmprestimoInput, EmprestimoSolidarioUncheckedCreateWithoutEmprestimoInput>
  }

  export type EmprestimoSolidarioUpdateWithWhereUniqueWithoutEmprestimoInput = {
    where: EmprestimoSolidarioWhereUniqueInput
    data: XOR<EmprestimoSolidarioUpdateWithoutEmprestimoInput, EmprestimoSolidarioUncheckedUpdateWithoutEmprestimoInput>
  }

  export type EmprestimoSolidarioUpdateManyWithWhereWithoutEmprestimoInput = {
    where: EmprestimoSolidarioScalarWhereInput
    data: XOR<EmprestimoSolidarioUpdateManyMutationInput, EmprestimoSolidarioUncheckedUpdateManyWithoutEmprestimoInput>
  }

  export type ProponenteUpsertWithoutEmprestimoInput = {
    update: XOR<ProponenteUpdateWithoutEmprestimoInput, ProponenteUncheckedUpdateWithoutEmprestimoInput>
    create: XOR<ProponenteCreateWithoutEmprestimoInput, ProponenteUncheckedCreateWithoutEmprestimoInput>
    where?: ProponenteWhereInput
  }

  export type ProponenteUpdateToOneWithWhereWithoutEmprestimoInput = {
    where?: ProponenteWhereInput
    data: XOR<ProponenteUpdateWithoutEmprestimoInput, ProponenteUncheckedUpdateWithoutEmprestimoInput>
  }

  export type ProponenteUpdateWithoutEmprestimoInput = {
    solicitacao?: IntFieldUpdateOperationsInput | number
    reembolsar?: IntFieldUpdateOperationsInput | number
    satisfeitos?: IntFieldUpdateOperationsInput | number
    insatisfeitos?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reembolso?: ReembolsoUpdateManyWithoutProponenteNestedInput
    user?: UserUpdateOneRequiredWithoutProponenteNestedInput
  }

  export type ProponenteUncheckedUpdateWithoutEmprestimoInput = {
    id?: IntFieldUpdateOperationsInput | number
    solicitacao?: IntFieldUpdateOperationsInput | number
    reembolsar?: IntFieldUpdateOperationsInput | number
    satisfeitos?: IntFieldUpdateOperationsInput | number
    insatisfeitos?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reembolso?: ReembolsoUncheckedUpdateManyWithoutProponenteNestedInput
  }

  export type SolidarioCreateWithoutEmprestimoInput = {
    tipo: $Enums.Aval
    parentesco: $Enums.Parentesco
    taxa: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pessoa: PessoaCreateNestedOneWithoutSolidarioInput
    user: UserCreateNestedOneWithoutSolidarioInput
    credito?: CreditoSolidarioCreateNestedManyWithoutSolidarioInput
  }

  export type SolidarioUncheckedCreateWithoutEmprestimoInput = {
    id?: number
    tipo: $Enums.Aval
    parentesco: $Enums.Parentesco
    taxa: number
    estado?: boolean
    pessoa_id: number
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    credito?: CreditoSolidarioUncheckedCreateNestedManyWithoutSolidarioInput
  }

  export type SolidarioCreateOrConnectWithoutEmprestimoInput = {
    where: SolidarioWhereUniqueInput
    create: XOR<SolidarioCreateWithoutEmprestimoInput, SolidarioUncheckedCreateWithoutEmprestimoInput>
  }

  export type EmprestimoCreateWithoutSolidarioInput = {
    valor: number
    juro_proponente: number
    taxa_investidor: number
    prestacao: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    createdAt?: Date | string
    updatedAt?: Date | string
    diversificacao?: DiversificacaoCreateNestedManyWithoutEmprestimoInput
    proponente: ProponenteCreateNestedOneWithoutEmprestimoInput
  }

  export type EmprestimoUncheckedCreateWithoutSolidarioInput = {
    id?: number
    valor: number
    juro_proponente: number
    taxa_investidor: number
    prestacao: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    proponente_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    diversificacao?: DiversificacaoUncheckedCreateNestedManyWithoutEmprestimoInput
  }

  export type EmprestimoCreateOrConnectWithoutSolidarioInput = {
    where: EmprestimoWhereUniqueInput
    create: XOR<EmprestimoCreateWithoutSolidarioInput, EmprestimoUncheckedCreateWithoutSolidarioInput>
  }

  export type SolidarioUpsertWithoutEmprestimoInput = {
    update: XOR<SolidarioUpdateWithoutEmprestimoInput, SolidarioUncheckedUpdateWithoutEmprestimoInput>
    create: XOR<SolidarioCreateWithoutEmprestimoInput, SolidarioUncheckedCreateWithoutEmprestimoInput>
    where?: SolidarioWhereInput
  }

  export type SolidarioUpdateToOneWithWhereWithoutEmprestimoInput = {
    where?: SolidarioWhereInput
    data: XOR<SolidarioUpdateWithoutEmprestimoInput, SolidarioUncheckedUpdateWithoutEmprestimoInput>
  }

  export type SolidarioUpdateWithoutEmprestimoInput = {
    tipo?: EnumAvalFieldUpdateOperationsInput | $Enums.Aval
    parentesco?: EnumParentescoFieldUpdateOperationsInput | $Enums.Parentesco
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pessoa?: PessoaUpdateOneRequiredWithoutSolidarioNestedInput
    user?: UserUpdateOneRequiredWithoutSolidarioNestedInput
    credito?: CreditoSolidarioUpdateManyWithoutSolidarioNestedInput
  }

  export type SolidarioUncheckedUpdateWithoutEmprestimoInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumAvalFieldUpdateOperationsInput | $Enums.Aval
    parentesco?: EnumParentescoFieldUpdateOperationsInput | $Enums.Parentesco
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credito?: CreditoSolidarioUncheckedUpdateManyWithoutSolidarioNestedInput
  }

  export type EmprestimoUpsertWithoutSolidarioInput = {
    update: XOR<EmprestimoUpdateWithoutSolidarioInput, EmprestimoUncheckedUpdateWithoutSolidarioInput>
    create: XOR<EmprestimoCreateWithoutSolidarioInput, EmprestimoUncheckedCreateWithoutSolidarioInput>
    where?: EmprestimoWhereInput
  }

  export type EmprestimoUpdateToOneWithWhereWithoutSolidarioInput = {
    where?: EmprestimoWhereInput
    data: XOR<EmprestimoUpdateWithoutSolidarioInput, EmprestimoUncheckedUpdateWithoutSolidarioInput>
  }

  export type EmprestimoUpdateWithoutSolidarioInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    juro_proponente?: IntFieldUpdateOperationsInput | number
    taxa_investidor?: IntFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    diversificacao?: DiversificacaoUpdateManyWithoutEmprestimoNestedInput
    proponente?: ProponenteUpdateOneRequiredWithoutEmprestimoNestedInput
  }

  export type EmprestimoUncheckedUpdateWithoutSolidarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    juro_proponente?: IntFieldUpdateOperationsInput | number
    taxa_investidor?: IntFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    proponente_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    diversificacao?: DiversificacaoUncheckedUpdateManyWithoutEmprestimoNestedInput
  }

  export type SolidarioCreateWithoutCreditoInput = {
    tipo: $Enums.Aval
    parentesco: $Enums.Parentesco
    taxa: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pessoa: PessoaCreateNestedOneWithoutSolidarioInput
    emprestimo?: EmprestimoSolidarioCreateNestedManyWithoutSolidarioInput
    user: UserCreateNestedOneWithoutSolidarioInput
  }

  export type SolidarioUncheckedCreateWithoutCreditoInput = {
    id?: number
    tipo: $Enums.Aval
    parentesco: $Enums.Parentesco
    taxa: number
    estado?: boolean
    pessoa_id: number
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emprestimo?: EmprestimoSolidarioUncheckedCreateNestedManyWithoutSolidarioInput
  }

  export type SolidarioCreateOrConnectWithoutCreditoInput = {
    where: SolidarioWhereUniqueInput
    create: XOR<SolidarioCreateWithoutCreditoInput, SolidarioUncheckedCreateWithoutCreditoInput>
  }

  export type CreditoCreateWithoutSolidarioInput = {
    tipo: $Enums.Produto
    valor: number
    prestacao: number
    juro: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    createdAt?: Date | string
    updatedAt?: Date | string
    devedor: DevedorCreateNestedOneWithoutCreditoInput
  }

  export type CreditoUncheckedCreateWithoutSolidarioInput = {
    id?: number
    tipo: $Enums.Produto
    valor: number
    prestacao: number
    juro: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    devedor_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditoCreateOrConnectWithoutSolidarioInput = {
    where: CreditoWhereUniqueInput
    create: XOR<CreditoCreateWithoutSolidarioInput, CreditoUncheckedCreateWithoutSolidarioInput>
  }

  export type SolidarioUpsertWithoutCreditoInput = {
    update: XOR<SolidarioUpdateWithoutCreditoInput, SolidarioUncheckedUpdateWithoutCreditoInput>
    create: XOR<SolidarioCreateWithoutCreditoInput, SolidarioUncheckedCreateWithoutCreditoInput>
    where?: SolidarioWhereInput
  }

  export type SolidarioUpdateToOneWithWhereWithoutCreditoInput = {
    where?: SolidarioWhereInput
    data: XOR<SolidarioUpdateWithoutCreditoInput, SolidarioUncheckedUpdateWithoutCreditoInput>
  }

  export type SolidarioUpdateWithoutCreditoInput = {
    tipo?: EnumAvalFieldUpdateOperationsInput | $Enums.Aval
    parentesco?: EnumParentescoFieldUpdateOperationsInput | $Enums.Parentesco
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pessoa?: PessoaUpdateOneRequiredWithoutSolidarioNestedInput
    emprestimo?: EmprestimoSolidarioUpdateManyWithoutSolidarioNestedInput
    user?: UserUpdateOneRequiredWithoutSolidarioNestedInput
  }

  export type SolidarioUncheckedUpdateWithoutCreditoInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumAvalFieldUpdateOperationsInput | $Enums.Aval
    parentesco?: EnumParentescoFieldUpdateOperationsInput | $Enums.Parentesco
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprestimo?: EmprestimoSolidarioUncheckedUpdateManyWithoutSolidarioNestedInput
  }

  export type CreditoUpsertWithoutSolidarioInput = {
    update: XOR<CreditoUpdateWithoutSolidarioInput, CreditoUncheckedUpdateWithoutSolidarioInput>
    create: XOR<CreditoCreateWithoutSolidarioInput, CreditoUncheckedCreateWithoutSolidarioInput>
    where?: CreditoWhereInput
  }

  export type CreditoUpdateToOneWithWhereWithoutSolidarioInput = {
    where?: CreditoWhereInput
    data: XOR<CreditoUpdateWithoutSolidarioInput, CreditoUncheckedUpdateWithoutSolidarioInput>
  }

  export type CreditoUpdateWithoutSolidarioInput = {
    tipo?: EnumProdutoFieldUpdateOperationsInput | $Enums.Produto
    valor?: FloatFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    juro?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devedor?: DevedorUpdateOneRequiredWithoutCreditoNestedInput
  }

  export type CreditoUncheckedUpdateWithoutSolidarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumProdutoFieldUpdateOperationsInput | $Enums.Produto
    valor?: FloatFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    juro?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    devedor_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestidorCreateWithoutDiversificacaoInput = {
    maior_risco: boolean
    maior_seguranca: boolean
    saque_antecipado: boolean
    fundo_protegido: boolean
    estado?: boolean
    partilhar_emprestimo: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvestidorInput
  }

  export type InvestidorUncheckedCreateWithoutDiversificacaoInput = {
    id?: number
    maior_risco: boolean
    maior_seguranca: boolean
    saque_antecipado: boolean
    fundo_protegido: boolean
    estado?: boolean
    partilhar_emprestimo: boolean
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestidorCreateOrConnectWithoutDiversificacaoInput = {
    where: InvestidorWhereUniqueInput
    create: XOR<InvestidorCreateWithoutDiversificacaoInput, InvestidorUncheckedCreateWithoutDiversificacaoInput>
  }

  export type EmprestimoCreateWithoutDiversificacaoInput = {
    valor: number
    juro_proponente: number
    taxa_investidor: number
    prestacao: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    createdAt?: Date | string
    updatedAt?: Date | string
    solidario?: EmprestimoSolidarioCreateNestedManyWithoutEmprestimoInput
    proponente: ProponenteCreateNestedOneWithoutEmprestimoInput
  }

  export type EmprestimoUncheckedCreateWithoutDiversificacaoInput = {
    id?: number
    valor: number
    juro_proponente: number
    taxa_investidor: number
    prestacao: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    proponente_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    solidario?: EmprestimoSolidarioUncheckedCreateNestedManyWithoutEmprestimoInput
  }

  export type EmprestimoCreateOrConnectWithoutDiversificacaoInput = {
    where: EmprestimoWhereUniqueInput
    create: XOR<EmprestimoCreateWithoutDiversificacaoInput, EmprestimoUncheckedCreateWithoutDiversificacaoInput>
  }

  export type InvestidorUpsertWithoutDiversificacaoInput = {
    update: XOR<InvestidorUpdateWithoutDiversificacaoInput, InvestidorUncheckedUpdateWithoutDiversificacaoInput>
    create: XOR<InvestidorCreateWithoutDiversificacaoInput, InvestidorUncheckedCreateWithoutDiversificacaoInput>
    where?: InvestidorWhereInput
  }

  export type InvestidorUpdateToOneWithWhereWithoutDiversificacaoInput = {
    where?: InvestidorWhereInput
    data: XOR<InvestidorUpdateWithoutDiversificacaoInput, InvestidorUncheckedUpdateWithoutDiversificacaoInput>
  }

  export type InvestidorUpdateWithoutDiversificacaoInput = {
    maior_risco?: BoolFieldUpdateOperationsInput | boolean
    maior_seguranca?: BoolFieldUpdateOperationsInput | boolean
    saque_antecipado?: BoolFieldUpdateOperationsInput | boolean
    fundo_protegido?: BoolFieldUpdateOperationsInput | boolean
    estado?: BoolFieldUpdateOperationsInput | boolean
    partilhar_emprestimo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvestidorNestedInput
  }

  export type InvestidorUncheckedUpdateWithoutDiversificacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    maior_risco?: BoolFieldUpdateOperationsInput | boolean
    maior_seguranca?: BoolFieldUpdateOperationsInput | boolean
    saque_antecipado?: BoolFieldUpdateOperationsInput | boolean
    fundo_protegido?: BoolFieldUpdateOperationsInput | boolean
    estado?: BoolFieldUpdateOperationsInput | boolean
    partilhar_emprestimo?: BoolFieldUpdateOperationsInput | boolean
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmprestimoUpsertWithoutDiversificacaoInput = {
    update: XOR<EmprestimoUpdateWithoutDiversificacaoInput, EmprestimoUncheckedUpdateWithoutDiversificacaoInput>
    create: XOR<EmprestimoCreateWithoutDiversificacaoInput, EmprestimoUncheckedCreateWithoutDiversificacaoInput>
    where?: EmprestimoWhereInput
  }

  export type EmprestimoUpdateToOneWithWhereWithoutDiversificacaoInput = {
    where?: EmprestimoWhereInput
    data: XOR<EmprestimoUpdateWithoutDiversificacaoInput, EmprestimoUncheckedUpdateWithoutDiversificacaoInput>
  }

  export type EmprestimoUpdateWithoutDiversificacaoInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    juro_proponente?: IntFieldUpdateOperationsInput | number
    taxa_investidor?: IntFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solidario?: EmprestimoSolidarioUpdateManyWithoutEmprestimoNestedInput
    proponente?: ProponenteUpdateOneRequiredWithoutEmprestimoNestedInput
  }

  export type EmprestimoUncheckedUpdateWithoutDiversificacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    juro_proponente?: IntFieldUpdateOperationsInput | number
    taxa_investidor?: IntFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    proponente_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solidario?: EmprestimoSolidarioUncheckedUpdateManyWithoutEmprestimoNestedInput
  }

  export type UserCreateWithoutSaqueInput = {
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaCreateNestedOneWithoutUserInput
    documento?: DocumentoCreateNestedManyWithoutUserInput
    devedor?: DevedorCreateNestedOneWithoutUserInput
    investidor?: InvestidorCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoCreateNestedManyWithoutUserInput
    proponente?: ProponenteCreateNestedOneWithoutUserInput
    deposito?: DepositoCreateNestedManyWithoutUserInput
    carteira?: CarteiraCreateNestedOneWithoutUserInput
    papel?: PapelCreateNestedOneWithoutUserInput
    solidario?: SolidarioCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSaqueInput = {
    id?: number
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaUncheckedCreateNestedOneWithoutUserInput
    documento?: DocumentoUncheckedCreateNestedManyWithoutUserInput
    devedor?: DevedorUncheckedCreateNestedOneWithoutUserInput
    investidor?: InvestidorUncheckedCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoUncheckedCreateNestedManyWithoutUserInput
    proponente?: ProponenteUncheckedCreateNestedOneWithoutUserInput
    deposito?: DepositoUncheckedCreateNestedManyWithoutUserInput
    carteira?: CarteiraUncheckedCreateNestedOneWithoutUserInput
    papel?: PapelUncheckedCreateNestedOneWithoutUserInput
    solidario?: SolidarioUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSaqueInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSaqueInput, UserUncheckedCreateWithoutSaqueInput>
  }

  export type UserUpsertWithoutSaqueInput = {
    update: XOR<UserUpdateWithoutSaqueInput, UserUncheckedUpdateWithoutSaqueInput>
    create: XOR<UserCreateWithoutSaqueInput, UserUncheckedCreateWithoutSaqueInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSaqueInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSaqueInput, UserUncheckedUpdateWithoutSaqueInput>
  }

  export type UserUpdateWithoutSaqueInput = {
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUpdateOneWithoutUserNestedInput
    documento?: DocumentoUpdateManyWithoutUserNestedInput
    devedor?: DevedorUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUpdateOneWithoutUserNestedInput
    deposito?: DepositoUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUpdateOneWithoutUserNestedInput
    papel?: PapelUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSaqueInput = {
    id?: IntFieldUpdateOperationsInput | number
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUncheckedUpdateOneWithoutUserNestedInput
    documento?: DocumentoUncheckedUpdateManyWithoutUserNestedInput
    devedor?: DevedorUncheckedUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUncheckedUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUncheckedUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUncheckedUpdateOneWithoutUserNestedInput
    deposito?: DepositoUncheckedUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUncheckedUpdateOneWithoutUserNestedInput
    papel?: PapelUncheckedUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDepositoInput = {
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaCreateNestedOneWithoutUserInput
    documento?: DocumentoCreateNestedManyWithoutUserInput
    devedor?: DevedorCreateNestedOneWithoutUserInput
    investidor?: InvestidorCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoCreateNestedManyWithoutUserInput
    proponente?: ProponenteCreateNestedOneWithoutUserInput
    saque?: SaqueCreateNestedManyWithoutUserInput
    carteira?: CarteiraCreateNestedOneWithoutUserInput
    papel?: PapelCreateNestedOneWithoutUserInput
    solidario?: SolidarioCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDepositoInput = {
    id?: number
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaUncheckedCreateNestedOneWithoutUserInput
    documento?: DocumentoUncheckedCreateNestedManyWithoutUserInput
    devedor?: DevedorUncheckedCreateNestedOneWithoutUserInput
    investidor?: InvestidorUncheckedCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoUncheckedCreateNestedManyWithoutUserInput
    proponente?: ProponenteUncheckedCreateNestedOneWithoutUserInput
    saque?: SaqueUncheckedCreateNestedManyWithoutUserInput
    carteira?: CarteiraUncheckedCreateNestedOneWithoutUserInput
    papel?: PapelUncheckedCreateNestedOneWithoutUserInput
    solidario?: SolidarioUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDepositoInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepositoInput, UserUncheckedCreateWithoutDepositoInput>
  }

  export type UserUpsertWithoutDepositoInput = {
    update: XOR<UserUpdateWithoutDepositoInput, UserUncheckedUpdateWithoutDepositoInput>
    create: XOR<UserCreateWithoutDepositoInput, UserUncheckedCreateWithoutDepositoInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDepositoInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDepositoInput, UserUncheckedUpdateWithoutDepositoInput>
  }

  export type UserUpdateWithoutDepositoInput = {
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUpdateOneWithoutUserNestedInput
    documento?: DocumentoUpdateManyWithoutUserNestedInput
    devedor?: DevedorUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUpdateOneWithoutUserNestedInput
    saque?: SaqueUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUpdateOneWithoutUserNestedInput
    papel?: PapelUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDepositoInput = {
    id?: IntFieldUpdateOperationsInput | number
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUncheckedUpdateOneWithoutUserNestedInput
    documento?: DocumentoUncheckedUpdateManyWithoutUserNestedInput
    devedor?: DevedorUncheckedUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUncheckedUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUncheckedUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUncheckedUpdateOneWithoutUserNestedInput
    saque?: SaqueUncheckedUpdateManyWithoutUserNestedInput
    carteira?: CarteiraUncheckedUpdateOneWithoutUserNestedInput
    papel?: PapelUncheckedUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCarteiraInput = {
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaCreateNestedOneWithoutUserInput
    documento?: DocumentoCreateNestedManyWithoutUserInput
    devedor?: DevedorCreateNestedOneWithoutUserInput
    investidor?: InvestidorCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoCreateNestedManyWithoutUserInput
    proponente?: ProponenteCreateNestedOneWithoutUserInput
    saque?: SaqueCreateNestedManyWithoutUserInput
    deposito?: DepositoCreateNestedManyWithoutUserInput
    papel?: PapelCreateNestedOneWithoutUserInput
    solidario?: SolidarioCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCarteiraInput = {
    id?: number
    primeiro_nome: string
    segundo_nome: string
    password: string
    genero: $Enums.Genero
    bilhete: string
    telemovel: string
    email: string
    estado?: boolean
    pessoa?: PessoaUncheckedCreateNestedOneWithoutUserInput
    documento?: DocumentoUncheckedCreateNestedManyWithoutUserInput
    devedor?: DevedorUncheckedCreateNestedOneWithoutUserInput
    investidor?: InvestidorUncheckedCreateNestedOneWithoutUserInput
    reclamacao?: ReclamacaoUncheckedCreateNestedManyWithoutUserInput
    proponente?: ProponenteUncheckedCreateNestedOneWithoutUserInput
    saque?: SaqueUncheckedCreateNestedManyWithoutUserInput
    deposito?: DepositoUncheckedCreateNestedManyWithoutUserInput
    papel?: PapelUncheckedCreateNestedOneWithoutUserInput
    solidario?: SolidarioUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCarteiraInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCarteiraInput, UserUncheckedCreateWithoutCarteiraInput>
  }

  export type UserUpsertWithoutCarteiraInput = {
    update: XOR<UserUpdateWithoutCarteiraInput, UserUncheckedUpdateWithoutCarteiraInput>
    create: XOR<UserCreateWithoutCarteiraInput, UserUncheckedCreateWithoutCarteiraInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCarteiraInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCarteiraInput, UserUncheckedUpdateWithoutCarteiraInput>
  }

  export type UserUpdateWithoutCarteiraInput = {
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUpdateOneWithoutUserNestedInput
    documento?: DocumentoUpdateManyWithoutUserNestedInput
    devedor?: DevedorUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUpdateOneWithoutUserNestedInput
    saque?: SaqueUpdateManyWithoutUserNestedInput
    deposito?: DepositoUpdateManyWithoutUserNestedInput
    papel?: PapelUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCarteiraInput = {
    id?: IntFieldUpdateOperationsInput | number
    primeiro_nome?: StringFieldUpdateOperationsInput | string
    segundo_nome?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    genero?: EnumGeneroFieldUpdateOperationsInput | $Enums.Genero
    bilhete?: StringFieldUpdateOperationsInput | string
    telemovel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUncheckedUpdateOneWithoutUserNestedInput
    documento?: DocumentoUncheckedUpdateManyWithoutUserNestedInput
    devedor?: DevedorUncheckedUpdateOneWithoutUserNestedInput
    investidor?: InvestidorUncheckedUpdateOneWithoutUserNestedInput
    reclamacao?: ReclamacaoUncheckedUpdateManyWithoutUserNestedInput
    proponente?: ProponenteUncheckedUpdateOneWithoutUserNestedInput
    saque?: SaqueUncheckedUpdateManyWithoutUserNestedInput
    deposito?: DepositoUncheckedUpdateManyWithoutUserNestedInput
    papel?: PapelUncheckedUpdateOneWithoutUserNestedInput
    solidario?: SolidarioUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DevedorCreateWithoutPagamentoInput = {
    solicitacao?: number
    adimplencia?: number
    inadimplencia?: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDevedorInput
    credito?: CreditoCreateNestedManyWithoutDevedorInput
    movel?: MovelCreateNestedManyWithoutDevedorInput
  }

  export type DevedorUncheckedCreateWithoutPagamentoInput = {
    id?: number
    user_id: number
    solicitacao?: number
    adimplencia?: number
    inadimplencia?: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    credito?: CreditoUncheckedCreateNestedManyWithoutDevedorInput
    movel?: MovelUncheckedCreateNestedManyWithoutDevedorInput
  }

  export type DevedorCreateOrConnectWithoutPagamentoInput = {
    where: DevedorWhereUniqueInput
    create: XOR<DevedorCreateWithoutPagamentoInput, DevedorUncheckedCreateWithoutPagamentoInput>
  }

  export type DevedorUpsertWithoutPagamentoInput = {
    update: XOR<DevedorUpdateWithoutPagamentoInput, DevedorUncheckedUpdateWithoutPagamentoInput>
    create: XOR<DevedorCreateWithoutPagamentoInput, DevedorUncheckedCreateWithoutPagamentoInput>
    where?: DevedorWhereInput
  }

  export type DevedorUpdateToOneWithWhereWithoutPagamentoInput = {
    where?: DevedorWhereInput
    data: XOR<DevedorUpdateWithoutPagamentoInput, DevedorUncheckedUpdateWithoutPagamentoInput>
  }

  export type DevedorUpdateWithoutPagamentoInput = {
    solicitacao?: IntFieldUpdateOperationsInput | number
    adimplencia?: IntFieldUpdateOperationsInput | number
    inadimplencia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevedorNestedInput
    credito?: CreditoUpdateManyWithoutDevedorNestedInput
    movel?: MovelUpdateManyWithoutDevedorNestedInput
  }

  export type DevedorUncheckedUpdateWithoutPagamentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    solicitacao?: IntFieldUpdateOperationsInput | number
    adimplencia?: IntFieldUpdateOperationsInput | number
    inadimplencia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credito?: CreditoUncheckedUpdateManyWithoutDevedorNestedInput
    movel?: MovelUncheckedUpdateManyWithoutDevedorNestedInput
  }

  export type ProponenteCreateWithoutReembolsoInput = {
    solicitacao: number
    reembolsar: number
    satisfeitos: number
    insatisfeitos: number
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    emprestimo?: EmprestimoCreateNestedManyWithoutProponenteInput
    user: UserCreateNestedOneWithoutProponenteInput
  }

  export type ProponenteUncheckedCreateWithoutReembolsoInput = {
    id?: number
    solicitacao: number
    reembolsar: number
    satisfeitos: number
    insatisfeitos: number
    estado?: boolean
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emprestimo?: EmprestimoUncheckedCreateNestedManyWithoutProponenteInput
  }

  export type ProponenteCreateOrConnectWithoutReembolsoInput = {
    where: ProponenteWhereUniqueInput
    create: XOR<ProponenteCreateWithoutReembolsoInput, ProponenteUncheckedCreateWithoutReembolsoInput>
  }

  export type ProponenteUpsertWithoutReembolsoInput = {
    update: XOR<ProponenteUpdateWithoutReembolsoInput, ProponenteUncheckedUpdateWithoutReembolsoInput>
    create: XOR<ProponenteCreateWithoutReembolsoInput, ProponenteUncheckedCreateWithoutReembolsoInput>
    where?: ProponenteWhereInput
  }

  export type ProponenteUpdateToOneWithWhereWithoutReembolsoInput = {
    where?: ProponenteWhereInput
    data: XOR<ProponenteUpdateWithoutReembolsoInput, ProponenteUncheckedUpdateWithoutReembolsoInput>
  }

  export type ProponenteUpdateWithoutReembolsoInput = {
    solicitacao?: IntFieldUpdateOperationsInput | number
    reembolsar?: IntFieldUpdateOperationsInput | number
    satisfeitos?: IntFieldUpdateOperationsInput | number
    insatisfeitos?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprestimo?: EmprestimoUpdateManyWithoutProponenteNestedInput
    user?: UserUpdateOneRequiredWithoutProponenteNestedInput
  }

  export type ProponenteUncheckedUpdateWithoutReembolsoInput = {
    id?: IntFieldUpdateOperationsInput | number
    solicitacao?: IntFieldUpdateOperationsInput | number
    reembolsar?: IntFieldUpdateOperationsInput | number
    satisfeitos?: IntFieldUpdateOperationsInput | number
    insatisfeitos?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprestimo?: EmprestimoUncheckedUpdateManyWithoutProponenteNestedInput
  }

  export type DocumentoCreateManyUserInput = {
    id?: number
    tipo: $Enums.Comprovativo
    titulo: string
    extensao: string
    tamanho: string
    nome_original: string
    nome_salvado: string
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReclamacaoCreateManyUserInput = {
    id?: number
    estado?: boolean
    assunto: string
    conteudo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaqueCreateManyUserInput = {
    id?: number
    valor: number
    taxa: number
    estado?: boolean
    pendencia: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositoCreateManyUserInput = {
    id?: number
    valor: number
    estado?: boolean
    pendencia: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SolidarioCreateManyUserInput = {
    id?: number
    tipo: $Enums.Aval
    parentesco: $Enums.Parentesco
    taxa: number
    estado?: boolean
    pessoa_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentoUpdateWithoutUserInput = {
    tipo?: EnumComprovativoFieldUpdateOperationsInput | $Enums.Comprovativo
    titulo?: StringFieldUpdateOperationsInput | string
    extensao?: StringFieldUpdateOperationsInput | string
    tamanho?: StringFieldUpdateOperationsInput | string
    nome_original?: StringFieldUpdateOperationsInput | string
    nome_salvado?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentoUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumComprovativoFieldUpdateOperationsInput | $Enums.Comprovativo
    titulo?: StringFieldUpdateOperationsInput | string
    extensao?: StringFieldUpdateOperationsInput | string
    tamanho?: StringFieldUpdateOperationsInput | string
    nome_original?: StringFieldUpdateOperationsInput | string
    nome_salvado?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentoUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumComprovativoFieldUpdateOperationsInput | $Enums.Comprovativo
    titulo?: StringFieldUpdateOperationsInput | string
    extensao?: StringFieldUpdateOperationsInput | string
    tamanho?: StringFieldUpdateOperationsInput | string
    nome_original?: StringFieldUpdateOperationsInput | string
    nome_salvado?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReclamacaoUpdateWithoutUserInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    assunto?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReclamacaoUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    assunto?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReclamacaoUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    assunto?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaqueUpdateWithoutUserInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaqueUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaqueUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositoUpdateWithoutUserInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositoUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositoUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SolidarioUpdateWithoutUserInput = {
    tipo?: EnumAvalFieldUpdateOperationsInput | $Enums.Aval
    parentesco?: EnumParentescoFieldUpdateOperationsInput | $Enums.Parentesco
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pessoa?: PessoaUpdateOneRequiredWithoutSolidarioNestedInput
    emprestimo?: EmprestimoSolidarioUpdateManyWithoutSolidarioNestedInput
    credito?: CreditoSolidarioUpdateManyWithoutSolidarioNestedInput
  }

  export type SolidarioUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumAvalFieldUpdateOperationsInput | $Enums.Aval
    parentesco?: EnumParentescoFieldUpdateOperationsInput | $Enums.Parentesco
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprestimo?: EmprestimoSolidarioUncheckedUpdateManyWithoutSolidarioNestedInput
    credito?: CreditoSolidarioUncheckedUpdateManyWithoutSolidarioNestedInput
  }

  export type SolidarioUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumAvalFieldUpdateOperationsInput | $Enums.Aval
    parentesco?: EnumParentescoFieldUpdateOperationsInput | $Enums.Parentesco
    taxa?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pessoa_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PessoaCreateManyEmpregoInput = {
    id?: number
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado?: boolean
    nivel_instrucao: string
    data_nascimento: Date | string
    user_id: number
    residencia_id: number
  }

  export type PessoaUpdateWithoutEmpregoInput = {
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPessoaNestedInput
    residencia?: ResidenciaUpdateOneRequiredWithoutPessoaNestedInput
    conjugue?: ConjugueUpdateOneWithoutPessoaNestedInput
    solidario?: SolidarioUpdateOneWithoutPessoaNestedInput
    conta?: ContaUpdateOneWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateWithoutEmpregoInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    residencia_id?: IntFieldUpdateOperationsInput | number
    conjugue?: ConjugueUncheckedUpdateOneWithoutPessoaNestedInput
    solidario?: SolidarioUncheckedUpdateOneWithoutPessoaNestedInput
    conta?: ContaUncheckedUpdateOneWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateManyWithoutEmpregoInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    residencia_id?: IntFieldUpdateOperationsInput | number
  }

  export type PessoaCreateManyResidenciaInput = {
    id?: number
    estado_civil: $Enums.Estado
    provincia: string
    municipio: string
    profissao: string
    estado?: boolean
    nivel_instrucao: string
    data_nascimento: Date | string
    user_id: number
    emprego_id: number
  }

  export type PessoaUpdateWithoutResidenciaInput = {
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPessoaNestedInput
    emprego?: EmpregoUpdateOneRequiredWithoutPessoaNestedInput
    conjugue?: ConjugueUpdateOneWithoutPessoaNestedInput
    solidario?: SolidarioUpdateOneWithoutPessoaNestedInput
    conta?: ContaUpdateOneWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateWithoutResidenciaInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    emprego_id?: IntFieldUpdateOperationsInput | number
    conjugue?: ConjugueUncheckedUpdateOneWithoutPessoaNestedInput
    solidario?: SolidarioUncheckedUpdateOneWithoutPessoaNestedInput
    conta?: ContaUncheckedUpdateOneWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateManyWithoutResidenciaInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado_civil?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: StringFieldUpdateOperationsInput | string
    profissao?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    nivel_instrucao?: StringFieldUpdateOperationsInput | string
    data_nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    emprego_id?: IntFieldUpdateOperationsInput | number
  }

  export type CreditoCreateManyDevedorInput = {
    id?: number
    tipo: $Enums.Produto
    valor: number
    prestacao: number
    juro: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovelCreateManyDevedorInput = {
    id?: number
    modelo: $Enums.Modelo
    matricula: string
    detalhes: string
    estado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagamentoCreateManyDevedorInput = {
    id?: number
    valor: number
    detalhe: string
    prestacao: number
    estado?: boolean
    pendencia: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditoUpdateWithoutDevedorInput = {
    tipo?: EnumProdutoFieldUpdateOperationsInput | $Enums.Produto
    valor?: FloatFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    juro?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solidario?: CreditoSolidarioUpdateManyWithoutCreditoNestedInput
  }

  export type CreditoUncheckedUpdateWithoutDevedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumProdutoFieldUpdateOperationsInput | $Enums.Produto
    valor?: FloatFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    juro?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solidario?: CreditoSolidarioUncheckedUpdateManyWithoutCreditoNestedInput
  }

  export type CreditoUncheckedUpdateManyWithoutDevedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumProdutoFieldUpdateOperationsInput | $Enums.Produto
    valor?: FloatFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    juro?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovelUpdateWithoutDevedorInput = {
    modelo?: EnumModeloFieldUpdateOperationsInput | $Enums.Modelo
    matricula?: StringFieldUpdateOperationsInput | string
    detalhes?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovelUncheckedUpdateWithoutDevedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelo?: EnumModeloFieldUpdateOperationsInput | $Enums.Modelo
    matricula?: StringFieldUpdateOperationsInput | string
    detalhes?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovelUncheckedUpdateManyWithoutDevedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelo?: EnumModeloFieldUpdateOperationsInput | $Enums.Modelo
    matricula?: StringFieldUpdateOperationsInput | string
    detalhes?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoUpdateWithoutDevedorInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    detalhe?: StringFieldUpdateOperationsInput | string
    prestacao?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoUncheckedUpdateWithoutDevedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    detalhe?: StringFieldUpdateOperationsInput | string
    prestacao?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoUncheckedUpdateManyWithoutDevedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    detalhe?: StringFieldUpdateOperationsInput | string
    prestacao?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiversificacaoCreateManyInvestidorInput = {
    estado?: boolean
    emprestimo_id: number
    taxa: number
    protencao: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiversificacaoUpdateWithoutInvestidorInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    taxa?: IntFieldUpdateOperationsInput | number
    protencao?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprestimo?: EmprestimoUpdateOneRequiredWithoutDiversificacaoNestedInput
  }

  export type DiversificacaoUncheckedUpdateWithoutInvestidorInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    emprestimo_id?: IntFieldUpdateOperationsInput | number
    taxa?: IntFieldUpdateOperationsInput | number
    protencao?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiversificacaoUncheckedUpdateManyWithoutInvestidorInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    emprestimo_id?: IntFieldUpdateOperationsInput | number
    taxa?: IntFieldUpdateOperationsInput | number
    protencao?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmprestimoCreateManyProponenteInput = {
    id?: number
    valor: number
    juro_proponente: number
    taxa_investidor: number
    prestacao: number
    termino: Date | string
    estado?: boolean
    pendencia: boolean
    progresso: $Enums.Progresso
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReembolsoCreateManyProponenteInput = {
    id?: number
    valor: number
    prestacao: number
    estado?: boolean
    detalhe: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmprestimoUpdateWithoutProponenteInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    juro_proponente?: IntFieldUpdateOperationsInput | number
    taxa_investidor?: IntFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    diversificacao?: DiversificacaoUpdateManyWithoutEmprestimoNestedInput
    solidario?: EmprestimoSolidarioUpdateManyWithoutEmprestimoNestedInput
  }

  export type EmprestimoUncheckedUpdateWithoutProponenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    juro_proponente?: IntFieldUpdateOperationsInput | number
    taxa_investidor?: IntFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    diversificacao?: DiversificacaoUncheckedUpdateManyWithoutEmprestimoNestedInput
    solidario?: EmprestimoSolidarioUncheckedUpdateManyWithoutEmprestimoNestedInput
  }

  export type EmprestimoUncheckedUpdateManyWithoutProponenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    juro_proponente?: IntFieldUpdateOperationsInput | number
    taxa_investidor?: IntFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    termino?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    pendencia?: BoolFieldUpdateOperationsInput | boolean
    progresso?: EnumProgressoFieldUpdateOperationsInput | $Enums.Progresso
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReembolsoUpdateWithoutProponenteInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalhe?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReembolsoUncheckedUpdateWithoutProponenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalhe?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReembolsoUncheckedUpdateManyWithoutProponenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    prestacao?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalhe?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmprestimoSolidarioCreateManySolidarioInput = {
    estado?: boolean
    emprestimo_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditoSolidarioCreateManySolidarioInput = {
    estado?: boolean
    credito_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmprestimoSolidarioUpdateWithoutSolidarioInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprestimo?: EmprestimoUpdateOneRequiredWithoutSolidarioNestedInput
  }

  export type EmprestimoSolidarioUncheckedUpdateWithoutSolidarioInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    emprestimo_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmprestimoSolidarioUncheckedUpdateManyWithoutSolidarioInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    emprestimo_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditoSolidarioUpdateWithoutSolidarioInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credito?: CreditoUpdateOneRequiredWithoutSolidarioNestedInput
  }

  export type CreditoSolidarioUncheckedUpdateWithoutSolidarioInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    credito_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditoSolidarioUncheckedUpdateManyWithoutSolidarioInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    credito_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditoSolidarioCreateManyCreditoInput = {
    estado?: boolean
    solidario_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditoSolidarioUpdateWithoutCreditoInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solidario?: SolidarioUpdateOneRequiredWithoutCreditoNestedInput
  }

  export type CreditoSolidarioUncheckedUpdateWithoutCreditoInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    solidario_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditoSolidarioUncheckedUpdateManyWithoutCreditoInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    solidario_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiversificacaoCreateManyEmprestimoInput = {
    estado?: boolean
    investidor_id: number
    taxa: number
    protencao: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmprestimoSolidarioCreateManyEmprestimoInput = {
    estado?: boolean
    solidario_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiversificacaoUpdateWithoutEmprestimoInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    taxa?: IntFieldUpdateOperationsInput | number
    protencao?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investidor?: InvestidorUpdateOneRequiredWithoutDiversificacaoNestedInput
  }

  export type DiversificacaoUncheckedUpdateWithoutEmprestimoInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    investidor_id?: IntFieldUpdateOperationsInput | number
    taxa?: IntFieldUpdateOperationsInput | number
    protencao?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiversificacaoUncheckedUpdateManyWithoutEmprestimoInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    investidor_id?: IntFieldUpdateOperationsInput | number
    taxa?: IntFieldUpdateOperationsInput | number
    protencao?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmprestimoSolidarioUpdateWithoutEmprestimoInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solidario?: SolidarioUpdateOneRequiredWithoutEmprestimoNestedInput
  }

  export type EmprestimoSolidarioUncheckedUpdateWithoutEmprestimoInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    solidario_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmprestimoSolidarioUncheckedUpdateManyWithoutEmprestimoInput = {
    estado?: BoolFieldUpdateOperationsInput | boolean
    solidario_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}